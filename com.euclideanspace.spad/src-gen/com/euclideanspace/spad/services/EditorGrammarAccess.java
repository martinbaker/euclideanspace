/*
* generated by Xtext
*/

package com.euclideanspace.spad.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class EditorGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAbbrevKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cWSTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cCAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cCCategoryDefParserRuleCall_2_0_0 = (RuleCall)cCAssignment_2_0.eContents().get(0);
		private final Assignment cPAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cPPackageDefParserRuleCall_2_1_0 = (RuleCall)cPAssignment_2_1.eContents().get(0);
		private final Assignment cDAssignment_2_2 = (Assignment)cAlternatives_2.eContents().get(2);
		private final RuleCall cDDomainDefParserRuleCall_2_2_0 = (RuleCall)cDAssignment_2_2.eContents().get(0);
		private final RuleCall cATTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		/// * Copyright 2012 Martin John Baker
		// * 
		// * This file is part of EuclideanSpace.
		// *
		// *  EuclideanSpace is free software: you can redistribute it and/or modify
		// *  it under the terms of the GNU Affero General Public License as published by
		// *  the Free Software Foundation, either version 3 of the License, or
		// *  (at your option) any later version.
		// *
		// *  EuclideanSpace is distributed in the hope that it will be useful,
		// *  but WITHOUT ANY WARRANTY; without even the implied warranty of
		// *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		// *  GNU Affero General Public License for more details.
		// *
		// *  You should have received a copy of the GNU Affero General Public License
		// *  along with EuclideanSpace.  If not, see <http://www.gnu.org/licenses/>.
		// * / / * FriCAS parses SPAD using a type of parser known as a 'Pratt' parser.
		// * In this type of parser each operator has different binding powers for
		// * its left and right. The SPAD parser also has 'special handlers' for
		// * certain operators. In this type of parser there is less distinction made
		// * between expressions and statements, effectively everything is treated as
		// * an expression so in this context, not only are "+" and "*" operators
		// * but also other keywords such as "for" and "return".
		// * 
		// * Here we are using a LL(*) recursive-descent parser generator and this
		// * may not be able to exactly replicate the SPAD parser as described above
		// * 
		// * I have taken this information from s-parser.boot in src/interp
		// * so I suspect that it in valid only for the SPAD interpreter and not
		// * the compiler however I am hoping that this will be a close enough
		// * approximation for this purpose.
		// *
		// * So I will use the LED Table to approximate infix operator precedence
		// * and the NUD Table to approximate prefix operator precedence. So I
		// * have ordered both these tables in 
		// * 
		// * I have ordered the tables low (binds least tightly) to high (binds most tightly) as follows:
		// * 
		// * LED Table - infix operators
		// * ---------------------------
		// * ";", 81, 82, ["parse_SemiColon"]
		// * "|", 108, 111
		// * ",", 110, 111
		// * "when", 112, 190
		// * "otherwise", 119, 190, ["parse_Suffix"]
		// * "where", 121, 104
		// * "==>", "MDEF", 122, 121
		// * "==", "DEF", 122, 121
		// * "=>", 123, 103
		// * ":=", "LET", 125, 124]
		// * "\/", BACKSLASHSLASH 200, 201
		// * "/\", SLASHBACKSLASH 250, 251
		// * "or", 200, 201
		// * "and", 250, 251
		// * "has", 400, 400
		// * "add", 400, 120
		// * "case", 400, 400
		// * "in", 400, 400
		// * "~=", 400, 400
		// * "^=", 400, 400
		// * "=", 400, 400
		// * ">=", 400, 400
		// * "<=", 400, 400
		// * ">>", 400, 400
		// * "<<", 400, 400
		// * ">", 400, 400
		// * "<", 400, 400
		// * "isnt", 400, 400
		// * "is", 400, 400
		// * "..", "SEGMENT", 401, 699, ["parse_Seg"]
		// * "-", 700, 701
		// * "+", 700, 701
		// * "exquo", 800, 801
		// * "/", 800, 801
		// * "quo", 800, 801
		// * "mod", 800, 801
		// * "rem", 800, 801
		// * "*", 800, 801
		// * "^", 901, 900
		// * "**", 901, 900
		// * "+->", 995, 112
		// * "pretend", 995, 996
		// * "@", 996, 997
		// * "::", 996, 997
		// * ":", 996, 997
		// * "!", 1002, 1001
		// * "with", 2000, 400, ["parse_InfixWith"]
		// * "."
		// *
		// * NUD Table - prefix operators
		// * ----------------------------
		// *
		// * "catch", 0, 114
		// * "finally", 0, 114
		// * "then", 0, 114
		// * "else", 0, 114
		// * "|", 0, 190
		// * "import", 120, 0, ["parse_Import"]
		// * "<<", 122, 120, ["parse_LabelExpr"]
		// * ">>"
		// * "if", 130, 0, ["parse_Conditional"]
		// * "try", 130, 0, ["parse_Try"]
		// * "for", 130, 350, ["parse_Loop"
		// * "while", 130, 190, ["parse_Loop"]
		// * "until", 130, 190, ["parse_Loop"]
		// * "repeat", 130, 190, ["parse_Loop"]
		// * "return", 202, 201, ["parse_Return"]
		// * "leave", 202, 201, ["parse_Leave"]
		// * "exit", 202, 201, ["parse_Exit"]
		// * "~", 260, 259, nil
		// * ":", 194, 195
		// * "not", 260, 259, NIL
		// * "has", 400, 400
		// * "=", 400, 700
		// * "-", 701, 700
		// * "add", 900, 120
		// * "#", 999, 998
		// * "'", 999, 999, ["parse_Data"]
		// * "with", 1000, 300, ["parse_With"]
		// * "->", 1001, 1002
		// * "!", 1002, 1001
		// * "unless"
		// * "suchthat"
		// * "from"
		// * "iterate"
		// * "yield"
		// * 
		// * * / / *
		// * Parser starts here
		// * CategoryDef,PackageDef and DomainDef must end with newline to ensure that
		// * only an '@' at the start of a line will be taken as the end.
		// * 
		// * On this line whitespace (WS) is not hidden so is explicitly included.
		// * / Model:
		//	")abbrev" WS (c=CategoryDef | p=PackageDef | d=DomainDef) AT;
		public ParserRule getRule() { return rule; }

		//")abbrev" WS (c=CategoryDef | p=PackageDef | d=DomainDef) AT
		public Group getGroup() { return cGroup; }

		//")abbrev"
		public Keyword getAbbrevKeyword_0() { return cAbbrevKeyword_0; }

		//WS
		public RuleCall getWSTerminalRuleCall_1() { return cWSTerminalRuleCall_1; }

		//c=CategoryDef | p=PackageDef | d=DomainDef
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//c=CategoryDef
		public Assignment getCAssignment_2_0() { return cCAssignment_2_0; }

		//CategoryDef
		public RuleCall getCCategoryDefParserRuleCall_2_0_0() { return cCCategoryDefParserRuleCall_2_0_0; }

		//p=PackageDef
		public Assignment getPAssignment_2_1() { return cPAssignment_2_1; }

		//PackageDef
		public RuleCall getPPackageDefParserRuleCall_2_1_0() { return cPPackageDefParserRuleCall_2_1_0; }

		//d=DomainDef
		public Assignment getDAssignment_2_2() { return cDAssignment_2_2; }

		//DomainDef
		public RuleCall getDDomainDefParserRuleCall_2_2_0() { return cDDomainDefParserRuleCall_2_2_0; }

		//AT
		public RuleCall getATTerminalRuleCall_3() { return cATTerminalRuleCall_3; }
	}

	public class CategoryDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CategoryDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameCategoryKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cShortnameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cShortnameIDTerminalRuleCall_1_0 = (RuleCall)cShortnameAssignment_1.eContents().get(0);
		private final Assignment cLongnameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLongnameIDTerminalRuleCall_2_0 = (RuleCall)cLongnameAssignment_2.eContents().get(0);
		private final Assignment cLongname2Assignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLongname2IDTerminalRuleCall_3_0 = (RuleCall)cLongname2Assignment_3.eContents().get(0);
		private final Assignment cCpAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCpTypeParameterListParserRuleCall_4_0 = (RuleCall)cCpAssignment_4.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Keyword cCategoryKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final RuleCall cDEFTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Alternatives cAlternatives_8 = (Alternatives)cGroup.eContents().get(8);
		private final Group cGroup_8_0 = (Group)cAlternatives_8.eContents().get(0);
		private final Assignment cImplNameAssignment_8_0_0 = (Assignment)cGroup_8_0.eContents().get(0);
		private final RuleCall cImplNameTypeArgumentsParserRuleCall_8_0_0_0 = (RuleCall)cImplNameAssignment_8_0_0.eContents().get(0);
		private final Alternatives cAlternatives_8_0_1 = (Alternatives)cGroup_8_0.eContents().get(1);
		private final Group cGroup_8_0_1_0 = (Group)cAlternatives_8_0_1.eContents().get(0);
		private final Assignment cWAssignment_8_0_1_0_0 = (Assignment)cGroup_8_0_1_0.eContents().get(0);
		private final RuleCall cWWithPartParserRuleCall_8_0_1_0_0_0 = (RuleCall)cWAssignment_8_0_1_0_0.eContents().get(0);
		private final Assignment cAAssignment_8_0_1_0_1 = (Assignment)cGroup_8_0_1_0.eContents().get(1);
		private final RuleCall cAAddPartParserRuleCall_8_0_1_0_1_0 = (RuleCall)cAAssignment_8_0_1_0_1.eContents().get(0);
		private final Assignment cWh5Assignment_8_0_1_1 = (Assignment)cAlternatives_8_0_1.eContents().get(1);
		private final RuleCall cWh5WherePartParserRuleCall_8_0_1_1_0 = (RuleCall)cWh5Assignment_8_0_1_1.eContents().get(0);
		private final Group cGroup_8_1 = (Group)cAlternatives_8.eContents().get(1);
		private final RuleCall cLBRACETerminalRuleCall_8_1_0 = (RuleCall)cGroup_8_1.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_8_1_1 = (RuleCall)cGroup_8_1.eContents().get(1);
		private final Assignment cImplNameAssignment_8_1_2 = (Assignment)cGroup_8_1.eContents().get(2);
		private final RuleCall cImplNameTypeArgumentsParserRuleCall_8_1_2_0 = (RuleCall)cImplNameAssignment_8_1_2.eContents().get(0);
		private final Alternatives cAlternatives_8_1_3 = (Alternatives)cGroup_8_1.eContents().get(3);
		private final Group cGroup_8_1_3_0 = (Group)cAlternatives_8_1_3.eContents().get(0);
		private final Assignment cWAssignment_8_1_3_0_0 = (Assignment)cGroup_8_1_3_0.eContents().get(0);
		private final RuleCall cWWithPartParserRuleCall_8_1_3_0_0_0 = (RuleCall)cWAssignment_8_1_3_0_0.eContents().get(0);
		private final Assignment cAAssignment_8_1_3_0_1 = (Assignment)cGroup_8_1_3_0.eContents().get(1);
		private final RuleCall cAAddPartParserRuleCall_8_1_3_0_1_0 = (RuleCall)cAAssignment_8_1_3_0_1.eContents().get(0);
		private final Assignment cWh5Assignment_8_1_3_1 = (Assignment)cAlternatives_8_1_3.eContents().get(1);
		private final RuleCall cWh5WherePartParserRuleCall_8_1_3_1_0 = (RuleCall)cWh5Assignment_8_1_3_1.eContents().get(0);
		private final RuleCall cRBRACETerminalRuleCall_8_1_4 = (RuleCall)cGroup_8_1.eContents().get(4);
		private final RuleCall cNLTerminalRuleCall_8_1_5 = (RuleCall)cGroup_8_1.eContents().get(5);
		private final Assignment cA2Assignment_8_1_6 = (Assignment)cGroup_8_1.eContents().get(6);
		private final RuleCall cA2AddPartParserRuleCall_8_1_6_0 = (RuleCall)cA2Assignment_8_1_6.eContents().get(0);
		
		//////////// end of lexer rules ///////////////
		/// *
		// * longname and longname2 should both be ID and have the same value. Since the
		// * runtime values can't be checked by the parser this must be checked later.
		// * / CategoryDef hidden(WS, NL, SL_COMMENT):
		//	name="category" shortname=ID longname=ID longname2= / *[CategoryDef]* / ID cp=TypeParameterList? COLON "Category" DEF
		//	(implName=TypeArguments? (w=WithPart? a=AddPart? | wh5=WherePart) | LBRACE NL* implName=TypeArguments (w=WithPart?
		//	a=AddPart? | wh5=WherePart) RBRACE NL* a2=AddPart?);
		public ParserRule getRule() { return rule; }

		//name="category" shortname=ID longname=ID longname2= / *[CategoryDef]* / ID cp=TypeParameterList? COLON "Category" DEF
		//(implName=TypeArguments? (w=WithPart? a=AddPart? | wh5=WherePart) | LBRACE NL* implName=TypeArguments (w=WithPart?
		//a=AddPart? | wh5=WherePart) RBRACE NL* a2=AddPart?)
		public Group getGroup() { return cGroup; }

		//name="category"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"category"
		public Keyword getNameCategoryKeyword_0_0() { return cNameCategoryKeyword_0_0; }

		//shortname=ID
		public Assignment getShortnameAssignment_1() { return cShortnameAssignment_1; }

		//ID
		public RuleCall getShortnameIDTerminalRuleCall_1_0() { return cShortnameIDTerminalRuleCall_1_0; }

		//longname=ID
		public Assignment getLongnameAssignment_2() { return cLongnameAssignment_2; }

		//ID
		public RuleCall getLongnameIDTerminalRuleCall_2_0() { return cLongnameIDTerminalRuleCall_2_0; }

		//longname2= / *[CategoryDef]* / ID
		public Assignment getLongname2Assignment_3() { return cLongname2Assignment_3; }

		/// *[CategoryDef]* / ID
		public RuleCall getLongname2IDTerminalRuleCall_3_0() { return cLongname2IDTerminalRuleCall_3_0; }

		//cp=TypeParameterList?
		public Assignment getCpAssignment_4() { return cCpAssignment_4; }

		//TypeParameterList
		public RuleCall getCpTypeParameterListParserRuleCall_4_0() { return cCpTypeParameterListParserRuleCall_4_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5() { return cCOLONTerminalRuleCall_5; }

		//"Category"
		public Keyword getCategoryKeyword_6() { return cCategoryKeyword_6; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_7() { return cDEFTerminalRuleCall_7; }

		//implName=TypeArguments? (w=WithPart? a=AddPart? | wh5=WherePart) | LBRACE NL* implName=TypeArguments (w=WithPart?
		//a=AddPart? | wh5=WherePart) RBRACE NL* a2=AddPart?
		public Alternatives getAlternatives_8() { return cAlternatives_8; }

		//implName=TypeArguments? (w=WithPart? a=AddPart? | wh5=WherePart)
		public Group getGroup_8_0() { return cGroup_8_0; }

		//implName=TypeArguments?
		public Assignment getImplNameAssignment_8_0_0() { return cImplNameAssignment_8_0_0; }

		//TypeArguments
		public RuleCall getImplNameTypeArgumentsParserRuleCall_8_0_0_0() { return cImplNameTypeArgumentsParserRuleCall_8_0_0_0; }

		//w=WithPart? a=AddPart? | wh5=WherePart
		public Alternatives getAlternatives_8_0_1() { return cAlternatives_8_0_1; }

		//w=WithPart? a=AddPart?
		public Group getGroup_8_0_1_0() { return cGroup_8_0_1_0; }

		//w=WithPart?
		public Assignment getWAssignment_8_0_1_0_0() { return cWAssignment_8_0_1_0_0; }

		//WithPart
		public RuleCall getWWithPartParserRuleCall_8_0_1_0_0_0() { return cWWithPartParserRuleCall_8_0_1_0_0_0; }

		//a=AddPart?
		public Assignment getAAssignment_8_0_1_0_1() { return cAAssignment_8_0_1_0_1; }

		//AddPart
		public RuleCall getAAddPartParserRuleCall_8_0_1_0_1_0() { return cAAddPartParserRuleCall_8_0_1_0_1_0; }

		//wh5=WherePart
		public Assignment getWh5Assignment_8_0_1_1() { return cWh5Assignment_8_0_1_1; }

		//WherePart
		public RuleCall getWh5WherePartParserRuleCall_8_0_1_1_0() { return cWh5WherePartParserRuleCall_8_0_1_1_0; }

		//LBRACE NL* implName=TypeArguments (w=WithPart? a=AddPart? | wh5=WherePart) RBRACE NL* a2=AddPart?
		public Group getGroup_8_1() { return cGroup_8_1; }

		//LBRACE
		public RuleCall getLBRACETerminalRuleCall_8_1_0() { return cLBRACETerminalRuleCall_8_1_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_8_1_1() { return cNLTerminalRuleCall_8_1_1; }

		//implName=TypeArguments
		public Assignment getImplNameAssignment_8_1_2() { return cImplNameAssignment_8_1_2; }

		//TypeArguments
		public RuleCall getImplNameTypeArgumentsParserRuleCall_8_1_2_0() { return cImplNameTypeArgumentsParserRuleCall_8_1_2_0; }

		//w=WithPart? a=AddPart? | wh5=WherePart
		public Alternatives getAlternatives_8_1_3() { return cAlternatives_8_1_3; }

		//w=WithPart? a=AddPart?
		public Group getGroup_8_1_3_0() { return cGroup_8_1_3_0; }

		//w=WithPart?
		public Assignment getWAssignment_8_1_3_0_0() { return cWAssignment_8_1_3_0_0; }

		//WithPart
		public RuleCall getWWithPartParserRuleCall_8_1_3_0_0_0() { return cWWithPartParserRuleCall_8_1_3_0_0_0; }

		//a=AddPart?
		public Assignment getAAssignment_8_1_3_0_1() { return cAAssignment_8_1_3_0_1; }

		//AddPart
		public RuleCall getAAddPartParserRuleCall_8_1_3_0_1_0() { return cAAddPartParserRuleCall_8_1_3_0_1_0; }

		//wh5=WherePart
		public Assignment getWh5Assignment_8_1_3_1() { return cWh5Assignment_8_1_3_1; }

		//WherePart
		public RuleCall getWh5WherePartParserRuleCall_8_1_3_1_0() { return cWh5WherePartParserRuleCall_8_1_3_1_0; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_8_1_4() { return cRBRACETerminalRuleCall_8_1_4; }

		//NL*
		public RuleCall getNLTerminalRuleCall_8_1_5() { return cNLTerminalRuleCall_8_1_5; }

		//a2=AddPart?
		public Assignment getA2Assignment_8_1_6() { return cA2Assignment_8_1_6; }

		//AddPart
		public RuleCall getA2AddPartParserRuleCall_8_1_6_0() { return cA2AddPartParserRuleCall_8_1_6_0; }
	}

	public class PackageDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PackageDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNamePackageKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cShortnameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cShortnameIDTerminalRuleCall_1_0 = (RuleCall)cShortnameAssignment_1.eContents().get(0);
		private final Assignment cLongnameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLongnameIDTerminalRuleCall_2_0 = (RuleCall)cLongnameAssignment_2.eContents().get(0);
		private final Assignment cLongname2Assignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLongname2IDTerminalRuleCall_3_0 = (RuleCall)cLongname2Assignment_3.eContents().get(0);
		private final Assignment cCpAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCpTypeParameterListParserRuleCall_4_0 = (RuleCall)cCpAssignment_4.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Alternatives cAlternatives_6 = (Alternatives)cGroup.eContents().get(6);
		private final Group cGroup_6_0 = (Group)cAlternatives_6.eContents().get(0);
		private final Assignment cExportNameAssignment_6_0_0 = (Assignment)cGroup_6_0.eContents().get(0);
		private final RuleCall cExportNameIDTerminalRuleCall_6_0_0_0 = (RuleCall)cExportNameAssignment_6_0_0.eContents().get(0);
		private final RuleCall cDEFTerminalRuleCall_6_0_1 = (RuleCall)cGroup_6_0.eContents().get(1);
		private final Assignment cImplNameAssignment_6_0_2 = (Assignment)cGroup_6_0.eContents().get(2);
		private final RuleCall cImplNameIDTerminalRuleCall_6_0_2_0 = (RuleCall)cImplNameAssignment_6_0_2.eContents().get(0);
		private final Alternatives cAlternatives_6_0_3 = (Alternatives)cGroup_6_0.eContents().get(3);
		private final Assignment cWAssignment_6_0_3_0 = (Assignment)cAlternatives_6_0_3.eContents().get(0);
		private final RuleCall cWWithPartParserRuleCall_6_0_3_0_0 = (RuleCall)cWAssignment_6_0_3_0.eContents().get(0);
		private final Assignment cWh5Assignment_6_0_3_1 = (Assignment)cAlternatives_6_0_3.eContents().get(1);
		private final RuleCall cWh5WherePartParserRuleCall_6_0_3_1_0 = (RuleCall)cWh5Assignment_6_0_3_1.eContents().get(0);
		private final Group cGroup_6_1 = (Group)cAlternatives_6.eContents().get(1);
		private final Assignment cWAssignment_6_1_0 = (Assignment)cGroup_6_1.eContents().get(0);
		private final RuleCall cWWithPartParserRuleCall_6_1_0_0 = (RuleCall)cWAssignment_6_1_0.eContents().get(0);
		private final Group cGroup_6_1_1 = (Group)cGroup_6_1.eContents().get(1);
		private final RuleCall cDEFTerminalRuleCall_6_1_1_0 = (RuleCall)cGroup_6_1_1.eContents().get(0);
		private final Assignment cAdd2Assignment_6_1_1_1 = (Assignment)cGroup_6_1_1.eContents().get(1);
		private final RuleCall cAdd2AddPartParserRuleCall_6_1_1_1_0 = (RuleCall)cAdd2Assignment_6_1_1_1.eContents().get(0);
		
		/// *
		// * longname and longname2 should both be ID and have the same value. Since the
		// * runtime values can't be checked by the parser this must be checked later.
		// * / PackageDef hidden(WS, NL, SL_COMMENT):
		//	name="package" shortname=ID longname=ID longname2= / *[PackageDef]* / ID cp=TypeParameterList? COLON (exportName=ID DEF
		//	implName=ID (w=WithPart | wh5=WherePart) | w=WithPart (DEF add2=AddPart)?);
		public ParserRule getRule() { return rule; }

		//name="package" shortname=ID longname=ID longname2= / *[PackageDef]* / ID cp=TypeParameterList? COLON (exportName=ID DEF
		//implName=ID (w=WithPart | wh5=WherePart) | w=WithPart (DEF add2=AddPart)?)
		public Group getGroup() { return cGroup; }

		//name="package"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"package"
		public Keyword getNamePackageKeyword_0_0() { return cNamePackageKeyword_0_0; }

		//shortname=ID
		public Assignment getShortnameAssignment_1() { return cShortnameAssignment_1; }

		//ID
		public RuleCall getShortnameIDTerminalRuleCall_1_0() { return cShortnameIDTerminalRuleCall_1_0; }

		//longname=ID
		public Assignment getLongnameAssignment_2() { return cLongnameAssignment_2; }

		//ID
		public RuleCall getLongnameIDTerminalRuleCall_2_0() { return cLongnameIDTerminalRuleCall_2_0; }

		//longname2= / *[PackageDef]* / ID
		public Assignment getLongname2Assignment_3() { return cLongname2Assignment_3; }

		/// *[PackageDef]* / ID
		public RuleCall getLongname2IDTerminalRuleCall_3_0() { return cLongname2IDTerminalRuleCall_3_0; }

		//cp=TypeParameterList?
		public Assignment getCpAssignment_4() { return cCpAssignment_4; }

		//TypeParameterList
		public RuleCall getCpTypeParameterListParserRuleCall_4_0() { return cCpTypeParameterListParserRuleCall_4_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5() { return cCOLONTerminalRuleCall_5; }

		//exportName=ID DEF implName=ID (w=WithPart | wh5=WherePart) | w=WithPart (DEF add2=AddPart)?
		public Alternatives getAlternatives_6() { return cAlternatives_6; }

		//exportName=ID DEF implName=ID (w=WithPart | wh5=WherePart)
		public Group getGroup_6_0() { return cGroup_6_0; }

		//exportName=ID
		public Assignment getExportNameAssignment_6_0_0() { return cExportNameAssignment_6_0_0; }

		//ID
		public RuleCall getExportNameIDTerminalRuleCall_6_0_0_0() { return cExportNameIDTerminalRuleCall_6_0_0_0; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_6_0_1() { return cDEFTerminalRuleCall_6_0_1; }

		//implName=ID
		public Assignment getImplNameAssignment_6_0_2() { return cImplNameAssignment_6_0_2; }

		//ID
		public RuleCall getImplNameIDTerminalRuleCall_6_0_2_0() { return cImplNameIDTerminalRuleCall_6_0_2_0; }

		//w=WithPart | wh5=WherePart
		public Alternatives getAlternatives_6_0_3() { return cAlternatives_6_0_3; }

		//w=WithPart
		public Assignment getWAssignment_6_0_3_0() { return cWAssignment_6_0_3_0; }

		//WithPart
		public RuleCall getWWithPartParserRuleCall_6_0_3_0_0() { return cWWithPartParserRuleCall_6_0_3_0_0; }

		//wh5=WherePart
		public Assignment getWh5Assignment_6_0_3_1() { return cWh5Assignment_6_0_3_1; }

		//WherePart
		public RuleCall getWh5WherePartParserRuleCall_6_0_3_1_0() { return cWh5WherePartParserRuleCall_6_0_3_1_0; }

		//w=WithPart (DEF add2=AddPart)?
		public Group getGroup_6_1() { return cGroup_6_1; }

		//w=WithPart
		public Assignment getWAssignment_6_1_0() { return cWAssignment_6_1_0; }

		//WithPart
		public RuleCall getWWithPartParserRuleCall_6_1_0_0() { return cWWithPartParserRuleCall_6_1_0_0; }

		//(DEF add2=AddPart)?
		public Group getGroup_6_1_1() { return cGroup_6_1_1; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_6_1_1_0() { return cDEFTerminalRuleCall_6_1_1_0; }

		//add2=AddPart
		public Assignment getAdd2Assignment_6_1_1_1() { return cAdd2Assignment_6_1_1_1; }

		//AddPart
		public RuleCall getAdd2AddPartParserRuleCall_6_1_1_1_0() { return cAdd2AddPartParserRuleCall_6_1_1_1_0; }
	}

	public class DomainDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameDomainKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cShortname5Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cShortname5IDTerminalRuleCall_1_0 = (RuleCall)cShortname5Assignment_1.eContents().get(0);
		private final Assignment cLongname5Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLongname5IDTerminalRuleCall_2_0 = (RuleCall)cLongname5Assignment_2.eContents().get(0);
		private final Assignment cLongname6Assignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLongname6IDTerminalRuleCall_3_0 = (RuleCall)cLongname6Assignment_3.eContents().get(0);
		private final Assignment cCp5Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCp5TypeParameterListParserRuleCall_4_0 = (RuleCall)cCp5Assignment_4.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Assignment cExportNameAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cExportNameIDTerminalRuleCall_6_0 = (RuleCall)cExportNameAssignment_6.eContents().get(0);
		private final Assignment cCp6Assignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cCp6TypeParameterListParserRuleCall_7_0 = (RuleCall)cCp6Assignment_7.eContents().get(0);
		private final RuleCall cDEFTerminalRuleCall_8 = (RuleCall)cGroup.eContents().get(8);
		private final Assignment cImplName5Assignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cImplName5IDTerminalRuleCall_9_0 = (RuleCall)cImplName5Assignment_9.eContents().get(0);
		private final Alternatives cAlternatives_10 = (Alternatives)cGroup.eContents().get(10);
		private final Assignment cWAssignment_10_0 = (Assignment)cAlternatives_10.eContents().get(0);
		private final RuleCall cWWithPartParserRuleCall_10_0_0 = (RuleCall)cWAssignment_10_0.eContents().get(0);
		private final Assignment cWh5Assignment_10_1 = (Assignment)cAlternatives_10.eContents().get(1);
		private final RuleCall cWh5WherePartParserRuleCall_10_1_0 = (RuleCall)cWh5Assignment_10_1.eContents().get(0);
		private final Assignment cAAssignment_10_2 = (Assignment)cAlternatives_10.eContents().get(2);
		private final RuleCall cAAddPartParserRuleCall_10_2_0 = (RuleCall)cAAssignment_10_2.eContents().get(0);
		
		/// *
		// * longname and longname2 should both be ID and have the same value. Since the
		// * runtime values can't be checked by the parser this must be checked later.
		// * / DomainDef hidden(WS, NL, SL_COMMENT):
		//	name="domain" shortname5=ID longname5=ID longname6= / *[DomainDef]* / ID cp5=TypeParameterList? COLON exportName=ID
		//	cp6=TypeParameterList? DEF implName5=ID? (w=WithPart | wh5=WherePart | a=AddPart);
		public ParserRule getRule() { return rule; }

		//name="domain" shortname5=ID longname5=ID longname6= / *[DomainDef]* / ID cp5=TypeParameterList? COLON exportName=ID
		//cp6=TypeParameterList? DEF implName5=ID? (w=WithPart | wh5=WherePart | a=AddPart)
		public Group getGroup() { return cGroup; }

		//name="domain"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"domain"
		public Keyword getNameDomainKeyword_0_0() { return cNameDomainKeyword_0_0; }

		//shortname5=ID
		public Assignment getShortname5Assignment_1() { return cShortname5Assignment_1; }

		//ID
		public RuleCall getShortname5IDTerminalRuleCall_1_0() { return cShortname5IDTerminalRuleCall_1_0; }

		//longname5=ID
		public Assignment getLongname5Assignment_2() { return cLongname5Assignment_2; }

		//ID
		public RuleCall getLongname5IDTerminalRuleCall_2_0() { return cLongname5IDTerminalRuleCall_2_0; }

		//longname6= / *[DomainDef]* / ID
		public Assignment getLongname6Assignment_3() { return cLongname6Assignment_3; }

		/// *[DomainDef]* / ID
		public RuleCall getLongname6IDTerminalRuleCall_3_0() { return cLongname6IDTerminalRuleCall_3_0; }

		//cp5=TypeParameterList?
		public Assignment getCp5Assignment_4() { return cCp5Assignment_4; }

		//TypeParameterList
		public RuleCall getCp5TypeParameterListParserRuleCall_4_0() { return cCp5TypeParameterListParserRuleCall_4_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5() { return cCOLONTerminalRuleCall_5; }

		//exportName=ID
		public Assignment getExportNameAssignment_6() { return cExportNameAssignment_6; }

		//ID
		public RuleCall getExportNameIDTerminalRuleCall_6_0() { return cExportNameIDTerminalRuleCall_6_0; }

		//cp6=TypeParameterList?
		public Assignment getCp6Assignment_7() { return cCp6Assignment_7; }

		//TypeParameterList
		public RuleCall getCp6TypeParameterListParserRuleCall_7_0() { return cCp6TypeParameterListParserRuleCall_7_0; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_8() { return cDEFTerminalRuleCall_8; }

		//implName5=ID?
		public Assignment getImplName5Assignment_9() { return cImplName5Assignment_9; }

		//ID
		public RuleCall getImplName5IDTerminalRuleCall_9_0() { return cImplName5IDTerminalRuleCall_9_0; }

		//w=WithPart | wh5=WherePart | a=AddPart
		public Alternatives getAlternatives_10() { return cAlternatives_10; }

		//w=WithPart
		public Assignment getWAssignment_10_0() { return cWAssignment_10_0; }

		//WithPart
		public RuleCall getWWithPartParserRuleCall_10_0_0() { return cWWithPartParserRuleCall_10_0_0; }

		//wh5=WherePart
		public Assignment getWh5Assignment_10_1() { return cWh5Assignment_10_1; }

		//WherePart
		public RuleCall getWh5WherePartParserRuleCall_10_1_0() { return cWh5WherePartParserRuleCall_10_1_0; }

		//a=AddPart
		public Assignment getAAssignment_10_2() { return cAAssignment_10_2; }

		//AddPart
		public RuleCall getAAddPartParserRuleCall_10_2_0() { return cAAddPartParserRuleCall_10_2_0; }
	}

	public class WherePartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WherePart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameWhereKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLBRACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cWhereAssigAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cWhereAssigWhereAssignmentsParserRuleCall_4_0_0 = (RuleCall)cWhereAssigAssignment_4_0.eContents().get(0);
		private final Alternatives cAlternatives_4_1 = (Alternatives)cGroup_4.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_4_1_0 = (RuleCall)cAlternatives_4_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_4_1_1 = (RuleCall)cAlternatives_4_1.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cLongname8Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cLongname8IDTerminalRuleCall_5_0_0 = (RuleCall)cLongname8Assignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Alternatives cAlternatives_5_1_0 = (Alternatives)cGroup_5_1.eContents().get(0);
		private final RuleCall cDEFTerminalRuleCall_5_1_0_0 = (RuleCall)cAlternatives_5_1_0.eContents().get(0);
		private final RuleCall cMDEFTerminalRuleCall_5_1_0_1 = (RuleCall)cAlternatives_5_1_0.eContents().get(1);
		private final Assignment cImpAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cImpTypeExpressionParserRuleCall_5_1_1_0 = (RuleCall)cImpAssignment_5_1_1.eContents().get(0);
		private final Assignment cW8Assignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cW8WithPartParserRuleCall_5_2_0 = (RuleCall)cW8Assignment_5_2.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Group cGroup_6_0 = (Group)cGroup_6.eContents().get(0);
		private final Assignment cLongname9Assignment_6_0_0 = (Assignment)cGroup_6_0.eContents().get(0);
		private final RuleCall cLongname9IDTerminalRuleCall_6_0_0_0 = (RuleCall)cLongname9Assignment_6_0_0.eContents().get(0);
		private final Alternatives cAlternatives_6_0_1 = (Alternatives)cGroup_6_0.eContents().get(1);
		private final RuleCall cDEFTerminalRuleCall_6_0_1_0 = (RuleCall)cAlternatives_6_0_1.eContents().get(0);
		private final RuleCall cMDEFTerminalRuleCall_6_0_1_1 = (RuleCall)cAlternatives_6_0_1.eContents().get(1);
		private final Group cGroup_6_1 = (Group)cGroup_6.eContents().get(1);
		private final Assignment cFsAssignment_6_1_0 = (Assignment)cGroup_6_1.eContents().get(0);
		private final RuleCall cFsIDTerminalRuleCall_6_1_0_0 = (RuleCall)cFsAssignment_6_1_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_6_1_1 = (RuleCall)cGroup_6_1.eContents().get(1);
		private final Assignment cPar2Assignment_6_1_2 = (Assignment)cGroup_6_1.eContents().get(2);
		private final RuleCall cPar2IDTerminalRuleCall_6_1_2_0 = (RuleCall)cPar2Assignment_6_1_2.eContents().get(0);
		private final Group cGroup_6_1_3 = (Group)cGroup_6_1.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_6_1_3_0 = (RuleCall)cGroup_6_1_3.eContents().get(0);
		private final Assignment cPar3Assignment_6_1_3_1 = (Assignment)cGroup_6_1_3.eContents().get(1);
		private final RuleCall cPar3IDTerminalRuleCall_6_1_3_1_0 = (RuleCall)cPar3Assignment_6_1_3_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_6_1_4 = (RuleCall)cGroup_6_1.eContents().get(4);
		private final Assignment cAddAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cAddAddPartParserRuleCall_6_2_0 = (RuleCall)cAddAssignment_6_2.eContents().get(0);
		private final RuleCall cRBRACETerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final RuleCall cNLTerminalRuleCall_8 = (RuleCall)cGroup.eContents().get(8);
		
		/// *
		// * both category and domain can have 'where' part which holds overall information
		// * such as category/domain parameter information and general macros. This is
		// * followed by export('with') and import ('add') information.
		// * Forms allowed include:
		// * Exports == PlottablePlaneCurveCategory with {
		// * Exports ==> PlottablePlaneCurveCategory with {
		// * Exports ==> with {
		// * / WherePart hidden(WS, SL_COMMENT):
		//	name="where" NL* LBRACE NL* (whereAssig+=WhereAssignments (NL | SEMICOLON)+)* // with part
		//	(longname8=ID ((DEF | MDEF) imp=TypeExpression?)? w8=WithPart)? // add part
		//	((longname9=ID (DEF | MDEF))? (fs=ID LPAREN par2=ID? (COMMA par3+=ID)* RPAREN)? add=AddPart)? RBRACE NL+;
		public ParserRule getRule() { return rule; }

		//name="where" NL* LBRACE NL* (whereAssig+=WhereAssignments (NL | SEMICOLON)+)* // with part
		//(longname8=ID ((DEF | MDEF) imp=TypeExpression?)? w8=WithPart)? // add part
		//((longname9=ID (DEF | MDEF))? (fs=ID LPAREN par2=ID? (COMMA par3+=ID)* RPAREN)? add=AddPart)? RBRACE NL+
		public Group getGroup() { return cGroup; }

		//name="where"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"where"
		public Keyword getNameWhereKeyword_0_0() { return cNameWhereKeyword_0_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//LBRACE
		public RuleCall getLBRACETerminalRuleCall_2() { return cLBRACETerminalRuleCall_2; }

		//NL*
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//(whereAssig+=WhereAssignments (NL | SEMICOLON)+)*
		public Group getGroup_4() { return cGroup_4; }

		//whereAssig+=WhereAssignments
		public Assignment getWhereAssigAssignment_4_0() { return cWhereAssigAssignment_4_0; }

		//WhereAssignments
		public RuleCall getWhereAssigWhereAssignmentsParserRuleCall_4_0_0() { return cWhereAssigWhereAssignmentsParserRuleCall_4_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_4_1() { return cAlternatives_4_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_4_1_0() { return cNLTerminalRuleCall_4_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_4_1_1() { return cSEMICOLONTerminalRuleCall_4_1_1; }

		//(longname8=ID ((DEF | MDEF) imp=TypeExpression?)? w8=WithPart)?
		public Group getGroup_5() { return cGroup_5; }

		//longname8=ID
		public Assignment getLongname8Assignment_5_0() { return cLongname8Assignment_5_0; }

		//ID
		public RuleCall getLongname8IDTerminalRuleCall_5_0_0() { return cLongname8IDTerminalRuleCall_5_0_0; }

		//((DEF | MDEF) imp=TypeExpression?)?
		public Group getGroup_5_1() { return cGroup_5_1; }

		//DEF | MDEF
		public Alternatives getAlternatives_5_1_0() { return cAlternatives_5_1_0; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_5_1_0_0() { return cDEFTerminalRuleCall_5_1_0_0; }

		//MDEF
		public RuleCall getMDEFTerminalRuleCall_5_1_0_1() { return cMDEFTerminalRuleCall_5_1_0_1; }

		//imp=TypeExpression?
		public Assignment getImpAssignment_5_1_1() { return cImpAssignment_5_1_1; }

		//TypeExpression
		public RuleCall getImpTypeExpressionParserRuleCall_5_1_1_0() { return cImpTypeExpressionParserRuleCall_5_1_1_0; }

		//w8=WithPart
		public Assignment getW8Assignment_5_2() { return cW8Assignment_5_2; }

		//WithPart
		public RuleCall getW8WithPartParserRuleCall_5_2_0() { return cW8WithPartParserRuleCall_5_2_0; }

		//((longname9=ID (DEF | MDEF))? (fs=ID LPAREN par2=ID? (COMMA par3+=ID)* RPAREN)? add=AddPart)?
		public Group getGroup_6() { return cGroup_6; }

		//(longname9=ID (DEF | MDEF))?
		public Group getGroup_6_0() { return cGroup_6_0; }

		//longname9=ID
		public Assignment getLongname9Assignment_6_0_0() { return cLongname9Assignment_6_0_0; }

		//ID
		public RuleCall getLongname9IDTerminalRuleCall_6_0_0_0() { return cLongname9IDTerminalRuleCall_6_0_0_0; }

		//DEF | MDEF
		public Alternatives getAlternatives_6_0_1() { return cAlternatives_6_0_1; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_6_0_1_0() { return cDEFTerminalRuleCall_6_0_1_0; }

		//MDEF
		public RuleCall getMDEFTerminalRuleCall_6_0_1_1() { return cMDEFTerminalRuleCall_6_0_1_1; }

		//(fs=ID LPAREN par2=ID? (COMMA par3+=ID)* RPAREN)?
		public Group getGroup_6_1() { return cGroup_6_1; }

		//fs=ID
		public Assignment getFsAssignment_6_1_0() { return cFsAssignment_6_1_0; }

		//ID
		public RuleCall getFsIDTerminalRuleCall_6_1_0_0() { return cFsIDTerminalRuleCall_6_1_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_6_1_1() { return cLPARENTerminalRuleCall_6_1_1; }

		//par2=ID?
		public Assignment getPar2Assignment_6_1_2() { return cPar2Assignment_6_1_2; }

		//ID
		public RuleCall getPar2IDTerminalRuleCall_6_1_2_0() { return cPar2IDTerminalRuleCall_6_1_2_0; }

		//(COMMA par3+=ID)*
		public Group getGroup_6_1_3() { return cGroup_6_1_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_6_1_3_0() { return cCOMMATerminalRuleCall_6_1_3_0; }

		//par3+=ID
		public Assignment getPar3Assignment_6_1_3_1() { return cPar3Assignment_6_1_3_1; }

		//ID
		public RuleCall getPar3IDTerminalRuleCall_6_1_3_1_0() { return cPar3IDTerminalRuleCall_6_1_3_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_6_1_4() { return cRPARENTerminalRuleCall_6_1_4; }

		//add=AddPart
		public Assignment getAddAssignment_6_2() { return cAddAssignment_6_2; }

		//AddPart
		public RuleCall getAddAddPartParserRuleCall_6_2_0() { return cAddAddPartParserRuleCall_6_2_0; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_7() { return cRBRACETerminalRuleCall_7; }

		//NL+
		public RuleCall getNLTerminalRuleCall_8() { return cNLTerminalRuleCall_8; }
	}

	public class WhereAssignmentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhereAssignments");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMacroDefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cImportParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * each one must be on a separate line or separated by ';'
		// * need to add name=
		// * / WhereAssignments hidden(WS):
		//	VariableDeclaration | MacroDef | Import;
		public ParserRule getRule() { return rule; }

		//VariableDeclaration | MacroDef | Import
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_0() { return cVariableDeclarationParserRuleCall_0; }

		//MacroDef
		public RuleCall getMacroDefParserRuleCall_1() { return cMacroDefParserRuleCall_1; }

		//Import
		public RuleCall getImportParserRuleCall_2() { return cImportParserRuleCall_2; }
	}

	public class WithPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WithPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameWithKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLBRACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cFundecAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cFundecVariableDeclarationParserRuleCall_4_0_0 = (RuleCall)cFundecAssignment_4_0.eContents().get(0);
		private final Alternatives cAlternatives_4_1 = (Alternatives)cGroup_4.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_4_1_0 = (RuleCall)cAlternatives_4_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_4_1_1 = (RuleCall)cAlternatives_4_1.eContents().get(1);
		private final RuleCall cRBRACETerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cNLTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		/// *
		// * the 'where' part contains a 'with' part which holds export information
		// * such as function signatures (function declarations) but not function definitions.
		// * / WithPart hidden(WS, SL_COMMENT):
		//	name="with" NL* LBRACE NL* (fundec+=VariableDeclaration (NL | SEMICOLON)+)* RBRACE NL*;
		public ParserRule getRule() { return rule; }

		//name="with" NL* LBRACE NL* (fundec+=VariableDeclaration (NL | SEMICOLON)+)* RBRACE NL*
		public Group getGroup() { return cGroup; }

		//name="with"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"with"
		public Keyword getNameWithKeyword_0_0() { return cNameWithKeyword_0_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//LBRACE
		public RuleCall getLBRACETerminalRuleCall_2() { return cLBRACETerminalRuleCall_2; }

		//NL*
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//(fundec+=VariableDeclaration (NL | SEMICOLON)+)*
		public Group getGroup_4() { return cGroup_4; }

		//fundec+=VariableDeclaration
		public Assignment getFundecAssignment_4_0() { return cFundecAssignment_4_0; }

		//VariableDeclaration
		public RuleCall getFundecVariableDeclarationParserRuleCall_4_0_0() { return cFundecVariableDeclarationParserRuleCall_4_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_4_1() { return cAlternatives_4_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_4_1_0() { return cNLTerminalRuleCall_4_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_4_1_1() { return cSEMICOLONTerminalRuleCall_4_1_1; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_5() { return cRBRACETerminalRuleCall_5; }

		//NL*
		public RuleCall getNLTerminalRuleCall_6() { return cNLTerminalRuleCall_6; }
	}

	public class AddPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AddPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameAddKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLBRACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cTAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cTAddStatementsParserRuleCall_4_0_0 = (RuleCall)cTAssignment_4_0.eContents().get(0);
		private final Alternatives cAlternatives_4_1 = (Alternatives)cGroup_4.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_4_1_0 = (RuleCall)cAlternatives_4_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_4_1_1 = (RuleCall)cAlternatives_4_1.eContents().get(1);
		private final RuleCall cRBRACETerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final RuleCall cNLTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		/// *
		// * the 'where' part contains a 'add' part which holds function and other
		// * declarations.
		// * / AddPart hidden(WS, SL_COMMENT):
		//	name="add" NL* LBRACE NL* (t+=AddStatements (NL | SEMICOLON)+)* RBRACE NL*;
		public ParserRule getRule() { return rule; }

		//name="add" NL* LBRACE NL* (t+=AddStatements (NL | SEMICOLON)+)* RBRACE NL*
		public Group getGroup() { return cGroup; }

		//name="add"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"add"
		public Keyword getNameAddKeyword_0_0() { return cNameAddKeyword_0_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//LBRACE
		public RuleCall getLBRACETerminalRuleCall_2() { return cLBRACETerminalRuleCall_2; }

		//NL*
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//(t+=AddStatements (NL | SEMICOLON)+)*
		public Group getGroup_4() { return cGroup_4; }

		//t+=AddStatements
		public Assignment getTAssignment_4_0() { return cTAssignment_4_0; }

		//AddStatements
		public RuleCall getTAddStatementsParserRuleCall_4_0_0() { return cTAddStatementsParserRuleCall_4_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_4_1() { return cAlternatives_4_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_4_1_0() { return cNLTerminalRuleCall_4_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_4_1_1() { return cSEMICOLONTerminalRuleCall_4_1_1; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_5() { return cRBRACETerminalRuleCall_5; }

		//NL*
		public RuleCall getNLTerminalRuleCall_6() { return cNLTerminalRuleCall_6; }
	}

	public class AddStatementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AddStatements");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableDeclarationAssignParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cIfKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cT1Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cT1ExpressionParserRuleCall_2_1_0 = (RuleCall)cT1Assignment_2_1.eContents().get(0);
		private final Keyword cThenKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cT13Assignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cT13FunctionDefinitionBlockParserRuleCall_2_3_0 = (RuleCall)cT13Assignment_2_3.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cElseKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cT14Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cT14FunctionDefinitionBlockParserRuleCall_3_1_0 = (RuleCall)cT14Assignment_3_1.eContents().get(0);
		private final RuleCall cMacroDefParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cImportParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		/// *
		// * The add section of domain or package may contain multiple lines
		// * / AddStatements hidden(WS, SL_COMMENT):
		//	VariableDeclarationAssign | FunctionDefinition | "if" t1= // expression has form 'x has y'
		//	Expression "then" t13=FunctionDefinitionBlock | "else" t14=FunctionDefinitionBlock | MacroDef | Import;
		public ParserRule getRule() { return rule; }

		//VariableDeclarationAssign | FunctionDefinition | "if" t1= // expression has form 'x has y'
		//Expression "then" t13=FunctionDefinitionBlock | "else" t14=FunctionDefinitionBlock | MacroDef | Import
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableDeclarationAssign
		public RuleCall getVariableDeclarationAssignParserRuleCall_0() { return cVariableDeclarationAssignParserRuleCall_0; }

		//FunctionDefinition
		public RuleCall getFunctionDefinitionParserRuleCall_1() { return cFunctionDefinitionParserRuleCall_1; }

		//"if" t1= // expression has form 'x has y'
		//Expression "then" t13=FunctionDefinitionBlock
		public Group getGroup_2() { return cGroup_2; }

		//"if"
		public Keyword getIfKeyword_2_0() { return cIfKeyword_2_0; }

		//t1= // expression has form 'x has y'
		//Expression
		public Assignment getT1Assignment_2_1() { return cT1Assignment_2_1; }

		//// expression has form 'x has y'
		//Expression
		public RuleCall getT1ExpressionParserRuleCall_2_1_0() { return cT1ExpressionParserRuleCall_2_1_0; }

		//"then"
		public Keyword getThenKeyword_2_2() { return cThenKeyword_2_2; }

		//t13=FunctionDefinitionBlock
		public Assignment getT13Assignment_2_3() { return cT13Assignment_2_3; }

		//FunctionDefinitionBlock
		public RuleCall getT13FunctionDefinitionBlockParserRuleCall_2_3_0() { return cT13FunctionDefinitionBlockParserRuleCall_2_3_0; }

		//"else" t14=FunctionDefinitionBlock
		public Group getGroup_3() { return cGroup_3; }

		//"else"
		public Keyword getElseKeyword_3_0() { return cElseKeyword_3_0; }

		//t14=FunctionDefinitionBlock
		public Assignment getT14Assignment_3_1() { return cT14Assignment_3_1; }

		//FunctionDefinitionBlock
		public RuleCall getT14FunctionDefinitionBlockParserRuleCall_3_1_0() { return cT14FunctionDefinitionBlockParserRuleCall_3_1_0; }

		//MacroDef
		public RuleCall getMacroDefParserRuleCall_4() { return cMacroDefParserRuleCall_4; }

		//Import
		public RuleCall getImportParserRuleCall_5() { return cImportParserRuleCall_5; }
	}

	public class FunctionDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPar3Assignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPar3FunctionSignatureParserRuleCall_0_0 = (RuleCall)cPar3Assignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cPar4Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPar4TypeExpressionParserRuleCall_1_1_0 = (RuleCall)cPar4Assignment_1_1.eContents().get(0);
		private final RuleCall cDEFTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cPar5Assignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPar5StatementParserRuleCall_3_0 = (RuleCall)cPar5Assignment_3.eContents().get(0);
		
		/// * function definition in add part (called by AddStatements)
		// * has a form like:
		// * name(params) == statement
		// * or, for infix operators,
		// * a = b == statement
		// * or, for multiple statements,
		// * name(params) == {
		// *     statement
		// *     statement
		// * }
		// * some function definitions may be conditional like this:
		// * if % has finiteAggregate then {
		// * ... }
		// * / FunctionDefinition hidden(WS, SL_COMMENT):
		//	par3=FunctionSignature (COLON par4=TypeExpression)? DEF par5=Statement;
		public ParserRule getRule() { return rule; }

		//par3=FunctionSignature (COLON par4=TypeExpression)? DEF par5=Statement
		public Group getGroup() { return cGroup; }

		//par3=FunctionSignature
		public Assignment getPar3Assignment_0() { return cPar3Assignment_0; }

		//FunctionSignature
		public RuleCall getPar3FunctionSignatureParserRuleCall_0_0() { return cPar3FunctionSignatureParserRuleCall_0_0; }

		//(COLON par4=TypeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_1_0() { return cCOLONTerminalRuleCall_1_0; }

		//par4=TypeExpression
		public Assignment getPar4Assignment_1_1() { return cPar4Assignment_1_1; }

		//TypeExpression
		public RuleCall getPar4TypeExpressionParserRuleCall_1_1_0() { return cPar4TypeExpressionParserRuleCall_1_1_0; }

		//DEF
		public RuleCall getDEFTerminalRuleCall_2() { return cDEFTerminalRuleCall_2; }

		//par5=Statement
		public Assignment getPar5Assignment_3() { return cPar5Assignment_3; }

		//Statement
		public RuleCall getPar5StatementParserRuleCall_3_0() { return cPar5StatementParserRuleCall_3_0; }
	}

	public class FunctionDefinitionBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDefinitionBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFnDecBrAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFnDecBrLBRACETerminalRuleCall_0_0 = (RuleCall)cFnDecBrAssignment_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Assignment cFnDecBkAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final RuleCall cFnDecBkFunctionDefinitionParserRuleCall_2_0_0_0 = (RuleCall)cFnDecBkAssignment_2_0_0.eContents().get(0);
		private final Alternatives cAlternatives_2_0_1 = (Alternatives)cGroup_2_0.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_2_0_1_0 = (RuleCall)cAlternatives_2_0_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2_0_1_1 = (RuleCall)cAlternatives_2_0_1.eContents().get(1);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cVarsAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cVarsVariableDeclarationAssignParserRuleCall_2_1_0_0 = (RuleCall)cVarsAssignment_2_1_0.eContents().get(0);
		private final Alternatives cAlternatives_2_1_1 = (Alternatives)cGroup_2_1.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_2_1_1_0 = (RuleCall)cAlternatives_2_1_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2_1_1_1 = (RuleCall)cAlternatives_2_1_1.eContents().get(1);
		private final Group cGroup_2_2 = (Group)cAlternatives_2.eContents().get(2);
		private final Keyword cIfKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cT1Assignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cT1ExpressionParserRuleCall_2_2_1_0 = (RuleCall)cT1Assignment_2_2_1.eContents().get(0);
		private final Keyword cThenKeyword_2_2_2 = (Keyword)cGroup_2_2.eContents().get(2);
		private final Assignment cT13Assignment_2_2_3 = (Assignment)cGroup_2_2.eContents().get(3);
		private final RuleCall cT13FunctionDefinitionBlockParserRuleCall_2_2_3_0 = (RuleCall)cT13Assignment_2_2_3.eContents().get(0);
		private final Alternatives cAlternatives_2_2_4 = (Alternatives)cGroup_2_2.eContents().get(4);
		private final RuleCall cNLTerminalRuleCall_2_2_4_0 = (RuleCall)cAlternatives_2_2_4.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2_2_4_1 = (RuleCall)cAlternatives_2_2_4.eContents().get(1);
		private final Group cGroup_2_3 = (Group)cAlternatives_2.eContents().get(3);
		private final Keyword cElseKeyword_2_3_0 = (Keyword)cGroup_2_3.eContents().get(0);
		private final Assignment cT14Assignment_2_3_1 = (Assignment)cGroup_2_3.eContents().get(1);
		private final RuleCall cT14FunctionDefinitionBlockParserRuleCall_2_3_1_0 = (RuleCall)cT14Assignment_2_3_1.eContents().get(0);
		private final Alternatives cAlternatives_2_3_2 = (Alternatives)cGroup_2_3.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_2_3_2_0 = (RuleCall)cAlternatives_2_3_2.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2_3_2_1 = (RuleCall)cAlternatives_2_3_2.eContents().get(1);
		private final RuleCall cRBRACETerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		/// *
		// * called by 'AddStatements' rule.
		// * allows more add statements inside:
		// * if a has y then 'more add statements'
		// * / FunctionDefinitionBlock hidden(WS, SL_COMMENT):
		//	fnDecBr=LBRACE NL* (fnDecBk+=FunctionDefinition (NL | SEMICOLON)+ | vars+=VariableDeclarationAssign (NL | SEMICOLON)+
		//	| "if" t1+= // expression has form 'x has y'
		//	Expression "then" t13+=FunctionDefinitionBlock (NL | SEMICOLON)+ | "else" t14+=FunctionDefinitionBlock (NL |
		//	SEMICOLON)+)* RBRACE;
		public ParserRule getRule() { return rule; }

		//fnDecBr=LBRACE NL* (fnDecBk+=FunctionDefinition (NL | SEMICOLON)+ | vars+=VariableDeclarationAssign (NL | SEMICOLON)+ |
		//"if" t1+= // expression has form 'x has y'
		//Expression "then" t13+=FunctionDefinitionBlock (NL | SEMICOLON)+ | "else" t14+=FunctionDefinitionBlock (NL |
		//SEMICOLON)+)* RBRACE
		public Group getGroup() { return cGroup; }

		//fnDecBr=LBRACE
		public Assignment getFnDecBrAssignment_0() { return cFnDecBrAssignment_0; }

		//LBRACE
		public RuleCall getFnDecBrLBRACETerminalRuleCall_0_0() { return cFnDecBrLBRACETerminalRuleCall_0_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//(fnDecBk+=FunctionDefinition (NL | SEMICOLON)+ | vars+=VariableDeclarationAssign (NL | SEMICOLON)+ | "if" t1+= // expression has form 'x has y'
		//Expression "then" t13+=FunctionDefinitionBlock (NL | SEMICOLON)+ | "else" t14+=FunctionDefinitionBlock (NL |
		//SEMICOLON)+)*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//fnDecBk+=FunctionDefinition (NL | SEMICOLON)+
		public Group getGroup_2_0() { return cGroup_2_0; }

		//fnDecBk+=FunctionDefinition
		public Assignment getFnDecBkAssignment_2_0_0() { return cFnDecBkAssignment_2_0_0; }

		//FunctionDefinition
		public RuleCall getFnDecBkFunctionDefinitionParserRuleCall_2_0_0_0() { return cFnDecBkFunctionDefinitionParserRuleCall_2_0_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_2_0_1() { return cAlternatives_2_0_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_2_0_1_0() { return cNLTerminalRuleCall_2_0_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2_0_1_1() { return cSEMICOLONTerminalRuleCall_2_0_1_1; }

		//vars+=VariableDeclarationAssign (NL | SEMICOLON)+
		public Group getGroup_2_1() { return cGroup_2_1; }

		//vars+=VariableDeclarationAssign
		public Assignment getVarsAssignment_2_1_0() { return cVarsAssignment_2_1_0; }

		//VariableDeclarationAssign
		public RuleCall getVarsVariableDeclarationAssignParserRuleCall_2_1_0_0() { return cVarsVariableDeclarationAssignParserRuleCall_2_1_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_2_1_1() { return cAlternatives_2_1_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_2_1_1_0() { return cNLTerminalRuleCall_2_1_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2_1_1_1() { return cSEMICOLONTerminalRuleCall_2_1_1_1; }

		//"if" t1+= // expression has form 'x has y'
		//Expression "then" t13+=FunctionDefinitionBlock (NL | SEMICOLON)+
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"if"
		public Keyword getIfKeyword_2_2_0() { return cIfKeyword_2_2_0; }

		//t1+= // expression has form 'x has y'
		//Expression
		public Assignment getT1Assignment_2_2_1() { return cT1Assignment_2_2_1; }

		//// expression has form 'x has y'
		//Expression
		public RuleCall getT1ExpressionParserRuleCall_2_2_1_0() { return cT1ExpressionParserRuleCall_2_2_1_0; }

		//"then"
		public Keyword getThenKeyword_2_2_2() { return cThenKeyword_2_2_2; }

		//t13+=FunctionDefinitionBlock
		public Assignment getT13Assignment_2_2_3() { return cT13Assignment_2_2_3; }

		//FunctionDefinitionBlock
		public RuleCall getT13FunctionDefinitionBlockParserRuleCall_2_2_3_0() { return cT13FunctionDefinitionBlockParserRuleCall_2_2_3_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_2_2_4() { return cAlternatives_2_2_4; }

		//NL
		public RuleCall getNLTerminalRuleCall_2_2_4_0() { return cNLTerminalRuleCall_2_2_4_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2_2_4_1() { return cSEMICOLONTerminalRuleCall_2_2_4_1; }

		//"else" t14+=FunctionDefinitionBlock (NL | SEMICOLON)+
		public Group getGroup_2_3() { return cGroup_2_3; }

		//"else"
		public Keyword getElseKeyword_2_3_0() { return cElseKeyword_2_3_0; }

		//t14+=FunctionDefinitionBlock
		public Assignment getT14Assignment_2_3_1() { return cT14Assignment_2_3_1; }

		//FunctionDefinitionBlock
		public RuleCall getT14FunctionDefinitionBlockParserRuleCall_2_3_1_0() { return cT14FunctionDefinitionBlockParserRuleCall_2_3_1_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_2_3_2() { return cAlternatives_2_3_2; }

		//NL
		public RuleCall getNLTerminalRuleCall_2_3_2_0() { return cNLTerminalRuleCall_2_3_2_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2_3_2_1() { return cSEMICOLONTerminalRuleCall_2_3_2_1; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_3() { return cRBRACETerminalRuleCall_3; }
	}

	public class FunctionSignatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionSignature");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cFnNamAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cFnNamIDTerminalRuleCall_0_0_0 = (RuleCall)cFnNamAssignment_0_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Assignment cPar2Assignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cPar2VariableTypedParserRuleCall_0_2_0 = (RuleCall)cPar2Assignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_0_3_0 = (RuleCall)cGroup_0_3.eContents().get(0);
		private final Assignment cPar3Assignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cPar3VariableTypedParserRuleCall_0_3_1_0 = (RuleCall)cPar3Assignment_0_3_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_0_4 = (RuleCall)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cFnNamAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cFnNamIDTerminalRuleCall_1_0_0 = (RuleCall)cFnNamAssignment_1_0.eContents().get(0);
		private final Assignment cParAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParIDTerminalRuleCall_1_1_0 = (RuleCall)cParAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cT4Assignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cT4IDTerminalRuleCall_2_0_0 = (RuleCall)cT4Assignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final RuleCall cCOLONTerminalRuleCall_2_1_0 = (RuleCall)cGroup_2_1.eContents().get(0);
		private final RuleCall cPERCENTTerminalRuleCall_2_1_1 = (RuleCall)cGroup_2_1.eContents().get(1);
		private final Alternatives cAlternatives_2_2 = (Alternatives)cGroup_2.eContents().get(2);
		private final Assignment cB1Assignment_2_2_0 = (Assignment)cAlternatives_2_2.eContents().get(0);
		private final RuleCall cB1EQUALTerminalRuleCall_2_2_0_0 = (RuleCall)cB1Assignment_2_2_0.eContents().get(0);
		private final Assignment cB1Assignment_2_2_1 = (Assignment)cAlternatives_2_2.eContents().get(1);
		private final RuleCall cB1LTTerminalRuleCall_2_2_1_0 = (RuleCall)cB1Assignment_2_2_1.eContents().get(0);
		private final Assignment cB1Assignment_2_2_2 = (Assignment)cAlternatives_2_2.eContents().get(2);
		private final RuleCall cB1GTTerminalRuleCall_2_2_2_0 = (RuleCall)cB1Assignment_2_2_2.eContents().get(0);
		private final Assignment cB1Assignment_2_2_3 = (Assignment)cAlternatives_2_2.eContents().get(3);
		private final RuleCall cB1LETerminalRuleCall_2_2_3_0 = (RuleCall)cB1Assignment_2_2_3.eContents().get(0);
		private final Assignment cB1Assignment_2_2_4 = (Assignment)cAlternatives_2_2.eContents().get(4);
		private final RuleCall cB1GETerminalRuleCall_2_2_4_0 = (RuleCall)cB1Assignment_2_2_4.eContents().get(0);
		private final Assignment cB1Assignment_2_2_5 = (Assignment)cAlternatives_2_2.eContents().get(5);
		private final RuleCall cB1PLUSTerminalRuleCall_2_2_5_0 = (RuleCall)cB1Assignment_2_2_5.eContents().get(0);
		private final Assignment cB1Assignment_2_2_6 = (Assignment)cAlternatives_2_2.eContents().get(6);
		private final RuleCall cB1MINUSTerminalRuleCall_2_2_6_0 = (RuleCall)cB1Assignment_2_2_6.eContents().get(0);
		private final Assignment cB1Assignment_2_2_7 = (Assignment)cAlternatives_2_2.eContents().get(7);
		private final RuleCall cB1TIMESTerminalRuleCall_2_2_7_0 = (RuleCall)cB1Assignment_2_2_7.eContents().get(0);
		private final Assignment cB1Assignment_2_2_8 = (Assignment)cAlternatives_2_2.eContents().get(8);
		private final RuleCall cB1SLASHTerminalRuleCall_2_2_8_0 = (RuleCall)cB1Assignment_2_2_8.eContents().get(0);
		private final Assignment cB1Assignment_2_2_9 = (Assignment)cAlternatives_2_2.eContents().get(9);
		private final RuleCall cB1AMPERSANDTerminalRuleCall_2_2_9_0 = (RuleCall)cB1Assignment_2_2_9.eContents().get(0);
		private final Assignment cB1Assignment_2_2_10 = (Assignment)cAlternatives_2_2.eContents().get(10);
		private final RuleCall cB1BARTerminalRuleCall_2_2_10_0 = (RuleCall)cB1Assignment_2_2_10.eContents().get(0);
		private final Assignment cB1Assignment_2_2_11 = (Assignment)cAlternatives_2_2.eContents().get(11);
		private final RuleCall cB1CARATTerminalRuleCall_2_2_11_0 = (RuleCall)cB1Assignment_2_2_11.eContents().get(0);
		private final Assignment cT5Assignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cT5IDTerminalRuleCall_2_3_0 = (RuleCall)cT5Assignment_2_3.eContents().get(0);
		private final Assignment cB3Assignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cB3INTTerminalRuleCall_3_0 = (RuleCall)cB3Assignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Assignment cB2Assignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cB2MINUSTerminalRuleCall_4_0_0 = (RuleCall)cB2Assignment_4_0.eContents().get(0);
		private final Assignment cT6Assignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cT6IDTerminalRuleCall_4_1_0 = (RuleCall)cT6Assignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Assignment cB4Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cB4TILDETerminalRuleCall_5_0_0 = (RuleCall)cB4Assignment_5_0.eContents().get(0);
		private final Assignment cT7Assignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cT7IDTerminalRuleCall_5_1_0 = (RuleCall)cT7Assignment_5_1.eContents().get(0);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Assignment cB5Assignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final Keyword cB5NotKeyword_6_0_0 = (Keyword)cB5Assignment_6_0.eContents().get(0);
		private final Assignment cT8Assignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cT8IDTerminalRuleCall_6_1_0 = (RuleCall)cT8Assignment_6_1.eContents().get(0);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Assignment cB6Assignment_7_0 = (Assignment)cGroup_7.eContents().get(0);
		private final RuleCall cB6HASHTerminalRuleCall_7_0_0 = (RuleCall)cB6Assignment_7_0.eContents().get(0);
		private final Assignment cT8Assignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cT8IDTerminalRuleCall_7_1_0 = (RuleCall)cT8Assignment_7_1.eContents().get(0);
		
		/// * This is the first part of the function definition without the return type or
		// * the function implementation. Usually the function signature has a form like:
		// * name(params)
		// * We allow a single parameter to be given without brackets:
		// * name param
		// * We also allow some alternative forms to represent infix operators like:
		// * a = b to represent _=(a,b)
		// * or the following (this works but only for % we need it to work for every type)
		// * s:% = t:%
		// * or
		// * a > b to represent _>(a,b)
		// * 0 or 1 can be used as a function signature as a short form of
		// * _0() or _1()
		// * / FunctionSignature hidden(WS, SL_COMMENT):
		//	fnNam=ID LPAREN par2=VariableTyped? (COMMA par3+=VariableTyped)* RPAREN // can't specify '0' or '1' explicitly as this would affect lex
		//	// order
		//	| // fnNam=ID par2=VariableDeclaration causes recursive definition so use:
		//	fnNam=ID par=ID | t4=ID (COLON PERCENT)? //(COLON te1=TypeExpression)?
		//	(b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE | b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH | b1=AMPERSAND | b1=BAR |
		//	b1=CARAT) t5=ID | b3= // allows special form of function signature using '0' or '1'
		//	INT | b2=MINUS t6=ID | b4=TILDE t7=ID | b5="not" t8=ID | b6=HASH t8=ID;
		public ParserRule getRule() { return rule; }

		//fnNam=ID LPAREN par2=VariableTyped? (COMMA par3+=VariableTyped)* RPAREN // can't specify '0' or '1' explicitly as this would affect lex
		//// order
		//| // fnNam=ID par2=VariableDeclaration causes recursive definition so use:
		//fnNam=ID par=ID | t4=ID (COLON PERCENT)? //(COLON te1=TypeExpression)?
		//(b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE | b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH | b1=AMPERSAND | b1=BAR | b1=CARAT)
		//t5=ID | b3= // allows special form of function signature using '0' or '1'
		//INT | b2=MINUS t6=ID | b4=TILDE t7=ID | b5="not" t8=ID | b6=HASH t8=ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//fnNam=ID LPAREN par2=VariableTyped? (COMMA par3+=VariableTyped)* RPAREN
		public Group getGroup_0() { return cGroup_0; }

		//fnNam=ID
		public Assignment getFnNamAssignment_0_0() { return cFnNamAssignment_0_0; }

		//ID
		public RuleCall getFnNamIDTerminalRuleCall_0_0_0() { return cFnNamIDTerminalRuleCall_0_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_0_1() { return cLPARENTerminalRuleCall_0_1; }

		//par2=VariableTyped?
		public Assignment getPar2Assignment_0_2() { return cPar2Assignment_0_2; }

		//VariableTyped
		public RuleCall getPar2VariableTypedParserRuleCall_0_2_0() { return cPar2VariableTypedParserRuleCall_0_2_0; }

		//(COMMA par3+=VariableTyped)*
		public Group getGroup_0_3() { return cGroup_0_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_0_3_0() { return cCOMMATerminalRuleCall_0_3_0; }

		//par3+=VariableTyped
		public Assignment getPar3Assignment_0_3_1() { return cPar3Assignment_0_3_1; }

		//VariableTyped
		public RuleCall getPar3VariableTypedParserRuleCall_0_3_1_0() { return cPar3VariableTypedParserRuleCall_0_3_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_0_4() { return cRPARENTerminalRuleCall_0_4; }

		//// fnNam=ID par2=VariableDeclaration causes recursive definition so use:
		//fnNam=ID par=ID
		public Group getGroup_1() { return cGroup_1; }

		//// fnNam=ID par2=VariableDeclaration causes recursive definition so use:
		//fnNam=ID
		public Assignment getFnNamAssignment_1_0() { return cFnNamAssignment_1_0; }

		//ID
		public RuleCall getFnNamIDTerminalRuleCall_1_0_0() { return cFnNamIDTerminalRuleCall_1_0_0; }

		//par=ID
		public Assignment getParAssignment_1_1() { return cParAssignment_1_1; }

		//ID
		public RuleCall getParIDTerminalRuleCall_1_1_0() { return cParIDTerminalRuleCall_1_1_0; }

		//t4=ID (COLON PERCENT)? //(COLON te1=TypeExpression)?
		//(b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE | b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH | b1=AMPERSAND | b1=BAR | b1=CARAT)
		//t5=ID
		public Group getGroup_2() { return cGroup_2; }

		//t4=ID
		public Assignment getT4Assignment_2_0() { return cT4Assignment_2_0; }

		//ID
		public RuleCall getT4IDTerminalRuleCall_2_0_0() { return cT4IDTerminalRuleCall_2_0_0; }

		//(COLON PERCENT)?
		public Group getGroup_2_1() { return cGroup_2_1; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_2_1_0() { return cCOLONTerminalRuleCall_2_1_0; }

		//PERCENT
		public RuleCall getPERCENTTerminalRuleCall_2_1_1() { return cPERCENTTerminalRuleCall_2_1_1; }

		//b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE | b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH | b1=AMPERSAND | b1=BAR | b1=CARAT
		public Alternatives getAlternatives_2_2() { return cAlternatives_2_2; }

		//b1=EQUAL
		public Assignment getB1Assignment_2_2_0() { return cB1Assignment_2_2_0; }

		//EQUAL
		public RuleCall getB1EQUALTerminalRuleCall_2_2_0_0() { return cB1EQUALTerminalRuleCall_2_2_0_0; }

		//b1=LT
		public Assignment getB1Assignment_2_2_1() { return cB1Assignment_2_2_1; }

		//LT
		public RuleCall getB1LTTerminalRuleCall_2_2_1_0() { return cB1LTTerminalRuleCall_2_2_1_0; }

		//b1=GT
		public Assignment getB1Assignment_2_2_2() { return cB1Assignment_2_2_2; }

		//GT
		public RuleCall getB1GTTerminalRuleCall_2_2_2_0() { return cB1GTTerminalRuleCall_2_2_2_0; }

		//b1=LE
		public Assignment getB1Assignment_2_2_3() { return cB1Assignment_2_2_3; }

		//LE
		public RuleCall getB1LETerminalRuleCall_2_2_3_0() { return cB1LETerminalRuleCall_2_2_3_0; }

		//b1=GE
		public Assignment getB1Assignment_2_2_4() { return cB1Assignment_2_2_4; }

		//GE
		public RuleCall getB1GETerminalRuleCall_2_2_4_0() { return cB1GETerminalRuleCall_2_2_4_0; }

		//b1=PLUS
		public Assignment getB1Assignment_2_2_5() { return cB1Assignment_2_2_5; }

		//PLUS
		public RuleCall getB1PLUSTerminalRuleCall_2_2_5_0() { return cB1PLUSTerminalRuleCall_2_2_5_0; }

		//b1=MINUS
		public Assignment getB1Assignment_2_2_6() { return cB1Assignment_2_2_6; }

		//MINUS
		public RuleCall getB1MINUSTerminalRuleCall_2_2_6_0() { return cB1MINUSTerminalRuleCall_2_2_6_0; }

		//b1=TIMES
		public Assignment getB1Assignment_2_2_7() { return cB1Assignment_2_2_7; }

		//TIMES
		public RuleCall getB1TIMESTerminalRuleCall_2_2_7_0() { return cB1TIMESTerminalRuleCall_2_2_7_0; }

		//b1=SLASH
		public Assignment getB1Assignment_2_2_8() { return cB1Assignment_2_2_8; }

		//SLASH
		public RuleCall getB1SLASHTerminalRuleCall_2_2_8_0() { return cB1SLASHTerminalRuleCall_2_2_8_0; }

		//b1=AMPERSAND
		public Assignment getB1Assignment_2_2_9() { return cB1Assignment_2_2_9; }

		//AMPERSAND
		public RuleCall getB1AMPERSANDTerminalRuleCall_2_2_9_0() { return cB1AMPERSANDTerminalRuleCall_2_2_9_0; }

		//b1=BAR
		public Assignment getB1Assignment_2_2_10() { return cB1Assignment_2_2_10; }

		//BAR
		public RuleCall getB1BARTerminalRuleCall_2_2_10_0() { return cB1BARTerminalRuleCall_2_2_10_0; }

		//b1=CARAT
		public Assignment getB1Assignment_2_2_11() { return cB1Assignment_2_2_11; }

		//CARAT
		public RuleCall getB1CARATTerminalRuleCall_2_2_11_0() { return cB1CARATTerminalRuleCall_2_2_11_0; }

		//t5=ID
		public Assignment getT5Assignment_2_3() { return cT5Assignment_2_3; }

		//ID
		public RuleCall getT5IDTerminalRuleCall_2_3_0() { return cT5IDTerminalRuleCall_2_3_0; }

		//b3= // allows special form of function signature using '0' or '1'
		//INT
		public Assignment getB3Assignment_3() { return cB3Assignment_3; }

		//// allows special form of function signature using '0' or '1'
		//INT
		public RuleCall getB3INTTerminalRuleCall_3_0() { return cB3INTTerminalRuleCall_3_0; }

		//b2=MINUS t6=ID
		public Group getGroup_4() { return cGroup_4; }

		//b2=MINUS
		public Assignment getB2Assignment_4_0() { return cB2Assignment_4_0; }

		//MINUS
		public RuleCall getB2MINUSTerminalRuleCall_4_0_0() { return cB2MINUSTerminalRuleCall_4_0_0; }

		//t6=ID
		public Assignment getT6Assignment_4_1() { return cT6Assignment_4_1; }

		//ID
		public RuleCall getT6IDTerminalRuleCall_4_1_0() { return cT6IDTerminalRuleCall_4_1_0; }

		//b4=TILDE t7=ID
		public Group getGroup_5() { return cGroup_5; }

		//b4=TILDE
		public Assignment getB4Assignment_5_0() { return cB4Assignment_5_0; }

		//TILDE
		public RuleCall getB4TILDETerminalRuleCall_5_0_0() { return cB4TILDETerminalRuleCall_5_0_0; }

		//t7=ID
		public Assignment getT7Assignment_5_1() { return cT7Assignment_5_1; }

		//ID
		public RuleCall getT7IDTerminalRuleCall_5_1_0() { return cT7IDTerminalRuleCall_5_1_0; }

		//b5="not" t8=ID
		public Group getGroup_6() { return cGroup_6; }

		//b5="not"
		public Assignment getB5Assignment_6_0() { return cB5Assignment_6_0; }

		//"not"
		public Keyword getB5NotKeyword_6_0_0() { return cB5NotKeyword_6_0_0; }

		//t8=ID
		public Assignment getT8Assignment_6_1() { return cT8Assignment_6_1; }

		//ID
		public RuleCall getT8IDTerminalRuleCall_6_1_0() { return cT8IDTerminalRuleCall_6_1_0; }

		//b6=HASH t8=ID
		public Group getGroup_7() { return cGroup_7; }

		//b6=HASH
		public Assignment getB6Assignment_7_0() { return cB6Assignment_7_0; }

		//HASH
		public RuleCall getB6HASHTerminalRuleCall_7_0_0() { return cB6HASHTerminalRuleCall_7_0_0; }

		//t8=ID
		public Assignment getT8Assignment_7_1() { return cT8Assignment_7_1; }

		//ID
		public RuleCall getT8IDTerminalRuleCall_7_1_0() { return cT8IDTerminalRuleCall_7_1_0; }
	}

	public class MacroDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MacroDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMacronameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cMacronameIDTerminalRuleCall_0_0 = (RuleCall)cMacronameAssignment_0.eContents().get(0);
		private final RuleCall cMACROVALUETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		/// * macros provide a general textual substitution
		// * there are two forms:
		// * name ==> body
		// * and
		// * name macro == body 	
		// * / //MACRO val=ID NL;
		//MacroDef:
		//	macroname=ID MACROVALUE;
		public ParserRule getRule() { return rule; }

		//macroname=ID MACROVALUE
		public Group getGroup() { return cGroup; }

		//macroname=ID
		public Assignment getMacronameAssignment_0() { return cMacronameAssignment_0; }

		//ID
		public RuleCall getMacronameIDTerminalRuleCall_0_0() { return cMacronameIDTerminalRuleCall_0_0; }

		//MACROVALUE
		public RuleCall getMACROVALUETerminalRuleCall_1() { return cMACROVALUETerminalRuleCall_1; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImpnameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImpnameIDTerminalRuleCall_1_0 = (RuleCall)cImpnameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cLPARENTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cPar22Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPar22TypeExpressionParserRuleCall_2_1_0 = (RuleCall)cPar22Assignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_2_2_0 = (RuleCall)cGroup_2_2.eContents().get(0);
		private final Assignment cPar22Assignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cPar22TypeExpressionParserRuleCall_2_2_1_0 = (RuleCall)cPar22Assignment_2_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_2_3 = (RuleCall)cGroup_2.eContents().get(3);
		
		/// *
		// * import domain
		// * / Import hidden(WS):
		//	"import" impname+=ID+ (LPAREN par22+=TypeExpression (COMMA par22+=TypeExpression)* RPAREN)?;
		public ParserRule getRule() { return rule; }

		//"import" impname+=ID+ (LPAREN par22+=TypeExpression (COMMA par22+=TypeExpression)* RPAREN)?
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//impname+=ID+
		public Assignment getImpnameAssignment_1() { return cImpnameAssignment_1; }

		//ID
		public RuleCall getImpnameIDTerminalRuleCall_1_0() { return cImpnameIDTerminalRuleCall_1_0; }

		//(LPAREN par22+=TypeExpression (COMMA par22+=TypeExpression)* RPAREN)?
		public Group getGroup_2() { return cGroup_2; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_2_0() { return cLPARENTerminalRuleCall_2_0; }

		//par22+=TypeExpression
		public Assignment getPar22Assignment_2_1() { return cPar22Assignment_2_1; }

		//TypeExpression
		public RuleCall getPar22TypeExpressionParserRuleCall_2_1_0() { return cPar22TypeExpressionParserRuleCall_2_1_0; }

		//(COMMA par22+=TypeExpression)*
		public Group getGroup_2_2() { return cGroup_2_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_2_2_0() { return cCOMMATerminalRuleCall_2_2_0; }

		//par22+=TypeExpression
		public Assignment getPar22Assignment_2_2_1() { return cPar22Assignment_2_2_1; }

		//TypeExpression
		public RuleCall getPar22TypeExpressionParserRuleCall_2_2_1_0() { return cPar22TypeExpressionParserRuleCall_2_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_2_3() { return cRPARENTerminalRuleCall_2_3; }
	}

	public class VariableDeclarationBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclarationBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVardecbrAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVardecbrLBRACETerminalRuleCall_0_0 = (RuleCall)cVardecbrAssignment_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cVardecBlkAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cVardecBlkVariableDeclarationParserRuleCall_2_0_0 = (RuleCall)cVardecBlkAssignment_2_0.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_2_1_0 = (RuleCall)cAlternatives_2_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2_1_1 = (RuleCall)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cRBRACETerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		/// * Variable declaration in where and with sections:
		// * A 'variable' can be simple like:
		// * x:Float
		// * or something more complicated like:
		// * x:Record(newPt: Pt,type:  String)
		// * or it can be a function like:
		// * x:(Float,Integer) -> Float
		// * or it can be conditional like:
		// * if 
		// * / VariableDeclarationBlock hidden(WS, SL_COMMENT):
		//	vardecbr=LBRACE NL* (vardecBlk+=VariableDeclaration (NL | SEMICOLON)+)* RBRACE;
		public ParserRule getRule() { return rule; }

		//vardecbr=LBRACE NL* (vardecBlk+=VariableDeclaration (NL | SEMICOLON)+)* RBRACE
		public Group getGroup() { return cGroup; }

		//vardecbr=LBRACE
		public Assignment getVardecbrAssignment_0() { return cVardecbrAssignment_0; }

		//LBRACE
		public RuleCall getVardecbrLBRACETerminalRuleCall_0_0() { return cVardecbrLBRACETerminalRuleCall_0_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//(vardecBlk+=VariableDeclaration (NL | SEMICOLON)+)*
		public Group getGroup_2() { return cGroup_2; }

		//vardecBlk+=VariableDeclaration
		public Assignment getVardecBlkAssignment_2_0() { return cVardecBlkAssignment_2_0; }

		//VariableDeclaration
		public RuleCall getVardecBlkVariableDeclarationParserRuleCall_2_0_0() { return cVardecBlkVariableDeclarationParserRuleCall_2_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_2_1_0() { return cNLTerminalRuleCall_2_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2_1_1() { return cSEMICOLONTerminalRuleCall_2_1_1; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_3() { return cRBRACETerminalRuleCall_3; }
	}

	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cT1Assignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cT1ExpressionParserRuleCall_0_1_0 = (RuleCall)cT1Assignment_0_1.eContents().get(0);
		private final Keyword cThenKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cV1Assignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cV1TypeWithNameParserRuleCall_1_0_0 = (RuleCall)cV1Assignment_1_0.eContents().get(0);
		private final Assignment cV2Assignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cV2VariableDeclarationBlockParserRuleCall_1_1_0 = (RuleCall)cV2Assignment_1_1.eContents().get(0);
		
		/// * Variable declaration in where and with sections:
		// * A 'variable' can be simple like:
		// * x:Float
		// * or something more complicated like:
		// * x:Record(newPt: Pt,type:  String)
		// * or it can be a function like:
		// * x:(Float,Integer) -> Float
		// * or it can be conditional like:
		// * if 
		// * / VariableDeclaration hidden(WS, SL_COMMENT):
		//	("if" t1=Expression "then")? // expression has form 'x has y'
		//	(v1=TypeWithName | v2=VariableDeclarationBlock);
		public ParserRule getRule() { return rule; }

		//("if" t1=Expression "then")? // expression has form 'x has y'
		//(v1=TypeWithName | v2=VariableDeclarationBlock)
		public Group getGroup() { return cGroup; }

		//("if" t1=Expression "then")?
		public Group getGroup_0() { return cGroup_0; }

		//"if"
		public Keyword getIfKeyword_0_0() { return cIfKeyword_0_0; }

		//t1=Expression
		public Assignment getT1Assignment_0_1() { return cT1Assignment_0_1; }

		//Expression
		public RuleCall getT1ExpressionParserRuleCall_0_1_0() { return cT1ExpressionParserRuleCall_0_1_0; }

		//"then"
		public Keyword getThenKeyword_0_2() { return cThenKeyword_0_2; }

		//v1=TypeWithName | v2=VariableDeclarationBlock
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//v1=TypeWithName
		public Assignment getV1Assignment_1_0() { return cV1Assignment_1_0; }

		//TypeWithName
		public RuleCall getV1TypeWithNameParserRuleCall_1_0_0() { return cV1TypeWithNameParserRuleCall_1_0_0; }

		//v2=VariableDeclarationBlock
		public Assignment getV2Assignment_1_1() { return cV2Assignment_1_1; }

		//VariableDeclarationBlock
		public RuleCall getV2VariableDeclarationBlockParserRuleCall_1_1_0() { return cV2VariableDeclarationBlockParserRuleCall_1_1_0; }
	}

	public class TypeWithNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeWithName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Assignment cVarNameAssignment_0_0_0 = (Assignment)cAlternatives_0_0.eContents().get(0);
		private final RuleCall cVarNameIDTerminalRuleCall_0_0_0_0 = (RuleCall)cVarNameAssignment_0_0_0.eContents().get(0);
		private final Assignment cVarNameStAssignment_0_0_1 = (Assignment)cAlternatives_0_0.eContents().get(1);
		private final RuleCall cVarNameStSTRINGTerminalRuleCall_0_0_1_0 = (RuleCall)cVarNameStAssignment_0_0_1.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_0_1_0 = (RuleCall)cGroup_0_1.eContents().get(0);
		private final Assignment cVarName2Assignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cVarName2IDTerminalRuleCall_0_1_1_0 = (RuleCall)cVarName2Assignment_0_1_1.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Assignment cTypAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypTypeExpressionParserRuleCall_1_0 = (RuleCall)cTypAssignment_1.eContents().get(0);
		
		/// *
		// * This rule is used where a type is expected like:
		// * Float
		// * but it may also have an optional name like:
		// * x:Float
		// * / TypeWithName hidden(WS, SL_COMMENT):
		//	((varName=ID | varNameSt=STRING) (COMMA varName2=ID)? COLON)? typ=TypeExpression;
		public ParserRule getRule() { return rule; }

		//((varName=ID | varNameSt=STRING) (COMMA varName2=ID)? COLON)? typ=TypeExpression
		public Group getGroup() { return cGroup; }

		//((varName=ID | varNameSt=STRING) (COMMA varName2=ID)? COLON)?
		public Group getGroup_0() { return cGroup_0; }

		//varName=ID | varNameSt=STRING
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//varName=ID
		public Assignment getVarNameAssignment_0_0_0() { return cVarNameAssignment_0_0_0; }

		//ID
		public RuleCall getVarNameIDTerminalRuleCall_0_0_0_0() { return cVarNameIDTerminalRuleCall_0_0_0_0; }

		//varNameSt=STRING
		public Assignment getVarNameStAssignment_0_0_1() { return cVarNameStAssignment_0_0_1; }

		//STRING
		public RuleCall getVarNameStSTRINGTerminalRuleCall_0_0_1_0() { return cVarNameStSTRINGTerminalRuleCall_0_0_1_0; }

		//(COMMA varName2=ID)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_0_1_0() { return cCOMMATerminalRuleCall_0_1_0; }

		//varName2=ID
		public Assignment getVarName2Assignment_0_1_1() { return cVarName2Assignment_0_1_1; }

		//ID
		public RuleCall getVarName2IDTerminalRuleCall_0_1_1_0() { return cVarName2IDTerminalRuleCall_0_1_1_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_0_2() { return cCOLONTerminalRuleCall_0_2; }

		//typ=TypeExpression
		public Assignment getTypAssignment_1() { return cTypAssignment_1; }

		//TypeExpression
		public RuleCall getTypTypeExpressionParserRuleCall_1_0() { return cTypTypeExpressionParserRuleCall_1_0; }
	}

	public class VariableTypedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableTyped");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cVarNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cVarNameIDTerminalRuleCall_0_0_0 = (RuleCall)cVarNameAssignment_0_0.eContents().get(0);
		private final Assignment cVarNameStAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cVarNameStSTRINGTerminalRuleCall_0_1_0 = (RuleCall)cVarNameStAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cTypAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypTypeExpressionParserRuleCall_1_1_0 = (RuleCall)cTypAssignment_1_1.eContents().get(0);
		
		/// * Variable name with optional type. This is used in function signature
		// * and also by VariableDeclaration:
		// * A 'variable' can be simple like:
		// * x:Float
		// * or something more complicated like:
		// * x:Record(newPt: Pt,type:  String)
		// * or it can be a function like:
		// * x:(Float,Integer) -> Float
		// * we can define multiple variables together:
		// * i,j : Integer
		// * / VariableTyped hidden(WS, SL_COMMENT):
		//	(varName=ID | varNameSt=STRING) //    =>(COMMA t2+=ID)* // multiple declarations in same line
		//	(COLON typ=TypeExpression)?;
		public ParserRule getRule() { return rule; }

		//(varName=ID | varNameSt=STRING) //    =>(COMMA t2+=ID)* // multiple declarations in same line
		//(COLON typ=TypeExpression)?
		public Group getGroup() { return cGroup; }

		//varName=ID | varNameSt=STRING
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//varName=ID
		public Assignment getVarNameAssignment_0_0() { return cVarNameAssignment_0_0; }

		//ID
		public RuleCall getVarNameIDTerminalRuleCall_0_0_0() { return cVarNameIDTerminalRuleCall_0_0_0; }

		//varNameSt=STRING
		public Assignment getVarNameStAssignment_0_1() { return cVarNameStAssignment_0_1; }

		//STRING
		public RuleCall getVarNameStSTRINGTerminalRuleCall_0_1_0() { return cVarNameStSTRINGTerminalRuleCall_0_1_0; }

		//(COLON typ=TypeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_1_0() { return cCOLONTerminalRuleCall_1_0; }

		//typ=TypeExpression
		public Assignment getTypAssignment_1_1() { return cTypAssignment_1_1; }

		//TypeExpression
		public RuleCall getTypTypeExpressionParserRuleCall_1_1_0() { return cTypTypeExpressionParserRuleCall_1_1_0; }
	}

	public class VariableDeclarationAssignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclarationAssign");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarNameIDTerminalRuleCall_0_0 = (RuleCall)cVarNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final RuleCall cCOMMATerminalRuleCall_1_0_0 = (RuleCall)cGroup_1_0.eContents().get(0);
		private final Assignment cT12Assignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cT12IDTerminalRuleCall_1_0_1_0 = (RuleCall)cT12Assignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final RuleCall cCOLONTerminalRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cTypAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cTypTypeExpressionParserRuleCall_1_1_1_0 = (RuleCall)cTypAssignment_1_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final RuleCall cBECOMESTerminalRuleCall_1_2_0 = (RuleCall)cGroup_1_2.eContents().get(0);
		private final Assignment cT4Assignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cT4ExpressionParserRuleCall_1_2_1_0 = (RuleCall)cT4Assignment_1_2_1.eContents().get(0);
		
		/// * in add part we can declare and assign in same part
		// * such as:
		// * a := 3
		// * a:Integer := 3
		// * a := sin(x)
		// * 
		// * There are two forms of multiple assignment:
		// * a,b,c := 0@Integer
		// * or:
		// * a := b := c := 0@Integer
		// * / VariableDeclarationAssign hidden(WS):
		//	varName= // name of variable
		//	ID // if I just use name=ID then, when the ui program is running, I get:
		//	// Duplicate xxx 'coerce' in yyy
		//	((COMMA t12+=ID)* // multiple declarations in same line
		//	(COLON typ=TypeExpression)? // option to explicitly define type
		//	(BECOMES t4=Expression / * |(LBRACE NL* Expression NL* RBRACE) * /)?) // we need block since we can't always detect continuation after ':='
		//	// but this causes infinite loop
		//	// | (BECOMES t2+=ID)+ BECOMES t4=Expression
		//;
		public ParserRule getRule() { return rule; }

		//varName= // name of variable
		//ID // if I just use name=ID then, when the ui program is running, I get:
		//// Duplicate xxx 'coerce' in yyy
		//((COMMA t12+=ID)* // multiple declarations in same line
		//(COLON typ=TypeExpression)? // option to explicitly define type
		//(BECOMES t4=Expression / * |(LBRACE NL* Expression NL* RBRACE) * /)?) // we need block since we can't always detect continuation after ':='
		//// but this causes infinite loop
		//// | (BECOMES t2+=ID)+ BECOMES t4=Expression
		public Group getGroup() { return cGroup; }

		//varName= // name of variable
		//ID
		public Assignment getVarNameAssignment_0() { return cVarNameAssignment_0; }

		//// name of variable
		//ID
		public RuleCall getVarNameIDTerminalRuleCall_0_0() { return cVarNameIDTerminalRuleCall_0_0; }

		//(COMMA t12+=ID)* // multiple declarations in same line
		//(COLON typ=TypeExpression)? // option to explicitly define type
		//(BECOMES t4=Expression / * |(LBRACE NL* Expression NL* RBRACE) * /)?
		public Group getGroup_1() { return cGroup_1; }

		//(COMMA t12+=ID)*
		public Group getGroup_1_0() { return cGroup_1_0; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_0_0() { return cCOMMATerminalRuleCall_1_0_0; }

		//t12+=ID
		public Assignment getT12Assignment_1_0_1() { return cT12Assignment_1_0_1; }

		//ID
		public RuleCall getT12IDTerminalRuleCall_1_0_1_0() { return cT12IDTerminalRuleCall_1_0_1_0; }

		//(COLON typ=TypeExpression)?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_1_1_0() { return cCOLONTerminalRuleCall_1_1_0; }

		//typ=TypeExpression
		public Assignment getTypAssignment_1_1_1() { return cTypAssignment_1_1_1; }

		//TypeExpression
		public RuleCall getTypTypeExpressionParserRuleCall_1_1_1_0() { return cTypTypeExpressionParserRuleCall_1_1_1_0; }

		//(BECOMES t4=Expression / * |(LBRACE NL* Expression NL* RBRACE) * /)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//BECOMES
		public RuleCall getBECOMESTerminalRuleCall_1_2_0() { return cBECOMESTerminalRuleCall_1_2_0; }

		//t4=Expression
		public Assignment getT4Assignment_1_2_1() { return cT4Assignment_1_2_1; }

		//Expression
		public RuleCall getT4ExpressionParserRuleCall_1_2_1_0() { return cT4ExpressionParserRuleCall_1_2_1_0; }
	}

	public class FreeVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FreeVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFreeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarIDTerminalRuleCall_1_0 = (RuleCall)cVarAssignment_1.eContents().get(0);
		
		/// *
		// * free variable 	allows us to declare a variable that is global 
		// * / FreeVariable hidden(WS):
		//	"free" var=ID;
		public ParserRule getRule() { return rule; }

		//"free" var=ID
		public Group getGroup() { return cGroup; }

		//"free"
		public Keyword getFreeKeyword_0() { return cFreeKeyword_0; }

		//var=ID
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }

		//ID
		public RuleCall getVarIDTerminalRuleCall_1_0() { return cVarIDTerminalRuleCall_1_0; }
	}

	public class LocalVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLocalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarIDTerminalRuleCall_1_0 = (RuleCall)cVarAssignment_1.eContents().get(0);
		
		/// *
		// * allows us to declare a variable that is not global  
		// * / LocalVariable hidden(WS):
		//	"local" var=ID;
		public ParserRule getRule() { return rule; }

		//"local" var=ID
		public Group getGroup() { return cGroup; }

		//"local"
		public Keyword getLocalKeyword_0() { return cLocalKeyword_0; }

		//var=ID
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }

		//ID
		public RuleCall getVarIDTerminalRuleCall_1_0() { return cVarIDTerminalRuleCall_1_0; }
	}

	public class TypeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Assignment cT2Assignment_0_0_0 = (Assignment)cGroup_0_0.eContents().get(0);
		private final RuleCall cT2TypeArgumentsParserRuleCall_0_0_0_0 = (RuleCall)cT2Assignment_0_0_0.eContents().get(0);
		private final RuleCall cARROWTerminalRuleCall_0_0_1 = (RuleCall)cGroup_0_0.eContents().get(1);
		private final Assignment cT3Assignment_0_0_2 = (Assignment)cGroup_0_0.eContents().get(2);
		private final RuleCall cT3TypeResultParserRuleCall_0_0_2_0 = (RuleCall)cT3Assignment_0_0_2.eContents().get(0);
		private final RuleCall cTypePrimaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * This is similar to Expression but known to be of type.
		// * (Expression can also be of type) but if we know that
		// * this is a type we can exclude some possibilities.
		// * 
		// * A 'typeExpression' can be simple like:
		// * Float
		// * or something more complicated like:
		// * Record(newPt: Pt,type:  String)
		// * or it can be a function like:
		// * (Float,Integer) -> Float
		// * 
		// * first we check for a function like: Integer -> Integer
		// * / TypeExpression hidden(WS):
		//	=> (t2=TypeArguments ARROW t3=TypeResult) | TypePrimaryExpression;
		public ParserRule getRule() { return rule; }

		//=> (t2=TypeArguments ARROW t3=TypeResult) | TypePrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//=> (t2=TypeArguments ARROW t3=TypeResult)
		public Group getGroup_0() { return cGroup_0; }

		//t2=TypeArguments ARROW t3=TypeResult
		public Group getGroup_0_0() { return cGroup_0_0; }

		//t2=TypeArguments
		public Assignment getT2Assignment_0_0_0() { return cT2Assignment_0_0_0; }

		//TypeArguments
		public RuleCall getT2TypeArgumentsParserRuleCall_0_0_0_0() { return cT2TypeArgumentsParserRuleCall_0_0_0_0; }

		//ARROW
		public RuleCall getARROWTerminalRuleCall_0_0_1() { return cARROWTerminalRuleCall_0_0_1; }

		//t3=TypeResult
		public Assignment getT3Assignment_0_0_2() { return cT3Assignment_0_0_2; }

		//TypeResult
		public RuleCall getT3TypeResultParserRuleCall_0_0_2_0() { return cT3TypeResultParserRuleCall_0_0_2_0; }

		//TypePrimaryExpression
		public RuleCall getTypePrimaryExpressionParserRuleCall_1() { return cTypePrimaryExpressionParserRuleCall_1; }
	}

	public class TypeParameterListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeParameterList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTynameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTynameLPARENTerminalRuleCall_0_0 = (RuleCall)cTynameAssignment_0.eContents().get(0);
		private final Assignment cParAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParIDTerminalRuleCall_1_0 = (RuleCall)cParAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cPar21Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPar21TypeExpressionParserRuleCall_2_1_0 = (RuleCall)cPar21Assignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cPar2Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cPar2IDTerminalRuleCall_3_1_0 = (RuleCall)cPar2Assignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_3_2_0 = (RuleCall)cGroup_3_2.eContents().get(0);
		private final Assignment cPar22Assignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cPar22TypeExpressionParserRuleCall_3_2_1_0 = (RuleCall)cPar22Assignment_3_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		/// *
		// * we use a type parameter list for parameters of category, package or domains
		// * Parameter list may be empty '()'.
		// * in this case parameters may be just ID or they may be nameID:typeID
		// * 
		// * examples are:
		// * ()
		// * (String)
		// * (s:String)
		// * (String,Integer)
		// * (s:String,i:Integer)
		// * / TypeParameterList hidden(WS):
		//	tyname=LPAREN par=ID? (COLON par21=TypeExpression)? (COMMA par2+=ID (COLON par22+=TypeExpression)?)* RPAREN;
		public ParserRule getRule() { return rule; }

		//tyname=LPAREN par=ID? (COLON par21=TypeExpression)? (COMMA par2+=ID (COLON par22+=TypeExpression)?)* RPAREN
		public Group getGroup() { return cGroup; }

		//tyname=LPAREN
		public Assignment getTynameAssignment_0() { return cTynameAssignment_0; }

		//LPAREN
		public RuleCall getTynameLPARENTerminalRuleCall_0_0() { return cTynameLPARENTerminalRuleCall_0_0; }

		//par=ID?
		public Assignment getParAssignment_1() { return cParAssignment_1; }

		//ID
		public RuleCall getParIDTerminalRuleCall_1_0() { return cParIDTerminalRuleCall_1_0; }

		//(COLON par21=TypeExpression)?
		public Group getGroup_2() { return cGroup_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_2_0() { return cCOLONTerminalRuleCall_2_0; }

		//par21=TypeExpression
		public Assignment getPar21Assignment_2_1() { return cPar21Assignment_2_1; }

		//TypeExpression
		public RuleCall getPar21TypeExpressionParserRuleCall_2_1_0() { return cPar21TypeExpressionParserRuleCall_2_1_0; }

		//(COMMA par2+=ID (COLON par22+=TypeExpression)?)*
		public Group getGroup_3() { return cGroup_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_0() { return cCOMMATerminalRuleCall_3_0; }

		//par2+=ID
		public Assignment getPar2Assignment_3_1() { return cPar2Assignment_3_1; }

		//ID
		public RuleCall getPar2IDTerminalRuleCall_3_1_0() { return cPar2IDTerminalRuleCall_3_1_0; }

		//(COLON par22+=TypeExpression)?
		public Group getGroup_3_2() { return cGroup_3_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_3_2_0() { return cCOLONTerminalRuleCall_3_2_0; }

		//par22+=TypeExpression
		public Assignment getPar22Assignment_3_2_1() { return cPar22Assignment_3_2_1; }

		//TypeExpression
		public RuleCall getPar22TypeExpressionParserRuleCall_3_2_1_0() { return cPar22TypeExpressionParserRuleCall_3_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_4() { return cRPARENTerminalRuleCall_4; }
	}

	public class TypeArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeArguments");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTTypeLiteralParserRuleCall_0_0 = (RuleCall)cTAssignment_0.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cT2PERCENTTerminalRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Assignment cT3Assignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final Keyword cT3TypeKeyword_2_0 = (Keyword)cT3Assignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cB1Assignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cB1LPARENTerminalRuleCall_3_0_0 = (RuleCall)cB1Assignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Group cGroup_3_1_0 = (Group)cGroup_3_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_3_1_0_0 = (RuleCall)cGroup_3_1_0.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_3_1_0_1 = (RuleCall)cGroup_3_1_0.eContents().get(1);
		private final Assignment cT4Assignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cT4TypeExpressionParserRuleCall_3_1_1_0 = (RuleCall)cT4Assignment_3_1_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_3_2_0 = (RuleCall)cGroup_3_2.eContents().get(0);
		private final Group cGroup_3_2_1 = (Group)cGroup_3_2.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_3_2_1_0 = (RuleCall)cGroup_3_2_1.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_3_2_1_1 = (RuleCall)cGroup_3_2_1.eContents().get(1);
		private final Assignment cT16Assignment_3_2_2 = (Assignment)cGroup_3_2.eContents().get(2);
		private final RuleCall cT16TypeExpressionParserRuleCall_3_2_2_0 = (RuleCall)cT16Assignment_3_2_2.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3_3 = (RuleCall)cGroup_3.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Assignment cT5Assignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cT5RecordKeyword_4_0_0 = (Keyword)cT5Assignment_4_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cT6Assignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cT6TypeExpressionParserRuleCall_4_2_0 = (RuleCall)cT6Assignment_4_2.eContents().get(0);
		private final Group cGroup_4_3 = (Group)cGroup_4.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_4_3_0 = (RuleCall)cGroup_4_3.eContents().get(0);
		private final Assignment cT22Assignment_4_3_1 = (Assignment)cGroup_4_3.eContents().get(1);
		private final RuleCall cT22TypeExpressionParserRuleCall_4_3_1_0 = (RuleCall)cT22Assignment_4_3_1.eContents().get(0);
		private final Group cGroup_4_4 = (Group)cGroup_4.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_4_4_0 = (RuleCall)cGroup_4_4.eContents().get(0);
		private final Assignment cT21Assignment_4_4_1 = (Assignment)cGroup_4_4.eContents().get(1);
		private final RuleCall cT21TypeExpressionParserRuleCall_4_4_1_0 = (RuleCall)cT21Assignment_4_4_1.eContents().get(0);
		private final Group cGroup_4_4_2 = (Group)cGroup_4_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_4_4_2_0 = (RuleCall)cGroup_4_4_2.eContents().get(0);
		private final Assignment cT23Assignment_4_4_2_1 = (Assignment)cGroup_4_4_2.eContents().get(1);
		private final RuleCall cT23TypeExpressionParserRuleCall_4_4_2_1_0 = (RuleCall)cT23Assignment_4_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_4_5 = (RuleCall)cGroup_4.eContents().get(5);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Assignment cT9Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final Keyword cT9UnionKeyword_5_0_0 = (Keyword)cT9Assignment_5_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Assignment cT10Assignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cT10TypeExpressionParserRuleCall_5_2_0 = (RuleCall)cT10Assignment_5_2.eContents().get(0);
		private final Group cGroup_5_3 = (Group)cGroup_5.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_5_3_0 = (RuleCall)cGroup_5_3.eContents().get(0);
		private final Assignment cT25Assignment_5_3_1 = (Assignment)cGroup_5_3.eContents().get(1);
		private final RuleCall cT25TypeExpressionParserRuleCall_5_3_1_0 = (RuleCall)cT25Assignment_5_3_1.eContents().get(0);
		private final Group cGroup_5_4 = (Group)cGroup_5.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_5_4_0 = (RuleCall)cGroup_5_4.eContents().get(0);
		private final Assignment cT24Assignment_5_4_1 = (Assignment)cGroup_5_4.eContents().get(1);
		private final RuleCall cT24TypeExpressionParserRuleCall_5_4_1_0 = (RuleCall)cT24Assignment_5_4_1.eContents().get(0);
		private final Group cGroup_5_4_2 = (Group)cGroup_5_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_5_4_2_0 = (RuleCall)cGroup_5_4_2.eContents().get(0);
		private final Assignment cT26Assignment_5_4_2_1 = (Assignment)cGroup_5_4_2.eContents().get(1);
		private final RuleCall cT26TypeExpressionParserRuleCall_5_4_2_1_0 = (RuleCall)cT26Assignment_5_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_5_5 = (RuleCall)cGroup_5.eContents().get(5);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Assignment cT11Assignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final Keyword cT11JoinKeyword_6_0_0 = (Keyword)cT11Assignment_6_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_6_1 = (RuleCall)cGroup_6.eContents().get(1);
		private final Assignment cT12Assignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final RuleCall cT12TypeExpressionParserRuleCall_6_2_0 = (RuleCall)cT12Assignment_6_2.eContents().get(0);
		private final Group cGroup_6_3 = (Group)cGroup_6.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_6_3_0 = (RuleCall)cGroup_6_3.eContents().get(0);
		private final Assignment cT13Assignment_6_3_1 = (Assignment)cGroup_6_3.eContents().get(1);
		private final RuleCall cT13TypeExpressionParserRuleCall_6_3_1_0 = (RuleCall)cT13Assignment_6_3_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_6_4 = (RuleCall)cGroup_6.eContents().get(4);
		private final Assignment cT15Assignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cT15TypeNameOrFunctionCallParserRuleCall_7_0 = (RuleCall)cT15Assignment_7.eContents().get(0);
		
		/// *
		// * we use type arguments for first part of function type, that is
		// * x in x-> y
		// * usually this is enclosed in parenthesis
		// * (x) in (x)-> y
		// * but if x is a single argument (Including Record, Union, etc.) then it does
		// * not need to be in parenthesis.
		// * / TypeArguments hidden(WS):
		//	t=TypeLiteral | t2=PERCENT | t3="Type" | // usually, but not always type arguments are in parenthesis, and empty
		//	// parenthesis are allowed
		//	b1?=LPAREN ((ID COLON)? t4=TypeExpression)? (COMMA (ID COLON)? t16+=TypeExpression)* RPAREN | t5="Record" LPAREN
		//	t6=TypeExpression (COLON t22+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN |
		//	t9="Union" LPAREN t10=TypeExpression (COLON t25+=TypeExpression)? (COMMA t24+=TypeExpression (COLON
		//	t26+=TypeExpression)?)* RPAREN | t11="Join" LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN |
		//	t15=TypeNameOrFunctionCall;
		public ParserRule getRule() { return rule; }

		//t=TypeLiteral | t2=PERCENT | t3="Type" | // usually, but not always type arguments are in parenthesis, and empty
		//// parenthesis are allowed
		//b1?=LPAREN ((ID COLON)? t4=TypeExpression)? (COMMA (ID COLON)? t16+=TypeExpression)* RPAREN | t5="Record" LPAREN
		//t6=TypeExpression (COLON t22+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN |
		//t9="Union" LPAREN t10=TypeExpression (COLON t25+=TypeExpression)? (COMMA t24+=TypeExpression (COLON
		//t26+=TypeExpression)?)* RPAREN | t11="Join" LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN |
		//t15=TypeNameOrFunctionCall
		public Alternatives getAlternatives() { return cAlternatives; }

		//t=TypeLiteral
		public Assignment getTAssignment_0() { return cTAssignment_0; }

		//TypeLiteral
		public RuleCall getTTypeLiteralParserRuleCall_0_0() { return cTTypeLiteralParserRuleCall_0_0; }

		//t2=PERCENT
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//PERCENT
		public RuleCall getT2PERCENTTerminalRuleCall_1_0() { return cT2PERCENTTerminalRuleCall_1_0; }

		//t3="Type"
		public Assignment getT3Assignment_2() { return cT3Assignment_2; }

		//"Type"
		public Keyword getT3TypeKeyword_2_0() { return cT3TypeKeyword_2_0; }

		//// usually, but not always type arguments are in parenthesis, and empty
		//// parenthesis are allowed
		//b1?=LPAREN ((ID COLON)? t4=TypeExpression)? (COMMA (ID COLON)? t16+=TypeExpression)* RPAREN
		public Group getGroup_3() { return cGroup_3; }

		//// usually, but not always type arguments are in parenthesis, and empty
		//// parenthesis are allowed
		//b1?=LPAREN
		public Assignment getB1Assignment_3_0() { return cB1Assignment_3_0; }

		//LPAREN
		public RuleCall getB1LPARENTerminalRuleCall_3_0_0() { return cB1LPARENTerminalRuleCall_3_0_0; }

		//((ID COLON)? t4=TypeExpression)?
		public Group getGroup_3_1() { return cGroup_3_1; }

		//(ID COLON)?
		public Group getGroup_3_1_0() { return cGroup_3_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_3_1_0_0() { return cIDTerminalRuleCall_3_1_0_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_3_1_0_1() { return cCOLONTerminalRuleCall_3_1_0_1; }

		//t4=TypeExpression
		public Assignment getT4Assignment_3_1_1() { return cT4Assignment_3_1_1; }

		//TypeExpression
		public RuleCall getT4TypeExpressionParserRuleCall_3_1_1_0() { return cT4TypeExpressionParserRuleCall_3_1_1_0; }

		//(COMMA (ID COLON)? t16+=TypeExpression)*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_2_0() { return cCOMMATerminalRuleCall_3_2_0; }

		//(ID COLON)?
		public Group getGroup_3_2_1() { return cGroup_3_2_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_3_2_1_0() { return cIDTerminalRuleCall_3_2_1_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_3_2_1_1() { return cCOLONTerminalRuleCall_3_2_1_1; }

		//t16+=TypeExpression
		public Assignment getT16Assignment_3_2_2() { return cT16Assignment_3_2_2; }

		//TypeExpression
		public RuleCall getT16TypeExpressionParserRuleCall_3_2_2_0() { return cT16TypeExpressionParserRuleCall_3_2_2_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3_3() { return cRPARENTerminalRuleCall_3_3; }

		//t5="Record" LPAREN t6=TypeExpression (COLON t22+=TypeExpression)? (COMMA t21+=TypeExpression (COLON
		//t23+=TypeExpression)?)* RPAREN
		public Group getGroup_4() { return cGroup_4; }

		//t5="Record"
		public Assignment getT5Assignment_4_0() { return cT5Assignment_4_0; }

		//"Record"
		public Keyword getT5RecordKeyword_4_0_0() { return cT5RecordKeyword_4_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_4_1() { return cLPARENTerminalRuleCall_4_1; }

		//t6=TypeExpression
		public Assignment getT6Assignment_4_2() { return cT6Assignment_4_2; }

		//TypeExpression
		public RuleCall getT6TypeExpressionParserRuleCall_4_2_0() { return cT6TypeExpressionParserRuleCall_4_2_0; }

		//(COLON t22+=TypeExpression)?
		public Group getGroup_4_3() { return cGroup_4_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_4_3_0() { return cCOLONTerminalRuleCall_4_3_0; }

		//t22+=TypeExpression
		public Assignment getT22Assignment_4_3_1() { return cT22Assignment_4_3_1; }

		//TypeExpression
		public RuleCall getT22TypeExpressionParserRuleCall_4_3_1_0() { return cT22TypeExpressionParserRuleCall_4_3_1_0; }

		//(COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)*
		public Group getGroup_4_4() { return cGroup_4_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_4_4_0() { return cCOMMATerminalRuleCall_4_4_0; }

		//t21+=TypeExpression
		public Assignment getT21Assignment_4_4_1() { return cT21Assignment_4_4_1; }

		//TypeExpression
		public RuleCall getT21TypeExpressionParserRuleCall_4_4_1_0() { return cT21TypeExpressionParserRuleCall_4_4_1_0; }

		//(COLON t23+=TypeExpression)?
		public Group getGroup_4_4_2() { return cGroup_4_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_4_4_2_0() { return cCOLONTerminalRuleCall_4_4_2_0; }

		//t23+=TypeExpression
		public Assignment getT23Assignment_4_4_2_1() { return cT23Assignment_4_4_2_1; }

		//TypeExpression
		public RuleCall getT23TypeExpressionParserRuleCall_4_4_2_1_0() { return cT23TypeExpressionParserRuleCall_4_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_4_5() { return cRPARENTerminalRuleCall_4_5; }

		//t9="Union" LPAREN t10=TypeExpression (COLON t25+=TypeExpression)? (COMMA t24+=TypeExpression (COLON
		//t26+=TypeExpression)?)* RPAREN
		public Group getGroup_5() { return cGroup_5; }

		//t9="Union"
		public Assignment getT9Assignment_5_0() { return cT9Assignment_5_0; }

		//"Union"
		public Keyword getT9UnionKeyword_5_0_0() { return cT9UnionKeyword_5_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_5_1() { return cLPARENTerminalRuleCall_5_1; }

		//t10=TypeExpression
		public Assignment getT10Assignment_5_2() { return cT10Assignment_5_2; }

		//TypeExpression
		public RuleCall getT10TypeExpressionParserRuleCall_5_2_0() { return cT10TypeExpressionParserRuleCall_5_2_0; }

		//(COLON t25+=TypeExpression)?
		public Group getGroup_5_3() { return cGroup_5_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5_3_0() { return cCOLONTerminalRuleCall_5_3_0; }

		//t25+=TypeExpression
		public Assignment getT25Assignment_5_3_1() { return cT25Assignment_5_3_1; }

		//TypeExpression
		public RuleCall getT25TypeExpressionParserRuleCall_5_3_1_0() { return cT25TypeExpressionParserRuleCall_5_3_1_0; }

		//(COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)*
		public Group getGroup_5_4() { return cGroup_5_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_5_4_0() { return cCOMMATerminalRuleCall_5_4_0; }

		//t24+=TypeExpression
		public Assignment getT24Assignment_5_4_1() { return cT24Assignment_5_4_1; }

		//TypeExpression
		public RuleCall getT24TypeExpressionParserRuleCall_5_4_1_0() { return cT24TypeExpressionParserRuleCall_5_4_1_0; }

		//(COLON t26+=TypeExpression)?
		public Group getGroup_5_4_2() { return cGroup_5_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5_4_2_0() { return cCOLONTerminalRuleCall_5_4_2_0; }

		//t26+=TypeExpression
		public Assignment getT26Assignment_5_4_2_1() { return cT26Assignment_5_4_2_1; }

		//TypeExpression
		public RuleCall getT26TypeExpressionParserRuleCall_5_4_2_1_0() { return cT26TypeExpressionParserRuleCall_5_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_5_5() { return cRPARENTerminalRuleCall_5_5; }

		//t11="Join" LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN
		public Group getGroup_6() { return cGroup_6; }

		//t11="Join"
		public Assignment getT11Assignment_6_0() { return cT11Assignment_6_0; }

		//"Join"
		public Keyword getT11JoinKeyword_6_0_0() { return cT11JoinKeyword_6_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_6_1() { return cLPARENTerminalRuleCall_6_1; }

		//t12=TypeExpression
		public Assignment getT12Assignment_6_2() { return cT12Assignment_6_2; }

		//TypeExpression
		public RuleCall getT12TypeExpressionParserRuleCall_6_2_0() { return cT12TypeExpressionParserRuleCall_6_2_0; }

		//(COMMA t13+=TypeExpression)*
		public Group getGroup_6_3() { return cGroup_6_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_6_3_0() { return cCOMMATerminalRuleCall_6_3_0; }

		//t13+=TypeExpression
		public Assignment getT13Assignment_6_3_1() { return cT13Assignment_6_3_1; }

		//TypeExpression
		public RuleCall getT13TypeExpressionParserRuleCall_6_3_1_0() { return cT13TypeExpressionParserRuleCall_6_3_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_6_4() { return cRPARENTerminalRuleCall_6_4; }

		//t15=TypeNameOrFunctionCall
		public Assignment getT15Assignment_7() { return cT15Assignment_7; }

		//TypeNameOrFunctionCall
		public RuleCall getT15TypeNameOrFunctionCallParserRuleCall_7_0() { return cT15TypeNameOrFunctionCallParserRuleCall_7_0; }
	}

	public class TypeResultElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeResult");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTTypeLiteralParserRuleCall_0_0 = (RuleCall)cTAssignment_0.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cT2PERCENTTerminalRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Assignment cTynameAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final Keyword cTynameTypeKeyword_2_0 = (Keyword)cTynameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cTynameAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Keyword cTynameRecordKeyword_3_0_0 = (Keyword)cTynameAssignment_3_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Assignment cT7Assignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cT7TypeExpressionParserRuleCall_3_2_0 = (RuleCall)cT7Assignment_3_2.eContents().get(0);
		private final Group cGroup_3_3 = (Group)cGroup_3.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_3_3_0 = (RuleCall)cGroup_3_3.eContents().get(0);
		private final Assignment cT8Assignment_3_3_1 = (Assignment)cGroup_3_3.eContents().get(1);
		private final RuleCall cT8TypeExpressionParserRuleCall_3_3_1_0 = (RuleCall)cT8Assignment_3_3_1.eContents().get(0);
		private final Group cGroup_3_4 = (Group)cGroup_3.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_3_4_0 = (RuleCall)cGroup_3_4.eContents().get(0);
		private final Assignment cT21Assignment_3_4_1 = (Assignment)cGroup_3_4.eContents().get(1);
		private final RuleCall cT21TypeExpressionParserRuleCall_3_4_1_0 = (RuleCall)cT21Assignment_3_4_1.eContents().get(0);
		private final Group cGroup_3_4_2 = (Group)cGroup_3_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_3_4_2_0 = (RuleCall)cGroup_3_4_2.eContents().get(0);
		private final Assignment cT23Assignment_3_4_2_1 = (Assignment)cGroup_3_4_2.eContents().get(1);
		private final RuleCall cT23TypeExpressionParserRuleCall_3_4_2_1_0 = (RuleCall)cT23Assignment_3_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3_5 = (RuleCall)cGroup_3.eContents().get(5);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Assignment cTynameAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cTynameUnionKeyword_4_0_0 = (Keyword)cTynameAssignment_4_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cT10Assignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cT10TypeExpressionParserRuleCall_4_2_0 = (RuleCall)cT10Assignment_4_2.eContents().get(0);
		private final Group cGroup_4_3 = (Group)cGroup_4.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_4_3_0 = (RuleCall)cGroup_4_3.eContents().get(0);
		private final Assignment cT11Assignment_4_3_1 = (Assignment)cGroup_4_3.eContents().get(1);
		private final RuleCall cT11TypeExpressionParserRuleCall_4_3_1_0 = (RuleCall)cT11Assignment_4_3_1.eContents().get(0);
		private final Group cGroup_4_4 = (Group)cGroup_4.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_4_4_0 = (RuleCall)cGroup_4_4.eContents().get(0);
		private final Assignment cT24Assignment_4_4_1 = (Assignment)cGroup_4_4.eContents().get(1);
		private final RuleCall cT24TypeExpressionParserRuleCall_4_4_1_0 = (RuleCall)cT24Assignment_4_4_1.eContents().get(0);
		private final Group cGroup_4_4_2 = (Group)cGroup_4_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_4_4_2_0 = (RuleCall)cGroup_4_4_2.eContents().get(0);
		private final Assignment cT26Assignment_4_4_2_1 = (Assignment)cGroup_4_4_2.eContents().get(1);
		private final RuleCall cT26TypeExpressionParserRuleCall_4_4_2_1_0 = (RuleCall)cT26Assignment_4_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_4_5 = (RuleCall)cGroup_4.eContents().get(5);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Assignment cTynameAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final Keyword cTynameJoinKeyword_5_0_0 = (Keyword)cTynameAssignment_5_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Assignment cT12Assignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cT12TypeExpressionParserRuleCall_5_2_0 = (RuleCall)cT12Assignment_5_2.eContents().get(0);
		private final Group cGroup_5_3 = (Group)cGroup_5.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_5_3_0 = (RuleCall)cGroup_5_3.eContents().get(0);
		private final Assignment cT13Assignment_5_3_1 = (Assignment)cGroup_5_3.eContents().get(1);
		private final RuleCall cT13TypeExpressionParserRuleCall_5_3_1_0 = (RuleCall)cT13Assignment_5_3_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_5_4 = (RuleCall)cGroup_5.eContents().get(4);
		private final Assignment cT15Assignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cT15TypeNameOrFunctionCallParserRuleCall_6_0 = (RuleCall)cT15Assignment_6.eContents().get(0);
		
		/// *
		// * we use type arguments for final part of function type, that is
		// * y in x-> y
		// * / TypeResult hidden(WS):
		//	t=TypeLiteral | t2=PERCENT | tyname="Type" | // | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
		//	tyname="Record" LPAREN t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON
		//	t23+=TypeExpression)?)* RPAREN | tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
		//	t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | tyname="Join" LPAREN t12=TypeExpression (COMMA
		//	t13+=TypeExpression)* RPAREN | t15=TypeNameOrFunctionCall;
		public ParserRule getRule() { return rule; }

		//t=TypeLiteral | t2=PERCENT | tyname="Type" | // | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
		//tyname="Record" LPAREN t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON
		//t23+=TypeExpression)?)* RPAREN | tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
		//t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | tyname="Join" LPAREN t12=TypeExpression (COMMA
		//t13+=TypeExpression)* RPAREN | t15=TypeNameOrFunctionCall
		public Alternatives getAlternatives() { return cAlternatives; }

		//t=TypeLiteral
		public Assignment getTAssignment_0() { return cTAssignment_0; }

		//TypeLiteral
		public RuleCall getTTypeLiteralParserRuleCall_0_0() { return cTTypeLiteralParserRuleCall_0_0; }

		//t2=PERCENT
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//PERCENT
		public RuleCall getT2PERCENTTerminalRuleCall_1_0() { return cT2PERCENTTerminalRuleCall_1_0; }

		//tyname="Type"
		public Assignment getTynameAssignment_2() { return cTynameAssignment_2; }

		//"Type"
		public Keyword getTynameTypeKeyword_2_0() { return cTynameTypeKeyword_2_0; }

		//// | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
		//tyname="Record" LPAREN t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON
		//t23+=TypeExpression)?)* RPAREN
		public Group getGroup_3() { return cGroup_3; }

		//// | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
		//tyname="Record"
		public Assignment getTynameAssignment_3_0() { return cTynameAssignment_3_0; }

		//"Record"
		public Keyword getTynameRecordKeyword_3_0_0() { return cTynameRecordKeyword_3_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_3_1() { return cLPARENTerminalRuleCall_3_1; }

		//t7=TypeExpression
		public Assignment getT7Assignment_3_2() { return cT7Assignment_3_2; }

		//TypeExpression
		public RuleCall getT7TypeExpressionParserRuleCall_3_2_0() { return cT7TypeExpressionParserRuleCall_3_2_0; }

		//(COLON t8+=TypeExpression)?
		public Group getGroup_3_3() { return cGroup_3_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_3_3_0() { return cCOLONTerminalRuleCall_3_3_0; }

		//t8+=TypeExpression
		public Assignment getT8Assignment_3_3_1() { return cT8Assignment_3_3_1; }

		//TypeExpression
		public RuleCall getT8TypeExpressionParserRuleCall_3_3_1_0() { return cT8TypeExpressionParserRuleCall_3_3_1_0; }

		//(COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)*
		public Group getGroup_3_4() { return cGroup_3_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_4_0() { return cCOMMATerminalRuleCall_3_4_0; }

		//t21+=TypeExpression
		public Assignment getT21Assignment_3_4_1() { return cT21Assignment_3_4_1; }

		//TypeExpression
		public RuleCall getT21TypeExpressionParserRuleCall_3_4_1_0() { return cT21TypeExpressionParserRuleCall_3_4_1_0; }

		//(COLON t23+=TypeExpression)?
		public Group getGroup_3_4_2() { return cGroup_3_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_3_4_2_0() { return cCOLONTerminalRuleCall_3_4_2_0; }

		//t23+=TypeExpression
		public Assignment getT23Assignment_3_4_2_1() { return cT23Assignment_3_4_2_1; }

		//TypeExpression
		public RuleCall getT23TypeExpressionParserRuleCall_3_4_2_1_0() { return cT23TypeExpressionParserRuleCall_3_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3_5() { return cRPARENTerminalRuleCall_3_5; }

		//tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA t24+=TypeExpression (COLON
		//t26+=TypeExpression)?)* RPAREN
		public Group getGroup_4() { return cGroup_4; }

		//tyname="Union"
		public Assignment getTynameAssignment_4_0() { return cTynameAssignment_4_0; }

		//"Union"
		public Keyword getTynameUnionKeyword_4_0_0() { return cTynameUnionKeyword_4_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_4_1() { return cLPARENTerminalRuleCall_4_1; }

		//t10=TypeExpression
		public Assignment getT10Assignment_4_2() { return cT10Assignment_4_2; }

		//TypeExpression
		public RuleCall getT10TypeExpressionParserRuleCall_4_2_0() { return cT10TypeExpressionParserRuleCall_4_2_0; }

		//(COLON t11+=TypeExpression)?
		public Group getGroup_4_3() { return cGroup_4_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_4_3_0() { return cCOLONTerminalRuleCall_4_3_0; }

		//t11+=TypeExpression
		public Assignment getT11Assignment_4_3_1() { return cT11Assignment_4_3_1; }

		//TypeExpression
		public RuleCall getT11TypeExpressionParserRuleCall_4_3_1_0() { return cT11TypeExpressionParserRuleCall_4_3_1_0; }

		//(COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)*
		public Group getGroup_4_4() { return cGroup_4_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_4_4_0() { return cCOMMATerminalRuleCall_4_4_0; }

		//t24+=TypeExpression
		public Assignment getT24Assignment_4_4_1() { return cT24Assignment_4_4_1; }

		//TypeExpression
		public RuleCall getT24TypeExpressionParserRuleCall_4_4_1_0() { return cT24TypeExpressionParserRuleCall_4_4_1_0; }

		//(COLON t26+=TypeExpression)?
		public Group getGroup_4_4_2() { return cGroup_4_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_4_4_2_0() { return cCOLONTerminalRuleCall_4_4_2_0; }

		//t26+=TypeExpression
		public Assignment getT26Assignment_4_4_2_1() { return cT26Assignment_4_4_2_1; }

		//TypeExpression
		public RuleCall getT26TypeExpressionParserRuleCall_4_4_2_1_0() { return cT26TypeExpressionParserRuleCall_4_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_4_5() { return cRPARENTerminalRuleCall_4_5; }

		//tyname="Join" LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN
		public Group getGroup_5() { return cGroup_5; }

		//tyname="Join"
		public Assignment getTynameAssignment_5_0() { return cTynameAssignment_5_0; }

		//"Join"
		public Keyword getTynameJoinKeyword_5_0_0() { return cTynameJoinKeyword_5_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_5_1() { return cLPARENTerminalRuleCall_5_1; }

		//t12=TypeExpression
		public Assignment getT12Assignment_5_2() { return cT12Assignment_5_2; }

		//TypeExpression
		public RuleCall getT12TypeExpressionParserRuleCall_5_2_0() { return cT12TypeExpressionParserRuleCall_5_2_0; }

		//(COMMA t13+=TypeExpression)*
		public Group getGroup_5_3() { return cGroup_5_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_5_3_0() { return cCOMMATerminalRuleCall_5_3_0; }

		//t13+=TypeExpression
		public Assignment getT13Assignment_5_3_1() { return cT13Assignment_5_3_1; }

		//TypeExpression
		public RuleCall getT13TypeExpressionParserRuleCall_5_3_1_0() { return cT13TypeExpressionParserRuleCall_5_3_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_5_4() { return cRPARENTerminalRuleCall_5_4; }

		//t15=TypeNameOrFunctionCall
		public Assignment getT15Assignment_6() { return cT15Assignment_6; }

		//TypeNameOrFunctionCall
		public RuleCall getT15TypeNameOrFunctionCallParserRuleCall_6_0() { return cT15TypeNameOrFunctionCallParserRuleCall_6_0; }
	}

	public class TypePrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypePrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cTypePrimaryExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cT32Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cT32PERCENTTerminalRuleCall_1_1_0 = (RuleCall)cT32Assignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cTypePrimaryExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cTynameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final Keyword cTynameTypeKeyword_2_1_0 = (Keyword)cTynameAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cTypePrimaryExpressionAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cTynameAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final Keyword cTynameLispKeyword_3_1_0 = (Keyword)cTynameAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cTypePrimaryExpressionAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cT5Assignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cT5TypeExpressionParserRuleCall_4_2_0 = (RuleCall)cT5Assignment_4_2.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_4_3 = (RuleCall)cGroup_4.eContents().get(3);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cTypePrimaryExpressionAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Assignment cTynameAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final Keyword cTynameRecordKeyword_5_1_0 = (Keyword)cTynameAssignment_5_1.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_5_2 = (RuleCall)cGroup_5.eContents().get(2);
		private final Assignment cT7Assignment_5_3 = (Assignment)cGroup_5.eContents().get(3);
		private final RuleCall cT7TypeExpressionParserRuleCall_5_3_0 = (RuleCall)cT7Assignment_5_3.eContents().get(0);
		private final Group cGroup_5_4 = (Group)cGroup_5.eContents().get(4);
		private final RuleCall cCOLONTerminalRuleCall_5_4_0 = (RuleCall)cGroup_5_4.eContents().get(0);
		private final Assignment cT8Assignment_5_4_1 = (Assignment)cGroup_5_4.eContents().get(1);
		private final RuleCall cT8TypeExpressionParserRuleCall_5_4_1_0 = (RuleCall)cT8Assignment_5_4_1.eContents().get(0);
		private final Group cGroup_5_5 = (Group)cGroup_5.eContents().get(5);
		private final RuleCall cCOMMATerminalRuleCall_5_5_0 = (RuleCall)cGroup_5_5.eContents().get(0);
		private final Assignment cT21Assignment_5_5_1 = (Assignment)cGroup_5_5.eContents().get(1);
		private final RuleCall cT21TypeExpressionParserRuleCall_5_5_1_0 = (RuleCall)cT21Assignment_5_5_1.eContents().get(0);
		private final Group cGroup_5_5_2 = (Group)cGroup_5_5.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_5_5_2_0 = (RuleCall)cGroup_5_5_2.eContents().get(0);
		private final Assignment cT23Assignment_5_5_2_1 = (Assignment)cGroup_5_5_2.eContents().get(1);
		private final RuleCall cT23TypeExpressionParserRuleCall_5_5_2_1_0 = (RuleCall)cT23Assignment_5_5_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_5_6 = (RuleCall)cGroup_5.eContents().get(6);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Action cTypePrimaryExpressionAction_6_0 = (Action)cGroup_6.eContents().get(0);
		private final Assignment cTynameAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final Keyword cTynameUnionKeyword_6_1_0 = (Keyword)cTynameAssignment_6_1.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_6_2 = (RuleCall)cGroup_6.eContents().get(2);
		private final Assignment cT10Assignment_6_3 = (Assignment)cGroup_6.eContents().get(3);
		private final RuleCall cT10TypeExpressionParserRuleCall_6_3_0 = (RuleCall)cT10Assignment_6_3.eContents().get(0);
		private final Group cGroup_6_4 = (Group)cGroup_6.eContents().get(4);
		private final RuleCall cCOLONTerminalRuleCall_6_4_0 = (RuleCall)cGroup_6_4.eContents().get(0);
		private final Assignment cT11Assignment_6_4_1 = (Assignment)cGroup_6_4.eContents().get(1);
		private final RuleCall cT11TypeExpressionParserRuleCall_6_4_1_0 = (RuleCall)cT11Assignment_6_4_1.eContents().get(0);
		private final Group cGroup_6_5 = (Group)cGroup_6.eContents().get(5);
		private final RuleCall cCOMMATerminalRuleCall_6_5_0 = (RuleCall)cGroup_6_5.eContents().get(0);
		private final Assignment cT24Assignment_6_5_1 = (Assignment)cGroup_6_5.eContents().get(1);
		private final RuleCall cT24TypeExpressionParserRuleCall_6_5_1_0 = (RuleCall)cT24Assignment_6_5_1.eContents().get(0);
		private final Group cGroup_6_5_2 = (Group)cGroup_6_5.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_6_5_2_0 = (RuleCall)cGroup_6_5_2.eContents().get(0);
		private final Assignment cT26Assignment_6_5_2_1 = (Assignment)cGroup_6_5_2.eContents().get(1);
		private final RuleCall cT26TypeExpressionParserRuleCall_6_5_2_1_0 = (RuleCall)cT26Assignment_6_5_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_6_6 = (RuleCall)cGroup_6.eContents().get(6);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Action cTypePrimaryExpressionAction_7_0 = (Action)cGroup_7.eContents().get(0);
		private final Assignment cTynameAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final Keyword cTynameJoinKeyword_7_1_0 = (Keyword)cTynameAssignment_7_1.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_7_2 = (RuleCall)cGroup_7.eContents().get(2);
		private final Assignment cT13Assignment_7_3 = (Assignment)cGroup_7.eContents().get(3);
		private final RuleCall cT13TypeExpressionParserRuleCall_7_3_0 = (RuleCall)cT13Assignment_7_3.eContents().get(0);
		private final Group cGroup_7_4 = (Group)cGroup_7.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_7_4_0 = (RuleCall)cGroup_7_4.eContents().get(0);
		private final Assignment cT14Assignment_7_4_1 = (Assignment)cGroup_7_4.eContents().get(1);
		private final RuleCall cT14TypeExpressionParserRuleCall_7_4_1_0 = (RuleCall)cT14Assignment_7_4_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_7_5 = (RuleCall)cGroup_7.eContents().get(5);
		private final RuleCall cTypeNameOrFunctionCallParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cTupleDefinitionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//TypePrimaryExpression hidden(WS):
		//	TypeLiteral // 'Type' is top of the category hierarchy
		//	// 'Lisp' is used for native lisp function calls such as Say$Lisp
		//	| {TypePrimaryExpression} t32=PERCENT | {TypePrimaryExpression} tyname="Type" | {TypePrimaryExpression} tyname="Lisp" |
		//	{TypePrimaryExpression} LPAREN t5=TypeExpression RPAREN | {TypePrimaryExpression} tyname="Record" LPAREN
		//	t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN |
		//	{TypePrimaryExpression} tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
		//	t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | {TypePrimaryExpression} tyname="Join" LPAREN
		//	t13=TypeExpression (COMMA t14+=TypeExpression)* RPAREN | TypeNameOrFunctionCall | => TupleDefinition;
		public ParserRule getRule() { return rule; }

		//TypeLiteral // 'Type' is top of the category hierarchy
		//// 'Lisp' is used for native lisp function calls such as Say$Lisp
		//| {TypePrimaryExpression} t32=PERCENT | {TypePrimaryExpression} tyname="Type" | {TypePrimaryExpression} tyname="Lisp" |
		//{TypePrimaryExpression} LPAREN t5=TypeExpression RPAREN | {TypePrimaryExpression} tyname="Record" LPAREN
		//t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN |
		//{TypePrimaryExpression} tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
		//t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | {TypePrimaryExpression} tyname="Join" LPAREN
		//t13=TypeExpression (COMMA t14+=TypeExpression)* RPAREN | TypeNameOrFunctionCall | => TupleDefinition
		public Alternatives getAlternatives() { return cAlternatives; }

		//TypeLiteral
		public RuleCall getTypeLiteralParserRuleCall_0() { return cTypeLiteralParserRuleCall_0; }

		//{TypePrimaryExpression} t32=PERCENT
		public Group getGroup_1() { return cGroup_1; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_1_0() { return cTypePrimaryExpressionAction_1_0; }

		//t32=PERCENT
		public Assignment getT32Assignment_1_1() { return cT32Assignment_1_1; }

		//PERCENT
		public RuleCall getT32PERCENTTerminalRuleCall_1_1_0() { return cT32PERCENTTerminalRuleCall_1_1_0; }

		//{TypePrimaryExpression} tyname="Type"
		public Group getGroup_2() { return cGroup_2; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_2_0() { return cTypePrimaryExpressionAction_2_0; }

		//tyname="Type"
		public Assignment getTynameAssignment_2_1() { return cTynameAssignment_2_1; }

		//"Type"
		public Keyword getTynameTypeKeyword_2_1_0() { return cTynameTypeKeyword_2_1_0; }

		//{TypePrimaryExpression} tyname="Lisp"
		public Group getGroup_3() { return cGroup_3; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_3_0() { return cTypePrimaryExpressionAction_3_0; }

		//tyname="Lisp"
		public Assignment getTynameAssignment_3_1() { return cTynameAssignment_3_1; }

		//"Lisp"
		public Keyword getTynameLispKeyword_3_1_0() { return cTynameLispKeyword_3_1_0; }

		//{TypePrimaryExpression} LPAREN t5=TypeExpression RPAREN
		public Group getGroup_4() { return cGroup_4; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_4_0() { return cTypePrimaryExpressionAction_4_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_4_1() { return cLPARENTerminalRuleCall_4_1; }

		//t5=TypeExpression
		public Assignment getT5Assignment_4_2() { return cT5Assignment_4_2; }

		//TypeExpression
		public RuleCall getT5TypeExpressionParserRuleCall_4_2_0() { return cT5TypeExpressionParserRuleCall_4_2_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_4_3() { return cRPARENTerminalRuleCall_4_3; }

		//{TypePrimaryExpression} tyname="Record" LPAREN t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression
		//(COLON t23+=TypeExpression)?)* RPAREN
		public Group getGroup_5() { return cGroup_5; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_5_0() { return cTypePrimaryExpressionAction_5_0; }

		//tyname="Record"
		public Assignment getTynameAssignment_5_1() { return cTynameAssignment_5_1; }

		//"Record"
		public Keyword getTynameRecordKeyword_5_1_0() { return cTynameRecordKeyword_5_1_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_5_2() { return cLPARENTerminalRuleCall_5_2; }

		//t7=TypeExpression
		public Assignment getT7Assignment_5_3() { return cT7Assignment_5_3; }

		//TypeExpression
		public RuleCall getT7TypeExpressionParserRuleCall_5_3_0() { return cT7TypeExpressionParserRuleCall_5_3_0; }

		//(COLON t8+=TypeExpression)?
		public Group getGroup_5_4() { return cGroup_5_4; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5_4_0() { return cCOLONTerminalRuleCall_5_4_0; }

		//t8+=TypeExpression
		public Assignment getT8Assignment_5_4_1() { return cT8Assignment_5_4_1; }

		//TypeExpression
		public RuleCall getT8TypeExpressionParserRuleCall_5_4_1_0() { return cT8TypeExpressionParserRuleCall_5_4_1_0; }

		//(COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)*
		public Group getGroup_5_5() { return cGroup_5_5; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_5_5_0() { return cCOMMATerminalRuleCall_5_5_0; }

		//t21+=TypeExpression
		public Assignment getT21Assignment_5_5_1() { return cT21Assignment_5_5_1; }

		//TypeExpression
		public RuleCall getT21TypeExpressionParserRuleCall_5_5_1_0() { return cT21TypeExpressionParserRuleCall_5_5_1_0; }

		//(COLON t23+=TypeExpression)?
		public Group getGroup_5_5_2() { return cGroup_5_5_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_5_5_2_0() { return cCOLONTerminalRuleCall_5_5_2_0; }

		//t23+=TypeExpression
		public Assignment getT23Assignment_5_5_2_1() { return cT23Assignment_5_5_2_1; }

		//TypeExpression
		public RuleCall getT23TypeExpressionParserRuleCall_5_5_2_1_0() { return cT23TypeExpressionParserRuleCall_5_5_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_5_6() { return cRPARENTerminalRuleCall_5_6; }

		//{TypePrimaryExpression} tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA t24+=TypeExpression
		//(COLON t26+=TypeExpression)?)* RPAREN
		public Group getGroup_6() { return cGroup_6; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_6_0() { return cTypePrimaryExpressionAction_6_0; }

		//tyname="Union"
		public Assignment getTynameAssignment_6_1() { return cTynameAssignment_6_1; }

		//"Union"
		public Keyword getTynameUnionKeyword_6_1_0() { return cTynameUnionKeyword_6_1_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_6_2() { return cLPARENTerminalRuleCall_6_2; }

		//t10=TypeExpression
		public Assignment getT10Assignment_6_3() { return cT10Assignment_6_3; }

		//TypeExpression
		public RuleCall getT10TypeExpressionParserRuleCall_6_3_0() { return cT10TypeExpressionParserRuleCall_6_3_0; }

		//(COLON t11+=TypeExpression)?
		public Group getGroup_6_4() { return cGroup_6_4; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_6_4_0() { return cCOLONTerminalRuleCall_6_4_0; }

		//t11+=TypeExpression
		public Assignment getT11Assignment_6_4_1() { return cT11Assignment_6_4_1; }

		//TypeExpression
		public RuleCall getT11TypeExpressionParserRuleCall_6_4_1_0() { return cT11TypeExpressionParserRuleCall_6_4_1_0; }

		//(COMMA t24+=TypeExpression (COLON t26+=TypeExpression)?)*
		public Group getGroup_6_5() { return cGroup_6_5; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_6_5_0() { return cCOMMATerminalRuleCall_6_5_0; }

		//t24+=TypeExpression
		public Assignment getT24Assignment_6_5_1() { return cT24Assignment_6_5_1; }

		//TypeExpression
		public RuleCall getT24TypeExpressionParserRuleCall_6_5_1_0() { return cT24TypeExpressionParserRuleCall_6_5_1_0; }

		//(COLON t26+=TypeExpression)?
		public Group getGroup_6_5_2() { return cGroup_6_5_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_6_5_2_0() { return cCOLONTerminalRuleCall_6_5_2_0; }

		//t26+=TypeExpression
		public Assignment getT26Assignment_6_5_2_1() { return cT26Assignment_6_5_2_1; }

		//TypeExpression
		public RuleCall getT26TypeExpressionParserRuleCall_6_5_2_1_0() { return cT26TypeExpressionParserRuleCall_6_5_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_6_6() { return cRPARENTerminalRuleCall_6_6; }

		//{TypePrimaryExpression} tyname="Join" LPAREN t13=TypeExpression (COMMA t14+=TypeExpression)* RPAREN
		public Group getGroup_7() { return cGroup_7; }

		//{TypePrimaryExpression}
		public Action getTypePrimaryExpressionAction_7_0() { return cTypePrimaryExpressionAction_7_0; }

		//tyname="Join"
		public Assignment getTynameAssignment_7_1() { return cTynameAssignment_7_1; }

		//"Join"
		public Keyword getTynameJoinKeyword_7_1_0() { return cTynameJoinKeyword_7_1_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_7_2() { return cLPARENTerminalRuleCall_7_2; }

		//t13=TypeExpression
		public Assignment getT13Assignment_7_3() { return cT13Assignment_7_3; }

		//TypeExpression
		public RuleCall getT13TypeExpressionParserRuleCall_7_3_0() { return cT13TypeExpressionParserRuleCall_7_3_0; }

		//(COMMA t14+=TypeExpression)*
		public Group getGroup_7_4() { return cGroup_7_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_7_4_0() { return cCOMMATerminalRuleCall_7_4_0; }

		//t14+=TypeExpression
		public Assignment getT14Assignment_7_4_1() { return cT14Assignment_7_4_1; }

		//TypeExpression
		public RuleCall getT14TypeExpressionParserRuleCall_7_4_1_0() { return cT14TypeExpressionParserRuleCall_7_4_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_7_5() { return cRPARENTerminalRuleCall_7_5; }

		//TypeNameOrFunctionCall
		public RuleCall getTypeNameOrFunctionCallParserRuleCall_8() { return cTypeNameOrFunctionCallParserRuleCall_8; }

		//=> TupleDefinition
		public RuleCall getTupleDefinitionParserRuleCall_9() { return cTupleDefinitionParserRuleCall_9; }
	}

	public class TypeNameOrFunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeNameOrFunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTfnnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTfnnameIDTerminalRuleCall_0_0 = (RuleCall)cTfnnameAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_1_0_0_0 = (RuleCall)cGroup_1_0_0.eContents().get(0);
		private final Group cGroup_1_0_0_1 = (Group)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_0_0_1_0 = (RuleCall)cGroup_1_0_0_1.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_1_0_0_1_1 = (RuleCall)cGroup_1_0_0_1.eContents().get(1);
		private final Assignment cT4Assignment_1_0_0_2 = (Assignment)cGroup_1_0_0.eContents().get(2);
		private final RuleCall cT4TypeExpressionParserRuleCall_1_0_0_2_0 = (RuleCall)cT4Assignment_1_0_0_2.eContents().get(0);
		private final Group cGroup_1_0_0_3 = (Group)cGroup_1_0_0.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_1_0_0_3_0 = (RuleCall)cGroup_1_0_0_3.eContents().get(0);
		private final Group cGroup_1_0_0_3_1 = (Group)cGroup_1_0_0_3.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_0_0_3_1_0 = (RuleCall)cGroup_1_0_0_3_1.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_1_0_0_3_1_1 = (RuleCall)cGroup_1_0_0_3_1.eContents().get(1);
		private final Assignment cT25Assignment_1_0_0_3_2 = (Assignment)cGroup_1_0_0_3.eContents().get(2);
		private final RuleCall cT25TypeExpressionParserRuleCall_1_0_0_3_2_0 = (RuleCall)cT25Assignment_1_0_0_3_2.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_1_0_0_4 = (RuleCall)cGroup_1_0_0.eContents().get(4);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final RuleCall cLPARENTerminalRuleCall_1_0_1_0 = (RuleCall)cGroup_1_0_1.eContents().get(0);
		private final Assignment cT44Assignment_1_0_1_1 = (Assignment)cGroup_1_0_1.eContents().get(1);
		private final RuleCall cT44StatementExpressionParserRuleCall_1_0_1_1_0 = (RuleCall)cT44Assignment_1_0_1_1.eContents().get(0);
		private final Group cGroup_1_0_1_2 = (Group)cGroup_1_0_1.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_1_0_1_2_0 = (RuleCall)cGroup_1_0_1_2.eContents().get(0);
		private final Assignment cT45Assignment_1_0_1_2_1 = (Assignment)cGroup_1_0_1_2.eContents().get(1);
		private final RuleCall cT45ExpressionParserRuleCall_1_0_1_2_1_0 = (RuleCall)cT45Assignment_1_0_1_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_1_0_1_3 = (RuleCall)cGroup_1_0_1.eContents().get(3);
		private final Assignment cT6Assignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cT6TypePrimaryExpressionParserRuleCall_1_1_0 = (RuleCall)cT6Assignment_1_1.eContents().get(0);
		
		/// * This rule will match:
		// * Float - an ID representation of a type
		// * List(Float) - a type function call
		// * List Float - a non-parenthesis form if only one parameter
		// * 
		// * The second two forms are known as a parameterised type or
		// * functor (not necessarily a true
		// * functor since it may not obey the axioms of a functor).
		// * If there is only one parameter then the parenthesis are optional
		// * / TypeNameOrFunctionCall hidden(WS):
		//	tfnname=ID ((LPAREN (ID COLON)? t4=TypeExpression? (COMMA (ID COLON)? t25+=TypeExpression)* RPAREN) // optional curried function:
		//	(LPAREN t44+=StatementExpression? (COMMA t45+=Expression)* RPAREN)* // option of no parenthesis for single parameter
		//	| => t6=TypePrimaryExpression)?;
		public ParserRule getRule() { return rule; }

		//tfnname=ID ((LPAREN (ID COLON)? t4=TypeExpression? (COMMA (ID COLON)? t25+=TypeExpression)* RPAREN) // optional curried function:
		//(LPAREN t44+=StatementExpression? (COMMA t45+=Expression)* RPAREN)* // option of no parenthesis for single parameter
		//| => t6=TypePrimaryExpression)?
		public Group getGroup() { return cGroup; }

		//tfnname=ID
		public Assignment getTfnnameAssignment_0() { return cTfnnameAssignment_0; }

		//ID
		public RuleCall getTfnnameIDTerminalRuleCall_0_0() { return cTfnnameIDTerminalRuleCall_0_0; }

		//((LPAREN (ID COLON)? t4=TypeExpression? (COMMA (ID COLON)? t25+=TypeExpression)* RPAREN) // optional curried function:
		//(LPAREN t44+=StatementExpression? (COMMA t45+=Expression)* RPAREN)* // option of no parenthesis for single parameter
		//| => t6=TypePrimaryExpression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//(LPAREN (ID COLON)? t4=TypeExpression? (COMMA (ID COLON)? t25+=TypeExpression)* RPAREN) // optional curried function:
		//(LPAREN t44+=StatementExpression? (COMMA t45+=Expression)* RPAREN)*
		public Group getGroup_1_0() { return cGroup_1_0; }

		//LPAREN (ID COLON)? t4=TypeExpression? (COMMA (ID COLON)? t25+=TypeExpression)* RPAREN
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_1_0_0_0() { return cLPARENTerminalRuleCall_1_0_0_0; }

		//(ID COLON)?
		public Group getGroup_1_0_0_1() { return cGroup_1_0_0_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_0_0_1_0() { return cIDTerminalRuleCall_1_0_0_1_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_1_0_0_1_1() { return cCOLONTerminalRuleCall_1_0_0_1_1; }

		//t4=TypeExpression?
		public Assignment getT4Assignment_1_0_0_2() { return cT4Assignment_1_0_0_2; }

		//TypeExpression
		public RuleCall getT4TypeExpressionParserRuleCall_1_0_0_2_0() { return cT4TypeExpressionParserRuleCall_1_0_0_2_0; }

		//(COMMA (ID COLON)? t25+=TypeExpression)*
		public Group getGroup_1_0_0_3() { return cGroup_1_0_0_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_0_0_3_0() { return cCOMMATerminalRuleCall_1_0_0_3_0; }

		//(ID COLON)?
		public Group getGroup_1_0_0_3_1() { return cGroup_1_0_0_3_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_0_0_3_1_0() { return cIDTerminalRuleCall_1_0_0_3_1_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_1_0_0_3_1_1() { return cCOLONTerminalRuleCall_1_0_0_3_1_1; }

		//t25+=TypeExpression
		public Assignment getT25Assignment_1_0_0_3_2() { return cT25Assignment_1_0_0_3_2; }

		//TypeExpression
		public RuleCall getT25TypeExpressionParserRuleCall_1_0_0_3_2_0() { return cT25TypeExpressionParserRuleCall_1_0_0_3_2_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_1_0_0_4() { return cRPARENTerminalRuleCall_1_0_0_4; }

		//(LPAREN t44+=StatementExpression? (COMMA t45+=Expression)* RPAREN)*
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_1_0_1_0() { return cLPARENTerminalRuleCall_1_0_1_0; }

		//t44+=StatementExpression?
		public Assignment getT44Assignment_1_0_1_1() { return cT44Assignment_1_0_1_1; }

		//StatementExpression
		public RuleCall getT44StatementExpressionParserRuleCall_1_0_1_1_0() { return cT44StatementExpressionParserRuleCall_1_0_1_1_0; }

		//(COMMA t45+=Expression)*
		public Group getGroup_1_0_1_2() { return cGroup_1_0_1_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_0_1_2_0() { return cCOMMATerminalRuleCall_1_0_1_2_0; }

		//t45+=Expression
		public Assignment getT45Assignment_1_0_1_2_1() { return cT45Assignment_1_0_1_2_1; }

		//Expression
		public RuleCall getT45ExpressionParserRuleCall_1_0_1_2_1_0() { return cT45ExpressionParserRuleCall_1_0_1_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_1_0_1_3() { return cRPARENTerminalRuleCall_1_0_1_3; }

		//=> t6=TypePrimaryExpression
		public Assignment getT6Assignment_1_1() { return cT6Assignment_1_1; }

		//TypePrimaryExpression
		public RuleCall getT6TypePrimaryExpressionParserRuleCall_1_1_0() { return cT6TypePrimaryExpressionParserRuleCall_1_1_0; }
	}

	public class TupleDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TupleDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLPARENTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cT4Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT4TypeExpressionParserRuleCall_1_0 = (RuleCall)cT4Assignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cT25Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cT25TypeExpressionParserRuleCall_2_1_0 = (RuleCall)cT25Assignment_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		/// * This has a form like: (Integer,Float,String)
		// * like an array where each entry can be of a different type
		// * / TupleDefinition hidden(WS):
		//	LPAREN t4=TypeExpression (COMMA t25+=TypeExpression)* RPAREN;
		public ParserRule getRule() { return rule; }

		//LPAREN t4=TypeExpression (COMMA t25+=TypeExpression)* RPAREN
		public Group getGroup() { return cGroup; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_0() { return cLPARENTerminalRuleCall_0; }

		//t4=TypeExpression
		public Assignment getT4Assignment_1() { return cT4Assignment_1; }

		//TypeExpression
		public RuleCall getT4TypeExpressionParserRuleCall_1_0() { return cT4TypeExpressionParserRuleCall_1_0; }

		//(COMMA t25+=TypeExpression)*
		public Group getGroup_2() { return cGroup_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_2_0() { return cCOMMATerminalRuleCall_2_0; }

		//t25+=TypeExpression
		public Assignment getT25Assignment_2_1() { return cT25Assignment_2_1; }

		//TypeExpression
		public RuleCall getT25TypeExpressionParserRuleCall_2_1_0() { return cT25TypeExpressionParserRuleCall_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3() { return cRPARENTerminalRuleCall_3; }
	}

	public class TypeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cT1Assignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cT1INTTerminalRuleCall_0_0 = (RuleCall)cT1Assignment_0.eContents().get(0);
		private final Assignment cT22Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cT22STRINGTerminalRuleCall_1_0 = (RuleCall)cT22Assignment_1.eContents().get(0);
		private final Assignment cT34Assignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cT34CharacterLiteralParserRuleCall_2_0 = (RuleCall)cT34Assignment_2.eContents().get(0);
		private final Assignment cT35Assignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cT35BooleanLiteralParserRuleCall_3_0 = (RuleCall)cT35Assignment_3.eContents().get(0);
		
		/// * Since SPAD supports dependent types then numbers and strings can occur here.
		// * Outstanding issues:
		// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
		// *    and convert to float literal
		// * 2) We need to be able to recognise exponent notation for floats
		// * 3) Integers without '-' prefix can be converted to PI or NNI
		// * 4) need to add hex or octal notation for integers (0xhhhh)
		// * 5) String and Character literals need to have backslash "\" doubled to
		// *    "\\" otherwise xtext will interpret backslash as an escape character.
		// * 6) values following immediately after string literal such as "abc"d should
		// *    represent an implied concat: concat("abc",d)
		// * / TypeLiteral hidden(WS):
		//	t1=INT | t22=STRING | // t3=FloatLiteral |
		//	t34=CharacterLiteral | t35=BooleanLiteral;
		public ParserRule getRule() { return rule; }

		//t1=INT | t22=STRING | // t3=FloatLiteral |
		//t34=CharacterLiteral | t35=BooleanLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//t1=INT
		public Assignment getT1Assignment_0() { return cT1Assignment_0; }

		//INT
		public RuleCall getT1INTTerminalRuleCall_0_0() { return cT1INTTerminalRuleCall_0_0; }

		//t22=STRING
		public Assignment getT22Assignment_1() { return cT22Assignment_1; }

		//STRING
		public RuleCall getT22STRINGTerminalRuleCall_1_0() { return cT22STRINGTerminalRuleCall_1_0; }

		//// t3=FloatLiteral |
		//t34=CharacterLiteral
		public Assignment getT34Assignment_2() { return cT34Assignment_2; }

		//CharacterLiteral
		public RuleCall getT34CharacterLiteralParserRuleCall_2_0() { return cT34CharacterLiteralParserRuleCall_2_0; }

		//t35=BooleanLiteral
		public Assignment getT35Assignment_3() { return cT35Assignment_3; }

		//BooleanLiteral
		public RuleCall getT35BooleanLiteralParserRuleCall_3_0() { return cT35BooleanLiteralParserRuleCall_3_0; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cS1Assignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cS1BlockParserRuleCall_0_0 = (RuleCall)cS1Assignment_0.eContents().get(0);
		private final Assignment cS3Assignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cS3StatementExpressionParserRuleCall_1_0 = (RuleCall)cS3Assignment_1.eContents().get(0);
		private final Assignment cS4Assignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cS4IfStatementParserRuleCall_2_0 = (RuleCall)cS4Assignment_2.eContents().get(0);
		private final Assignment cS4bAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cS4bIfElseStatementParserRuleCall_3_0 = (RuleCall)cS4bAssignment_3.eContents().get(0);
		private final Assignment cS5Assignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cS5WhileStatementParserRuleCall_4_0 = (RuleCall)cS5Assignment_4.eContents().get(0);
		private final Assignment cS6Assignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cS6DoStatementParserRuleCall_5_0 = (RuleCall)cS6Assignment_5.eContents().get(0);
		private final Assignment cS7Assignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cS7ForStatementParserRuleCall_6_0 = (RuleCall)cS7Assignment_6.eContents().get(0);
		private final Assignment cS8Assignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cS8BreakStatementParserRuleCall_7_0 = (RuleCall)cS8Assignment_7.eContents().get(0);
		private final Assignment cS12Assignment_8 = (Assignment)cAlternatives.eContents().get(8);
		private final RuleCall cS12RepeatStatementParserRuleCall_8_0 = (RuleCall)cS12Assignment_8.eContents().get(0);
		private final Assignment cS9Assignment_9 = (Assignment)cAlternatives.eContents().get(9);
		private final RuleCall cS9IterateStatementParserRuleCall_9_0 = (RuleCall)cS9Assignment_9.eContents().get(0);
		private final Assignment cS10Assignment_10 = (Assignment)cAlternatives.eContents().get(10);
		private final RuleCall cS10ReturnStatementParserRuleCall_10_0 = (RuleCall)cS10Assignment_10.eContents().get(0);
		
		/// * In FunctionDefinition the algorithm is defined by a sequence of the
		// * following statements:
		// * / Statement hidden(WS, SL_COMMENT):
		//	s1=Block | s3=StatementExpression | // 'if' can occur in an expression or in
		//	// a statement so we use '=>' to choose
		//	// expression if there is any ambiguity
		//	s4=IfStatement | s4b=IfElseStatement | //    s4c=IfThenStatement |
		//	s5=WhileStatement | s6=DoStatement | s7=ForStatement | s8=BreakStatement | s12=RepeatStatement | s9=IterateStatement | //    s11= ContinueStatement|
		//	s10=ReturnStatement;
		public ParserRule getRule() { return rule; }

		//s1=Block | s3=StatementExpression | // 'if' can occur in an expression or in
		//// a statement so we use '=>' to choose
		//// expression if there is any ambiguity
		//s4=IfStatement | s4b=IfElseStatement | //    s4c=IfThenStatement |
		//s5=WhileStatement | s6=DoStatement | s7=ForStatement | s8=BreakStatement | s12=RepeatStatement | s9=IterateStatement | //    s11= ContinueStatement|
		//s10=ReturnStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//s1=Block
		public Assignment getS1Assignment_0() { return cS1Assignment_0; }

		//Block
		public RuleCall getS1BlockParserRuleCall_0_0() { return cS1BlockParserRuleCall_0_0; }

		//s3=StatementExpression
		public Assignment getS3Assignment_1() { return cS3Assignment_1; }

		//StatementExpression
		public RuleCall getS3StatementExpressionParserRuleCall_1_0() { return cS3StatementExpressionParserRuleCall_1_0; }

		//// 'if' can occur in an expression or in
		//// a statement so we use '=>' to choose
		//// expression if there is any ambiguity
		//s4=IfStatement
		public Assignment getS4Assignment_2() { return cS4Assignment_2; }

		//IfStatement
		public RuleCall getS4IfStatementParserRuleCall_2_0() { return cS4IfStatementParserRuleCall_2_0; }

		//s4b=IfElseStatement
		public Assignment getS4bAssignment_3() { return cS4bAssignment_3; }

		//IfElseStatement
		public RuleCall getS4bIfElseStatementParserRuleCall_3_0() { return cS4bIfElseStatementParserRuleCall_3_0; }

		////    s4c=IfThenStatement |
		//s5=WhileStatement
		public Assignment getS5Assignment_4() { return cS5Assignment_4; }

		//WhileStatement
		public RuleCall getS5WhileStatementParserRuleCall_4_0() { return cS5WhileStatementParserRuleCall_4_0; }

		//s6=DoStatement
		public Assignment getS6Assignment_5() { return cS6Assignment_5; }

		//DoStatement
		public RuleCall getS6DoStatementParserRuleCall_5_0() { return cS6DoStatementParserRuleCall_5_0; }

		//s7=ForStatement
		public Assignment getS7Assignment_6() { return cS7Assignment_6; }

		//ForStatement
		public RuleCall getS7ForStatementParserRuleCall_6_0() { return cS7ForStatementParserRuleCall_6_0; }

		//s8=BreakStatement
		public Assignment getS8Assignment_7() { return cS8Assignment_7; }

		//BreakStatement
		public RuleCall getS8BreakStatementParserRuleCall_7_0() { return cS8BreakStatementParserRuleCall_7_0; }

		//s12=RepeatStatement
		public Assignment getS12Assignment_8() { return cS12Assignment_8; }

		//RepeatStatement
		public RuleCall getS12RepeatStatementParserRuleCall_8_0() { return cS12RepeatStatementParserRuleCall_8_0; }

		//s9=IterateStatement
		public Assignment getS9Assignment_9() { return cS9Assignment_9; }

		//IterateStatement
		public RuleCall getS9IterateStatementParserRuleCall_9_0() { return cS9IterateStatementParserRuleCall_9_0; }

		////    s11= ContinueStatement|
		//s10=ReturnStatement
		public Assignment getS10Assignment_10() { return cS10Assignment_10; }

		//ReturnStatement
		public RuleCall getS10ReturnStatementParserRuleCall_10_0() { return cS10ReturnStatementParserRuleCall_10_0; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStnameLBRACETerminalRuleCall_0_0 = (RuleCall)cStnameAssignment_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cStatemBlAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cStatemBlStatementParserRuleCall_2_0_0 = (RuleCall)cStatemBlAssignment_2_0.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_2_1_0 = (RuleCall)cAlternatives_2_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2_1_1 = (RuleCall)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cRBRACETerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		/// * allows multiple statements which are grouped by wrapping in curly brackets * / Block hidden(WS, SL_COMMENT):
		//	stname=LBRACE NL* (statemBl+=Statement (NL | SEMICOLON)+)* RBRACE;
		public ParserRule getRule() { return rule; }

		//stname=LBRACE NL* (statemBl+=Statement (NL | SEMICOLON)+)* RBRACE
		public Group getGroup() { return cGroup; }

		//stname=LBRACE
		public Assignment getStnameAssignment_0() { return cStnameAssignment_0; }

		//LBRACE
		public RuleCall getStnameLBRACETerminalRuleCall_0_0() { return cStnameLBRACETerminalRuleCall_0_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//(statemBl+=Statement (NL | SEMICOLON)+)*
		public Group getGroup_2() { return cGroup_2; }

		//statemBl+=Statement
		public Assignment getStatemBlAssignment_2_0() { return cStatemBlAssignment_2_0; }

		//Statement
		public RuleCall getStatemBlStatementParserRuleCall_2_0_0() { return cStatemBlStatementParserRuleCall_2_0_0; }

		//(NL | SEMICOLON)+
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_2_1_0() { return cNLTerminalRuleCall_2_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2_1_1() { return cSEMICOLONTerminalRuleCall_2_1_1; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_3() { return cRBRACETerminalRuleCall_3; }
	}

	public class StatementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StatementExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTConditionExpressionParserRuleCall_0_0 = (RuleCall)cTAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cBECOMESTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cT5Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cT5BlockParserRuleCall_1_1_0 = (RuleCall)cT5Assignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cEXITTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cT4Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cT4StatementParserRuleCall_2_1_0 = (RuleCall)cT4Assignment_2_1.eContents().get(0);
		
		/// *
		// * Gives a value or assigns a value to a variable or does conditional exit
		// * 
		// * examples:
		// * x
		// * x:Int
		// * x,y:INT -- multiple assignment
		// * x:Int := 3
		// * 
		// * x=y => 3
		// * / StatementExpression hidden(WS, SL_COMMENT): //(ID COMMA)* // allow multiple assignment
		//	t= // was Expression but changed so that 'if' statement
		//	ConditionExpression // does not clash with if-then-else expression
		//	//    (COLON t2=TypeExpression)?
		//	//    (BECOMES t3=Expression (BECOMES t33+=Expression)*)?
		//	(BECOMES t5=Block)? // breaks out of a block if predicate before '=>' is true then program
		//	// control leaves the block.
		//	// Put it here so that it can only occur at the top level of an expression.
		//	// if inside some complicated expression then it must be terminated with ';'.
		//	(EXIT t4=Statement)?;
		public ParserRule getRule() { return rule; }

		////(ID COMMA)* // allow multiple assignment
		//t= // was Expression but changed so that 'if' statement
		//ConditionExpression // does not clash with if-then-else expression
		////    (COLON t2=TypeExpression)?
		////    (BECOMES t3=Expression (BECOMES t33+=Expression)*)?
		//(BECOMES t5=Block)? // breaks out of a block if predicate before '=>' is true then program
		//// control leaves the block.
		//// Put it here so that it can only occur at the top level of an expression.
		//// if inside some complicated expression then it must be terminated with ';'.
		//(EXIT t4=Statement)?
		public Group getGroup() { return cGroup; }

		////(ID COMMA)* // allow multiple assignment
		//t= // was Expression but changed so that 'if' statement
		//ConditionExpression
		public Assignment getTAssignment_0() { return cTAssignment_0; }

		//// was Expression but changed so that 'if' statement
		//ConditionExpression
		public RuleCall getTConditionExpressionParserRuleCall_0_0() { return cTConditionExpressionParserRuleCall_0_0; }

		//(BECOMES t5=Block)?
		public Group getGroup_1() { return cGroup_1; }

		//BECOMES
		public RuleCall getBECOMESTerminalRuleCall_1_0() { return cBECOMESTerminalRuleCall_1_0; }

		//t5=Block
		public Assignment getT5Assignment_1_1() { return cT5Assignment_1_1; }

		//Block
		public RuleCall getT5BlockParserRuleCall_1_1_0() { return cT5BlockParserRuleCall_1_1_0; }

		//(EXIT t4=Statement)?
		public Group getGroup_2() { return cGroup_2; }

		//EXIT
		public RuleCall getEXITTerminalRuleCall_2_0() { return cEXITTerminalRuleCall_2_0; }

		//t4=Statement
		public Assignment getT4Assignment_2_1() { return cT4Assignment_2_1; }

		//Statement
		public RuleCall getT4StatementParserRuleCall_2_1_0() { return cT4StatementParserRuleCall_2_1_0; }
	}

	public class ForStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cStnameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cStnameIDTerminalRuleCall_1_0_0 = (RuleCall)cStnameAssignment_1_0.eContents().get(0);
		private final Keyword cInKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cT1Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cT1ExpressionParserRuleCall_1_2_0 = (RuleCall)cT1Assignment_1_2.eContents().get(0);
		private final RuleCall cSEGTerminalRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Group cGroup_1_4 = (Group)cGroup_1.eContents().get(4);
		private final Keyword cByKeyword_1_4_0 = (Keyword)cGroup_1_4.eContents().get(0);
		private final Assignment cBy1Assignment_1_4_1 = (Assignment)cGroup_1_4.eContents().get(1);
		private final RuleCall cBy1ExpressionParserRuleCall_1_4_1_0 = (RuleCall)cBy1Assignment_1_4_1.eContents().get(0);
		private final Group cGroup_1_5 = (Group)cGroup_1.eContents().get(5);
		private final Keyword cForKeyword_1_5_0 = (Keyword)cGroup_1_5.eContents().get(0);
		private final Assignment cStname2Assignment_1_5_1 = (Assignment)cGroup_1_5.eContents().get(1);
		private final RuleCall cStname2IDTerminalRuleCall_1_5_1_0 = (RuleCall)cStname2Assignment_1_5_1.eContents().get(0);
		private final Keyword cInKeyword_1_5_2 = (Keyword)cGroup_1_5.eContents().get(2);
		private final Assignment cT2Assignment_1_5_3 = (Assignment)cGroup_1_5.eContents().get(3);
		private final RuleCall cT2ExpressionParserRuleCall_1_5_3_0 = (RuleCall)cT2Assignment_1_5_3.eContents().get(0);
		private final Group cGroup_1_5_4 = (Group)cGroup_1_5.eContents().get(4);
		private final Keyword cByKeyword_1_5_4_0 = (Keyword)cGroup_1_5_4.eContents().get(0);
		private final Assignment cBy2Assignment_1_5_4_1 = (Assignment)cGroup_1_5_4.eContents().get(1);
		private final RuleCall cBy2ExpressionParserRuleCall_1_5_4_1_0 = (RuleCall)cBy2Assignment_1_5_4_1.eContents().get(0);
		private final RuleCall cSEGTerminalRuleCall_1_5_5 = (RuleCall)cGroup_1_5.eContents().get(5);
		private final Group cGroup_1_6 = (Group)cGroup_1.eContents().get(6);
		private final Keyword cWhileKeyword_1_6_0 = (Keyword)cGroup_1_6.eContents().get(0);
		private final Assignment cT2Assignment_1_6_1 = (Assignment)cGroup_1_6.eContents().get(1);
		private final RuleCall cT2ExpressionParserRuleCall_1_6_1_0 = (RuleCall)cT2Assignment_1_6_1.eContents().get(0);
		private final Keyword cRepeatKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cS1Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cS1StatementParserRuleCall_4_0 = (RuleCall)cS1Assignment_4.eContents().get(0);
		
		/// *
		// * for i in n..m repeat ... is 1
		// * for i in n..m by s repeat ...
		// * for i in list repeat ...
		// * for i in list for i in 1..length() repeat ...
		// * for i in list for i in 1.. repeat ...
		// * for j in n..m repeat loopBody
		// * for j in n..m | odd? j repeat
		// * 
		// * To Do
		// * -----
		// * As a temporary measure we check for '..' as a suffix operator
		// * here, but we should really put this into expression?
		// * 
		// * We need to allow conditions using BAR '|'
		// * / ForStatement hidden(WS, SL_COMMENT):
		//	"for" (stname=ID "in" t1=Expression SEG? //(=> '..' t2=Expression)?
		//	("by" by1=Expression)? //       (=> BAR t2=PredicateOr)? // condition
		//	("for" stname2+=ID "in" t2+=Expression ("by" by2+=Expression)? SEG?)* ("while" t2+=Expression)*) "repeat" NL? s1= //('is' s2=Statement)?
		//	Statement;
		public ParserRule getRule() { return rule; }

		//"for" (stname=ID "in" t1=Expression SEG? //(=> '..' t2=Expression)?
		//("by" by1=Expression)? //       (=> BAR t2=PredicateOr)? // condition
		//("for" stname2+=ID "in" t2+=Expression ("by" by2+=Expression)? SEG?)* ("while" t2+=Expression)*) "repeat" NL? s1= //('is' s2=Statement)?
		//Statement
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//stname=ID "in" t1=Expression SEG? //(=> '..' t2=Expression)?
		//("by" by1=Expression)? //       (=> BAR t2=PredicateOr)? // condition
		//("for" stname2+=ID "in" t2+=Expression ("by" by2+=Expression)? SEG?)* ("while" t2+=Expression)*
		public Group getGroup_1() { return cGroup_1; }

		//stname=ID
		public Assignment getStnameAssignment_1_0() { return cStnameAssignment_1_0; }

		//ID
		public RuleCall getStnameIDTerminalRuleCall_1_0_0() { return cStnameIDTerminalRuleCall_1_0_0; }

		//"in"
		public Keyword getInKeyword_1_1() { return cInKeyword_1_1; }

		//t1=Expression
		public Assignment getT1Assignment_1_2() { return cT1Assignment_1_2; }

		//Expression
		public RuleCall getT1ExpressionParserRuleCall_1_2_0() { return cT1ExpressionParserRuleCall_1_2_0; }

		//SEG?
		public RuleCall getSEGTerminalRuleCall_1_3() { return cSEGTerminalRuleCall_1_3; }

		//("by" by1=Expression)?
		public Group getGroup_1_4() { return cGroup_1_4; }

		//"by"
		public Keyword getByKeyword_1_4_0() { return cByKeyword_1_4_0; }

		//by1=Expression
		public Assignment getBy1Assignment_1_4_1() { return cBy1Assignment_1_4_1; }

		//Expression
		public RuleCall getBy1ExpressionParserRuleCall_1_4_1_0() { return cBy1ExpressionParserRuleCall_1_4_1_0; }

		//("for" stname2+=ID "in" t2+=Expression ("by" by2+=Expression)? SEG?)*
		public Group getGroup_1_5() { return cGroup_1_5; }

		//"for"
		public Keyword getForKeyword_1_5_0() { return cForKeyword_1_5_0; }

		//stname2+=ID
		public Assignment getStname2Assignment_1_5_1() { return cStname2Assignment_1_5_1; }

		//ID
		public RuleCall getStname2IDTerminalRuleCall_1_5_1_0() { return cStname2IDTerminalRuleCall_1_5_1_0; }

		//"in"
		public Keyword getInKeyword_1_5_2() { return cInKeyword_1_5_2; }

		//t2+=Expression
		public Assignment getT2Assignment_1_5_3() { return cT2Assignment_1_5_3; }

		//Expression
		public RuleCall getT2ExpressionParserRuleCall_1_5_3_0() { return cT2ExpressionParserRuleCall_1_5_3_0; }

		//("by" by2+=Expression)?
		public Group getGroup_1_5_4() { return cGroup_1_5_4; }

		//"by"
		public Keyword getByKeyword_1_5_4_0() { return cByKeyword_1_5_4_0; }

		//by2+=Expression
		public Assignment getBy2Assignment_1_5_4_1() { return cBy2Assignment_1_5_4_1; }

		//Expression
		public RuleCall getBy2ExpressionParserRuleCall_1_5_4_1_0() { return cBy2ExpressionParserRuleCall_1_5_4_1_0; }

		//SEG?
		public RuleCall getSEGTerminalRuleCall_1_5_5() { return cSEGTerminalRuleCall_1_5_5; }

		//("while" t2+=Expression)*
		public Group getGroup_1_6() { return cGroup_1_6; }

		//"while"
		public Keyword getWhileKeyword_1_6_0() { return cWhileKeyword_1_6_0; }

		//t2+=Expression
		public Assignment getT2Assignment_1_6_1() { return cT2Assignment_1_6_1; }

		//Expression
		public RuleCall getT2ExpressionParserRuleCall_1_6_1_0() { return cT2ExpressionParserRuleCall_1_6_1_0; }

		//"repeat"
		public Keyword getRepeatKeyword_2() { return cRepeatKeyword_2; }

		//NL?
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//s1= //('is' s2=Statement)?
		//Statement
		public Assignment getS1Assignment_4() { return cS1Assignment_4; }

		////('is' s2=Statement)?
		//Statement
		public RuleCall getS1StatementParserRuleCall_4_0() { return cS1StatementParserRuleCall_4_0; }
	}

	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cStnameWhileKeyword_0_0 = (Keyword)cStnameAssignment_0.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT2ExpressionParserRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Keyword cRepeatKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cS1Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cS1StatementParserRuleCall_4_0 = (RuleCall)cS1Assignment_4.eContents().get(0);
		
		/// *
		// * while BoolExpr repeat loopBody
		// * / WhileStatement hidden(WS, SL_COMMENT):
		//	stname="while" t2= / *PredicateOr* / Expression "repeat" NL? s1=Statement;
		public ParserRule getRule() { return rule; }

		//stname="while" t2= / *PredicateOr* / Expression "repeat" NL? s1=Statement
		public Group getGroup() { return cGroup; }

		//stname="while"
		public Assignment getStnameAssignment_0() { return cStnameAssignment_0; }

		//"while"
		public Keyword getStnameWhileKeyword_0_0() { return cStnameWhileKeyword_0_0; }

		//t2= / *PredicateOr* / Expression
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		/// *PredicateOr* / Expression
		public RuleCall getT2ExpressionParserRuleCall_1_0() { return cT2ExpressionParserRuleCall_1_0; }

		//"repeat"
		public Keyword getRepeatKeyword_2() { return cRepeatKeyword_2; }

		//NL?
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//s1=Statement
		public Assignment getS1Assignment_4() { return cS1Assignment_4; }

		//Statement
		public RuleCall getS1StatementParserRuleCall_4_0() { return cS1StatementParserRuleCall_4_0; }
	}

	public class DoStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cStnameDoKeyword_0_0 = (Keyword)cStnameAssignment_0.eContents().get(0);
		private final Assignment cS1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cS1StatementParserRuleCall_1_0 = (RuleCall)cS1Assignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cNLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cT2Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cT2ExpressionParserRuleCall_4_0 = (RuleCall)cT2Assignment_4.eContents().get(0);
		
		/// *
		// *  do loopBody while BoolExpr
		// * / DoStatement hidden(WS, SL_COMMENT):
		//	stname="do" s1=Statement "while" NL? t2= / *PredicateOr* / Expression;
		public ParserRule getRule() { return rule; }

		//stname="do" s1=Statement "while" NL? t2= / *PredicateOr* / Expression
		public Group getGroup() { return cGroup; }

		//stname="do"
		public Assignment getStnameAssignment_0() { return cStnameAssignment_0; }

		//"do"
		public Keyword getStnameDoKeyword_0_0() { return cStnameDoKeyword_0_0; }

		//s1=Statement
		public Assignment getS1Assignment_1() { return cS1Assignment_1; }

		//Statement
		public RuleCall getS1StatementParserRuleCall_1_0() { return cS1StatementParserRuleCall_1_0; }

		//"while"
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }

		//NL?
		public RuleCall getNLTerminalRuleCall_3() { return cNLTerminalRuleCall_3; }

		//t2= / *PredicateOr* / Expression
		public Assignment getT2Assignment_4() { return cT2Assignment_4; }

		/// *PredicateOr* / Expression
		public RuleCall getT2ExpressionParserRuleCall_4_0() { return cT2ExpressionParserRuleCall_4_0; }
	}

	public class RepeatStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RepeatStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cStnameRepeatKeyword_0_0 = (Keyword)cStnameAssignment_0.eContents().get(0);
		private final Assignment cS1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cS1StatementParserRuleCall_1_0 = (RuleCall)cS1Assignment_1.eContents().get(0);
		
		/// *
		// *  will repeat until we jump out. For instance by calling return.
		// * / RepeatStatement hidden(WS, SL_COMMENT):
		//	stname="repeat" s1=Statement;
		public ParserRule getRule() { return rule; }

		//stname="repeat" s1=Statement
		public Group getGroup() { return cGroup; }

		//stname="repeat"
		public Assignment getStnameAssignment_0() { return cStnameAssignment_0; }

		//"repeat"
		public Keyword getStnameRepeatKeyword_0_0() { return cStnameRepeatKeyword_0_0; }

		//s1=Statement
		public Assignment getS1Assignment_1() { return cS1Assignment_1; }

		//Statement
		public RuleCall getS1StatementParserRuleCall_1_0() { return cS1StatementParserRuleCall_1_0; }
	}

	public class IterateStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IterateStatement");
		private final Assignment cStnameAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cStnameIterateKeyword_0 = (Keyword)cStnameAssignment.eContents().get(0);
		
		/// *
		// * iterate ...
		// * skips over the remainder of a loop 
		// * / IterateStatement hidden(WS, SL_COMMENT):
		//	stname="iterate";
		public ParserRule getRule() { return rule; }

		//stname="iterate"
		public Assignment getStnameAssignment() { return cStnameAssignment; }

		//"iterate"
		public Keyword getStnameIterateKeyword_0() { return cStnameIterateKeyword_0; }
	}

	public class BreakStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BreakStatement");
		private final Assignment cStnameAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cStnameBreakKeyword_0 = (Keyword)cStnameAssignment.eContents().get(0);
		
		/// *
		// * break 	leave current loop 
		// * / BreakStatement hidden(WS, SL_COMMENT):
		//	stname="break";
		public ParserRule getRule() { return rule; }

		//stname="break"
		public Assignment getStnameAssignment() { return cStnameAssignment; }

		//"break"
		public Keyword getStnameBreakKeyword_0() { return cStnameBreakKeyword_0; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cStnameReturnKeyword_0_0 = (Keyword)cStnameAssignment_0.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT2ExpressionParserRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		
		/// *
		// * return 	leave current function 
		// * / ReturnStatement hidden(WS):
		//	stname="return" t2=Expression;
		public ParserRule getRule() { return rule; }

		//stname="return" t2=Expression
		public Group getGroup() { return cGroup; }

		//stname="return"
		public Assignment getStnameAssignment_0() { return cStnameAssignment_0; }

		//"return"
		public Keyword getStnameReturnKeyword_0_0() { return cStnameReturnKeyword_0_0; }

		//t2=Expression
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//Expression
		public RuleCall getT2ExpressionParserRuleCall_1_0() { return cT2ExpressionParserRuleCall_1_0; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cT2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT2ExpressionParserRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cThenKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Assignment cS1Assignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cS1StatementParserRuleCall_2_0_1_0 = (RuleCall)cS1Assignment_2_0_1.eContents().get(0);
		private final Group cGroup_2_0_2 = (Group)cGroup_2_0.eContents().get(2);
		private final Keyword cElseKeyword_2_0_2_0 = (Keyword)cGroup_2_0_2.eContents().get(0);
		private final Assignment cS2Assignment_2_0_2_1 = (Assignment)cGroup_2_0_2.eContents().get(1);
		private final RuleCall cS2StatementParserRuleCall_2_0_2_1_0 = (RuleCall)cS2Assignment_2_0_2_1.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cBAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cBLBRACETerminalRuleCall_2_1_0_0 = (RuleCall)cBAssignment_2_1_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_2_1_1 = (RuleCall)cGroup_2_1.eContents().get(1);
		private final Keyword cThenKeyword_2_1_2 = (Keyword)cGroup_2_1.eContents().get(2);
		private final Assignment cS11Assignment_2_1_3 = (Assignment)cGroup_2_1.eContents().get(3);
		private final RuleCall cS11StatementParserRuleCall_2_1_3_0 = (RuleCall)cS11Assignment_2_1_3.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_2_1_4 = (RuleCall)cGroup_2_1.eContents().get(4);
		private final Group cGroup_2_1_5 = (Group)cGroup_2_1.eContents().get(5);
		private final Keyword cElseKeyword_2_1_5_0 = (Keyword)cGroup_2_1_5.eContents().get(0);
		private final Assignment cS12Assignment_2_1_5_1 = (Assignment)cGroup_2_1_5.eContents().get(1);
		private final RuleCall cS12StatementParserRuleCall_2_1_5_1_0 = (RuleCall)cS12Assignment_2_1_5_1.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_2_1_5_2 = (RuleCall)cGroup_2_1_5.eContents().get(2);
		private final RuleCall cRBRACETerminalRuleCall_2_1_6 = (RuleCall)cGroup_2_1.eContents().get(6);
		
		/// * 'if' statement allows program flow to be switched
		// * forms:
		// * if boolean then
		// * if equation then
		// * if ... not ... and ...or ... then
		// * if ... then ... else ...
		// * note1:
		// * if ... then ... else ... always returns a value so we can use this
		// * on the right hand side of an assignment
		// * note2:
		// * since there is an explicit 'then' keyword there is no need to put
		// * the condition in brackets
		// * 	
		// * examples:
		// * a:= if x >0 then x else -x
		// * if R has Field then ... 	  	 
		// * if myUnion case mtType then ...
		// * 
		// * we also need to allow a form like this:
		// * if x >0 {
		// *   then x
		// *   else -x
		// * }
		// * 
		// * also this form (this requires IfElseStatement rule):
		// * if x >0 then {
		// *   x
		// * }
		// * else {
		// *   -x
		// * }
		// * / IfStatement hidden(WS, SL_COMMENT):
		//	"if" t2=Expression ("then" s1=Statement ("else" s2=Statement)? //  'if' t2=ConditionExpression
		//	| b?=LBRACE NL+ "then" s11=Statement NL* ("else" s12=Statement NL*)? RBRACE);
		public ParserRule getRule() { return rule; }

		//"if" t2=Expression ("then" s1=Statement ("else" s2=Statement)? //  'if' t2=ConditionExpression
		//| b?=LBRACE NL+ "then" s11=Statement NL* ("else" s12=Statement NL*)? RBRACE)
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//t2=Expression
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }

		//Expression
		public RuleCall getT2ExpressionParserRuleCall_1_0() { return cT2ExpressionParserRuleCall_1_0; }

		//"then" s1=Statement ("else" s2=Statement)? //  'if' t2=ConditionExpression
		//| b?=LBRACE NL+ "then" s11=Statement NL* ("else" s12=Statement NL*)? RBRACE
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"then" s1=Statement ("else" s2=Statement)?
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"then"
		public Keyword getThenKeyword_2_0_0() { return cThenKeyword_2_0_0; }

		//s1=Statement
		public Assignment getS1Assignment_2_0_1() { return cS1Assignment_2_0_1; }

		//Statement
		public RuleCall getS1StatementParserRuleCall_2_0_1_0() { return cS1StatementParserRuleCall_2_0_1_0; }

		//(=> "else" s2=Statement)?
		public Group getGroup_2_0_2() { return cGroup_2_0_2; }

		//=> "else"
		public Keyword getElseKeyword_2_0_2_0() { return cElseKeyword_2_0_2_0; }

		//s2=Statement
		public Assignment getS2Assignment_2_0_2_1() { return cS2Assignment_2_0_2_1; }

		//Statement
		public RuleCall getS2StatementParserRuleCall_2_0_2_1_0() { return cS2StatementParserRuleCall_2_0_2_1_0; }

		//b?=LBRACE NL+ "then" s11=Statement NL* ("else" s12=Statement NL*)? RBRACE
		public Group getGroup_2_1() { return cGroup_2_1; }

		//b?=LBRACE
		public Assignment getBAssignment_2_1_0() { return cBAssignment_2_1_0; }

		//LBRACE
		public RuleCall getBLBRACETerminalRuleCall_2_1_0_0() { return cBLBRACETerminalRuleCall_2_1_0_0; }

		//NL+
		public RuleCall getNLTerminalRuleCall_2_1_1() { return cNLTerminalRuleCall_2_1_1; }

		//"then"
		public Keyword getThenKeyword_2_1_2() { return cThenKeyword_2_1_2; }

		//s11=Statement
		public Assignment getS11Assignment_2_1_3() { return cS11Assignment_2_1_3; }

		//Statement
		public RuleCall getS11StatementParserRuleCall_2_1_3_0() { return cS11StatementParserRuleCall_2_1_3_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_2_1_4() { return cNLTerminalRuleCall_2_1_4; }

		//(=> "else" s12=Statement NL*)?
		public Group getGroup_2_1_5() { return cGroup_2_1_5; }

		//=> "else"
		public Keyword getElseKeyword_2_1_5_0() { return cElseKeyword_2_1_5_0; }

		//s12=Statement
		public Assignment getS12Assignment_2_1_5_1() { return cS12Assignment_2_1_5_1; }

		//Statement
		public RuleCall getS12StatementParserRuleCall_2_1_5_1_0() { return cS12StatementParserRuleCall_2_1_5_1_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_2_1_5_2() { return cNLTerminalRuleCall_2_1_5_2; }

		//RBRACE
		public RuleCall getRBRACETerminalRuleCall_2_1_6() { return cRBRACETerminalRuleCall_2_1_6; }
	}

	public class IfElseStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfElseStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cElseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cS2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cS2StatementParserRuleCall_1_0 = (RuleCall)cS2Assignment_1.eContents().get(0);
		
		//IfElseStatement hidden(WS, SL_COMMENT):
		//	"else" s2=Statement;
		public ParserRule getRule() { return rule; }

		//"else" s2=Statement
		public Group getGroup() { return cGroup; }

		//"else"
		public Keyword getElseKeyword_0() { return cElseKeyword_0; }

		//s2=Statement
		public Assignment getS2Assignment_1() { return cS2Assignment_1; }

		//Statement
		public RuleCall getS2StatementParserRuleCall_1_0() { return cS2StatementParserRuleCall_1_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cIfnameAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Keyword cIfnameIfKeyword_0_0_0 = (Keyword)cIfnameAssignment_0_0.eContents().get(0);
		private final Assignment cIfpredAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cIfpredExpressionParserRuleCall_0_1_0 = (RuleCall)cIfpredAssignment_0_1.eContents().get(0);
		private final Keyword cThenKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cThenexpAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cThenexpExpressionParserRuleCall_0_3_0 = (RuleCall)cThenexpAssignment_0_3.eContents().get(0);
		private final Keyword cElseKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Assignment cElseexpAssignment_0_5 = (Assignment)cGroup_0.eContents().get(5);
		private final RuleCall cElseexpExpressionParserRuleCall_0_5_0 = (RuleCall)cElseexpAssignment_0_5.eContents().get(0);
		private final RuleCall cExitExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/////////////// Expression syntax follows //////////////
		/// * This is the top level for expressions
		// * 
		// * This level handles special cases such as:
		// * if x then y else z
		// * (x,y) +-> z
		// * 
		// * We can consider expressions as elements of statements 
		// * expressions contain no newlines unless preceded by underscore
		// * (which is handled by WS)
		// * / Expression returns Expr hidden(WS, SL_COMMENT):
		//	ifname="if" ifpred=Expression "then" thenexp=Expression "else" elseexp=Expression //  | LPAREN t24=ConditionExpression (COMMA t25+=ConditionExpression)+ RPAREN (COLON rightType2 =TypeExpression)? GIVES ConditionExpression
		//	| ExitExpression;
		public ParserRule getRule() { return rule; }

		//ifname="if" ifpred=Expression "then" thenexp=Expression "else" elseexp=Expression //  | LPAREN t24=ConditionExpression (COMMA t25+=ConditionExpression)+ RPAREN (COLON rightType2 =TypeExpression)? GIVES ConditionExpression
		//| ExitExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//ifname="if" ifpred=Expression "then" thenexp=Expression "else" elseexp=Expression
		public Group getGroup_0() { return cGroup_0; }

		//ifname="if"
		public Assignment getIfnameAssignment_0_0() { return cIfnameAssignment_0_0; }

		//"if"
		public Keyword getIfnameIfKeyword_0_0_0() { return cIfnameIfKeyword_0_0_0; }

		//ifpred=Expression
		public Assignment getIfpredAssignment_0_1() { return cIfpredAssignment_0_1; }

		//Expression
		public RuleCall getIfpredExpressionParserRuleCall_0_1_0() { return cIfpredExpressionParserRuleCall_0_1_0; }

		//"then"
		public Keyword getThenKeyword_0_2() { return cThenKeyword_0_2; }

		//thenexp=Expression
		public Assignment getThenexpAssignment_0_3() { return cThenexpAssignment_0_3; }

		//Expression
		public RuleCall getThenexpExpressionParserRuleCall_0_3_0() { return cThenexpExpressionParserRuleCall_0_3_0; }

		//"else"
		public Keyword getElseKeyword_0_4() { return cElseKeyword_0_4; }

		//elseexp=Expression
		public Assignment getElseexpAssignment_0_5() { return cElseexpAssignment_0_5; }

		//Expression
		public RuleCall getElseexpExpressionParserRuleCall_0_5_0() { return cElseexpExpressionParserRuleCall_0_5_0; }

		//ExitExpression
		public RuleCall getExitExpressionParserRuleCall_1() { return cExitExpressionParserRuleCall_1; }
	}

	public class ExitExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExitExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExitExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpEXITTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightConditionExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Assignment cR2Assignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cR2ConditionExpressionParserRuleCall_1_4_0 = (RuleCall)cR2Assignment_1_4.eContents().get(0);
		
		/// * 
		// * condition '=>' expr1 ';' expr2
		// * / ExitExpression returns Expr hidden(WS, SL_COMMENT):
		//	ConditionExpression ({ExitExpression.left=current} op=EXIT right=ConditionExpression SEMICOLON
		//	r2=ConditionExpression)*;
		public ParserRule getRule() { return rule; }

		//ConditionExpression ({ExitExpression.left=current} op=EXIT right=ConditionExpression SEMICOLON r2=ConditionExpression)*
		public Group getGroup() { return cGroup; }

		//ConditionExpression
		public RuleCall getConditionExpressionParserRuleCall_0() { return cConditionExpressionParserRuleCall_0; }

		//({ExitExpression.left=current} op=EXIT right=ConditionExpression SEMICOLON r2=ConditionExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ExitExpression.left=current}
		public Action getExitExpressionLeftAction_1_0() { return cExitExpressionLeftAction_1_0; }

		//op=EXIT
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//EXIT
		public RuleCall getOpEXITTerminalRuleCall_1_1_0() { return cOpEXITTerminalRuleCall_1_1_0; }

		//right=ConditionExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ConditionExpression
		public RuleCall getRightConditionExpressionParserRuleCall_1_2_0() { return cRightConditionExpressionParserRuleCall_1_2_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_1_3() { return cSEMICOLONTerminalRuleCall_1_3; }

		//r2=ConditionExpression
		public Assignment getR2Assignment_1_4() { return cR2Assignment_1_4; }

		//ConditionExpression
		public RuleCall getR2ConditionExpressionParserRuleCall_1_4_0() { return cR2ConditionExpressionParserRuleCall_1_4_0; }
	}

	public class ConditionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConditionExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpBARTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// * BAR "|" precedence: 108, 111
		// * / ConditionExpression returns Expr hidden(WS, SL_COMMENT):
		//	OrExpression ({ConditionExpression.left=current} op=BAR right=OrExpression)*;
		public ParserRule getRule() { return rule; }

		//OrExpression ({ConditionExpression.left=current} op=BAR right=OrExpression)*
		public Group getGroup() { return cGroup; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }

		//({ConditionExpression.left=current} op=BAR right=OrExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ConditionExpression.left=current}
		public Action getConditionExpressionLeftAction_1_0() { return cConditionExpressionLeftAction_1_0; }

		//op=BAR
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//BAR
		public RuleCall getOpBARTerminalRuleCall_1_1_0() { return cOpBARTerminalRuleCall_1_1_0; }

		//right=OrExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//OrExpression
		public RuleCall getRightOrExpressionParserRuleCall_1_2_0() { return cRightOrExpressionParserRuleCall_1_2_0; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpOrKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// * COMMA"," precedence: 110, 111
		// * / //CommaExpression returns Expr hidden(WS,SL_COMMENT):
		////  ConditionalAndExpression
		////  ({ConditionExpression.left=current} op=BAR right = ConditionalAndExpression )*
		////;
		/// *
		// * There is also another rule that looks for 'or' which is PredicateOr,
		// * this version is used in a general expression and the other version is
		// * used when we know we have a predicate.
		// * "or", precedence: 200, 201
		// * / OrExpression returns Expr hidden(WS, SL_COMMENT):
		//	AndExpression ({OrExpression.left=current} op="or" right=AndExpression)*;
		public ParserRule getRule() { return rule; }

		//AndExpression ({OrExpression.left=current} op="or" right=AndExpression)*
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({OrExpression.left=current} op="or" right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{OrExpression.left=current}
		public Action getOrExpressionLeftAction_1_0() { return cOrExpressionLeftAction_1_0; }

		//op="or"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"or"
		public Keyword getOpOrKeyword_1_1_0() { return cOpOrKeyword_1_1_0; }

		//right=AndExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_2_0() { return cRightAndExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInnerProdExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpAndKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightInnerProdExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * There is also another rule that looks for 'and' which is PredicateAnd,
		// * this version is used in a general expression and the other version is
		// * used when we know we have a predicate.
		// * "and", precedence: 250, 251
		// * / AndExpression returns Expr hidden(WS, SL_COMMENT):
		//	InnerProdExpression ({AndExpression.left=current} op="and" right=InnerProdExpression)*;
		public ParserRule getRule() { return rule; }

		//InnerProdExpression ({AndExpression.left=current} op="and" right=InnerProdExpression)*
		public Group getGroup() { return cGroup; }

		//InnerProdExpression
		public RuleCall getInnerProdExpressionParserRuleCall_0() { return cInnerProdExpressionParserRuleCall_0; }

		//({AndExpression.left=current} op="and" right=InnerProdExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{AndExpression.left=current}
		public Action getAndExpressionLeftAction_1_0() { return cAndExpressionLeftAction_1_0; }

		//op="and"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"and"
		public Keyword getOpAndKeyword_1_1_0() { return cOpAndKeyword_1_1_0; }

		//right=InnerProdExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//InnerProdExpression
		public RuleCall getRightInnerProdExpressionParserRuleCall_1_2_0() { return cRightInnerProdExpressionParserRuleCall_1_2_0; }
	}

	public class InnerProdExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InnerProdExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOuterProdExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInnerProdExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpBACKSLASHSLASHTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOuterProdExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * This has multiple uses such as inner product and logical or.
		// * 
		// * "\/", BACKSLASHSLASH precedence: 200, 201
		// * 
		// * the backslash is duplicated here because it is the escape character for
		// * strings, it will not be duplicated when used. 
		// * / InnerProdExpression returns Expr hidden(WS, SL_COMMENT):
		//	OuterProdExpression ({InnerProdExpression.left=current} op=BACKSLASHSLASH right=OuterProdExpression)*;
		public ParserRule getRule() { return rule; }

		//OuterProdExpression ({InnerProdExpression.left=current} op=BACKSLASHSLASH right=OuterProdExpression)*
		public Group getGroup() { return cGroup; }

		//OuterProdExpression
		public RuleCall getOuterProdExpressionParserRuleCall_0() { return cOuterProdExpressionParserRuleCall_0; }

		//({InnerProdExpression.left=current} op=BACKSLASHSLASH right=OuterProdExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{InnerProdExpression.left=current}
		public Action getInnerProdExpressionLeftAction_1_0() { return cInnerProdExpressionLeftAction_1_0; }

		//op=BACKSLASHSLASH
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//BACKSLASHSLASH
		public RuleCall getOpBACKSLASHSLASHTerminalRuleCall_1_1_0() { return cOpBACKSLASHSLASHTerminalRuleCall_1_1_0; }

		//right=OuterProdExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//OuterProdExpression
		public RuleCall getRightOuterProdExpressionParserRuleCall_1_2_0() { return cRightOuterProdExpressionParserRuleCall_1_2_0; }
	}

	public class OuterProdExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OuterProdExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cHasExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOuterProdExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpSLASHBACKSLASHTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightHasExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * This has multiple uses such as outer product and logical and.
		// * 
		// * "/\", SLASHBACKSLASH precedence: 250, 251
		// * 
		// * the backslash is duplicated here because it is the escape character for
		// * strings, it will not be duplicated when used. 
		// * / OuterProdExpression returns Expr hidden(WS, SL_COMMENT):
		//	HasExpression ({OuterProdExpression.left=current} op=SLASHBACKSLASH right=HasExpression)*;
		public ParserRule getRule() { return rule; }

		//HasExpression ({OuterProdExpression.left=current} op=SLASHBACKSLASH right=HasExpression)*
		public Group getGroup() { return cGroup; }

		//HasExpression
		public RuleCall getHasExpressionParserRuleCall_0() { return cHasExpressionParserRuleCall_0; }

		//({OuterProdExpression.left=current} op=SLASHBACKSLASH right=HasExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{OuterProdExpression.left=current}
		public Action getOuterProdExpressionLeftAction_1_0() { return cOuterProdExpressionLeftAction_1_0; }

		//op=SLASHBACKSLASH
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//SLASHBACKSLASH
		public RuleCall getOpSLASHBACKSLASHTerminalRuleCall_1_1_0() { return cOpSLASHBACKSLASHTerminalRuleCall_1_1_0; }

		//right=HasExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//HasExpression
		public RuleCall getRightHasExpressionParserRuleCall_1_2_0() { return cRightHasExpressionParserRuleCall_1_2_0; }
	}

	public class HasExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HasExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCaseExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cHasExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpHasKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		/// * Predicate which returns true if preceding value is of a given type
		// * example:
		// * if R has Field then ..
		// * 
		// * "has", precedence: 400, 400
		// * / HasExpression returns Expr hidden(WS, SL_COMMENT):
		//	CaseExpression ({HasExpression.left=current} op="has" rightType=TypeExpression)*;
		public ParserRule getRule() { return rule; }

		//CaseExpression ({HasExpression.left=current} op="has" rightType=TypeExpression)*
		public Group getGroup() { return cGroup; }

		//CaseExpression
		public RuleCall getCaseExpressionParserRuleCall_0() { return cCaseExpressionParserRuleCall_0; }

		//({HasExpression.left=current} op="has" rightType=TypeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{HasExpression.left=current}
		public Action getHasExpressionLeftAction_1_0() { return cHasExpressionLeftAction_1_0; }

		//op="has"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"has"
		public Keyword getOpHasKeyword_1_1_0() { return cOpHasKeyword_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class CaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CaseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCaseExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpCaseKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEqualityExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * Select from Union values 
		// * example:
		// * if myUnion case mtType then ... 	
		// * 
		// * "case", precedence: 400, 400
		// * / CaseExpression returns Expr hidden(WS, SL_COMMENT):
		//	EqualityExpression ({CaseExpression.left=current} op="case" right=EqualityExpression)?;
		public ParserRule getRule() { return rule; }

		//EqualityExpression ({CaseExpression.left=current} op="case" right=EqualityExpression)?
		public Group getGroup() { return cGroup; }

		//EqualityExpression
		public RuleCall getEqualityExpressionParserRuleCall_0() { return cEqualityExpressionParserRuleCall_0; }

		//({CaseExpression.left=current} op="case" right=EqualityExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{CaseExpression.left=current}
		public Action getCaseExpressionLeftAction_1_0() { return cCaseExpressionLeftAction_1_0; }

		//op="case"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"case"
		public Keyword getOpCaseKeyword_1_1_0() { return cOpCaseKeyword_1_1_0; }

		//right=EqualityExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//EqualityExpression
		public RuleCall getRightEqualityExpressionParserRuleCall_1_2_0() { return cRightEqualityExpressionParserRuleCall_1_2_0; }
	}

	public class EqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cOpEQUALTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpNOTEQUALTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1_2 = (Assignment)cAlternatives_1_1.eContents().get(2);
		private final Keyword cOpCircumflexAccentEqualsSignKeyword_1_1_2_0 = (Keyword)cOpAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final RuleCall cDOLARTerminalRuleCall_1_2_0 = (RuleCall)cGroup_1_2.eContents().get(0);
		private final Assignment cTeAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cTeIDTerminalRuleCall_1_2_1_0 = (RuleCall)cTeAssignment_1_2_1.eContents().get(0);
		private final Assignment cRightAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cRightRelationalExpressionParserRuleCall_1_3_0 = (RuleCall)cRightAssignment_1_3.eContents().get(0);
		
		/// * used in list comprehension
		// * 
		// * "in", precedence: 400, 400
		// * / / *InExpression returns Expr hidden(WS,SL_COMMENT):
		//  RelationalExpression
		//  ( {CaseExpression.left=current} op='in' right = RelationalExpression)?
		//;* / / * 
		// * "~=", precedence: 400, 400
		// * "^=", precedence: 400, 400
		// * "=", precedence: 400, 400
		// * / EqualityExpression returns Expr hidden(WS, SL_COMMENT):
		//	RelationalExpression // ambiguous because EQ can be in top level expression
		//	({EqualityExpression.left=current} (op=EQUAL | op=NOTEQUAL | op="^=") (DOLAR te=ID)? right=RelationalExpression)*;
		public ParserRule getRule() { return rule; }

		//RelationalExpression // ambiguous because EQ can be in top level expression
		//({EqualityExpression.left=current} (op=EQUAL | op=NOTEQUAL | op="^=") (DOLAR te=ID)? right=RelationalExpression)*
		public Group getGroup() { return cGroup; }

		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }

		//({EqualityExpression.left=current} (op=EQUAL | op=NOTEQUAL | op="^=") (DOLAR te=ID)? right=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{EqualityExpression.left=current}
		public Action getEqualityExpressionLeftAction_1_0() { return cEqualityExpressionLeftAction_1_0; }

		//op=EQUAL | op=NOTEQUAL | op="^="
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op=EQUAL
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//EQUAL
		public RuleCall getOpEQUALTerminalRuleCall_1_1_0_0() { return cOpEQUALTerminalRuleCall_1_1_0_0; }

		//op=NOTEQUAL
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//NOTEQUAL
		public RuleCall getOpNOTEQUALTerminalRuleCall_1_1_1_0() { return cOpNOTEQUALTerminalRuleCall_1_1_1_0; }

		//op="^="
		public Assignment getOpAssignment_1_1_2() { return cOpAssignment_1_1_2; }

		//"^="
		public Keyword getOpCircumflexAccentEqualsSignKeyword_1_1_2_0() { return cOpCircumflexAccentEqualsSignKeyword_1_1_2_0; }

		//(DOLAR te=ID)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//DOLAR
		public RuleCall getDOLARTerminalRuleCall_1_2_0() { return cDOLARTerminalRuleCall_1_2_0; }

		//te=ID
		public Assignment getTeAssignment_1_2_1() { return cTeAssignment_1_2_1; }

		//ID
		public RuleCall getTeIDTerminalRuleCall_1_2_1_0() { return cTeIDTerminalRuleCall_1_2_1_0; }

		//right=RelationalExpression
		public Assignment getRightAssignment_1_3() { return cRightAssignment_1_3; }

		//RelationalExpression
		public RuleCall getRightRelationalExpressionParserRuleCall_1_3_0() { return cRightRelationalExpressionParserRuleCall_1_3_0; }
	}

	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIsExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelationalExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cOpLTTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpGTTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1_2 = (Assignment)cAlternatives_1_1.eContents().get(2);
		private final RuleCall cOpLETerminalRuleCall_1_1_2_0 = (RuleCall)cOpAssignment_1_1_2.eContents().get(0);
		private final Assignment cOpAssignment_1_1_3 = (Assignment)cAlternatives_1_1.eContents().get(3);
		private final RuleCall cOpGETerminalRuleCall_1_1_3_0 = (RuleCall)cOpAssignment_1_1_3.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightIsExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// * ">=", precedence: 400, 400
		// * "<=", precedence: 400, 400
		// * ">>", precedence: 400, 400
		// * "<<", precedence: 400, 400
		// * ">", precedence: 400, 400
		// * "<", precedence: 400, 400
		// * / RelationalExpression returns Expr hidden(WS, SL_COMMENT):
		//	IsExpression ({RelationalExpression.left=current} (op=LT | op=GT | op=LE | op=GE) right=IsExpression)?;
		public ParserRule getRule() { return rule; }

		//IsExpression ({RelationalExpression.left=current} (op=LT | op=GT | op=LE | op=GE) right=IsExpression)?
		public Group getGroup() { return cGroup; }

		//IsExpression
		public RuleCall getIsExpressionParserRuleCall_0() { return cIsExpressionParserRuleCall_0; }

		//({RelationalExpression.left=current} (op=LT | op=GT | op=LE | op=GE) right=IsExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{RelationalExpression.left=current}
		public Action getRelationalExpressionLeftAction_1_0() { return cRelationalExpressionLeftAction_1_0; }

		//op=LT | op=GT | op=LE | op=GE
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op=LT
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//LT
		public RuleCall getOpLTTerminalRuleCall_1_1_0_0() { return cOpLTTerminalRuleCall_1_1_0_0; }

		//op=GT
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//GT
		public RuleCall getOpGTTerminalRuleCall_1_1_1_0() { return cOpGTTerminalRuleCall_1_1_1_0; }

		//op=LE
		public Assignment getOpAssignment_1_1_2() { return cOpAssignment_1_1_2; }

		//LE
		public RuleCall getOpLETerminalRuleCall_1_1_2_0() { return cOpLETerminalRuleCall_1_1_2_0; }

		//op=GE
		public Assignment getOpAssignment_1_1_3() { return cOpAssignment_1_1_3; }

		//GE
		public RuleCall getOpGETerminalRuleCall_1_1_3_0() { return cOpGETerminalRuleCall_1_1_3_0; }

		//right=IsExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//IsExpression
		public RuleCall getRightIsExpressionParserRuleCall_1_2_0() { return cRightIsExpressionParserRuleCall_1_2_0; }
	}

	public class IsExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IsExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSegmentExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIsExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final Keyword cOpIsKeyword_1_1_0_0 = (Keyword)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final Keyword cOpIsntKeyword_1_1_1_0 = (Keyword)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		/// * 
		// * 
		// * "isnt", precedence: 400, 400
		// * "is", precedence: 400, 400
		// * / IsExpression returns Expr hidden(WS, SL_COMMENT):
		//	SegmentExpression ({IsExpression.left=current} (op="is" | op="isnt") rightType=TypeExpression)*;
		public ParserRule getRule() { return rule; }

		//SegmentExpression ({IsExpression.left=current} (op="is" | op="isnt") rightType=TypeExpression)*
		public Group getGroup() { return cGroup; }

		//SegmentExpression
		public RuleCall getSegmentExpressionParserRuleCall_0() { return cSegmentExpressionParserRuleCall_0; }

		//({IsExpression.left=current} (op="is" | op="isnt") rightType=TypeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{IsExpression.left=current}
		public Action getIsExpressionLeftAction_1_0() { return cIsExpressionLeftAction_1_0; }

		//op="is" | op="isnt"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op="is"
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//"is"
		public Keyword getOpIsKeyword_1_1_0_0() { return cOpIsKeyword_1_1_0_0; }

		//op="isnt"
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//"isnt"
		public Keyword getOpIsntKeyword_1_1_1_0() { return cOpIsntKeyword_1_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class SegmentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SegmentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSegmentExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpSEGTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditiveExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// * this is used to indicate a range:
		// * 1..4 means the range from 1 to 4
		// * 1.. means the range from 1 to infinity. This is used in cases where
		// * no top bounds is necessary, when the end point is determined by other
		// * means.
		// * "..", "SEGMENT",  precedence: 401, 699, ["parse_Seg"]
		// * / SegmentExpression returns Expr hidden(WS, SL_COMMENT):
		//	AdditiveExpression ({SegmentExpression.left=current} op=SEG right=AdditiveExpression)*;
		public ParserRule getRule() { return rule; }

		//AdditiveExpression ({SegmentExpression.left=current} op=SEG right=AdditiveExpression)*
		public Group getGroup() { return cGroup; }

		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//({SegmentExpression.left=current} op=SEG right=AdditiveExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{SegmentExpression.left=current}
		public Action getSegmentExpressionLeftAction_1_0() { return cSegmentExpressionLeftAction_1_0; }

		//op=SEG
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//SEG
		public RuleCall getOpSEGTerminalRuleCall_1_1_0() { return cOpSEGTerminalRuleCall_1_1_0; }

		//right=AdditiveExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AdditiveExpression
		public RuleCall getRightAdditiveExpressionParserRuleCall_1_2_0() { return cRightAdditiveExpressionParserRuleCall_1_2_0; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExquoExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditiveExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cOpPLUSTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpMINUSTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExquoExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * add expression
		// * we include both '+' and '-' in the same case as this allows a
		// * multiple sequence like:
		// * a + b + c - d + e -f
		// * 
		// * "-",  precedence: 700, 701
		// * "+",  precedence: 700, 701
		// * / AdditiveExpression returns Expr hidden(WS, SL_COMMENT):
		//	ExquoExpression ({AdditiveExpression.left=current} (op=PLUS | op=MINUS) right=ExquoExpression)*;
		public ParserRule getRule() { return rule; }

		//ExquoExpression ({AdditiveExpression.left=current} (op=PLUS | op=MINUS) right=ExquoExpression)*
		public Group getGroup() { return cGroup; }

		//ExquoExpression
		public RuleCall getExquoExpressionParserRuleCall_0() { return cExquoExpressionParserRuleCall_0; }

		//({AdditiveExpression.left=current} (op=PLUS | op=MINUS) right=ExquoExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{AdditiveExpression.left=current}
		public Action getAdditiveExpressionLeftAction_1_0() { return cAdditiveExpressionLeftAction_1_0; }

		//op=PLUS | op=MINUS
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op=PLUS
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//PLUS
		public RuleCall getOpPLUSTerminalRuleCall_1_1_0_0() { return cOpPLUSTerminalRuleCall_1_1_0_0; }

		//op=MINUS
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//MINUS
		public RuleCall getOpMINUSTerminalRuleCall_1_1_1_0() { return cOpMINUSTerminalRuleCall_1_1_1_0; }

		//right=ExquoExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ExquoExpression
		public RuleCall getRightExquoExpressionParserRuleCall_1_2_0() { return cRightExquoExpressionParserRuleCall_1_2_0; }
	}

	public class ExquoExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExquoExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDivisionExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExquoExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpExquoKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightDivisionExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// * "exquo",  precedence: 800, 801
		// * / ExquoExpression returns Expr hidden(WS, SL_COMMENT):
		//	DivisionExpression ({ExquoExpression.left=current} op="exquo" right=DivisionExpression)*;
		public ParserRule getRule() { return rule; }

		//DivisionExpression ({ExquoExpression.left=current} op="exquo" right=DivisionExpression)*
		public Group getGroup() { return cGroup; }

		//DivisionExpression
		public RuleCall getDivisionExpressionParserRuleCall_0() { return cDivisionExpressionParserRuleCall_0; }

		//({ExquoExpression.left=current} op="exquo" right=DivisionExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ExquoExpression.left=current}
		public Action getExquoExpressionLeftAction_1_0() { return cExquoExpressionLeftAction_1_0; }

		//op="exquo"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"exquo"
		public Keyword getOpExquoKeyword_1_1_0() { return cOpExquoKeyword_1_1_0; }

		//right=DivisionExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//DivisionExpression
		public RuleCall getRightDivisionExpressionParserRuleCall_1_2_0() { return cRightDivisionExpressionParserRuleCall_1_2_0; }
	}

	public class DivisionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DivisionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQuoExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDivisionExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpSLASHTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightQuoExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * division expression
		// * "/",  precedence: 800, 801
		// * / DivisionExpression returns Expr hidden(WS, SL_COMMENT):
		//	QuoExpression ({DivisionExpression.left=current} op=SLASH right=QuoExpression)*;
		public ParserRule getRule() { return rule; }

		//QuoExpression ({DivisionExpression.left=current} op=SLASH right=QuoExpression)*
		public Group getGroup() { return cGroup; }

		//QuoExpression
		public RuleCall getQuoExpressionParserRuleCall_0() { return cQuoExpressionParserRuleCall_0; }

		//({DivisionExpression.left=current} op=SLASH right=QuoExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{DivisionExpression.left=current}
		public Action getDivisionExpressionLeftAction_1_0() { return cDivisionExpressionLeftAction_1_0; }

		//op=SLASH
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//SLASH
		public RuleCall getOpSLASHTerminalRuleCall_1_1_0() { return cOpSLASHTerminalRuleCall_1_1_0; }

		//right=QuoExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//QuoExpression
		public RuleCall getRightQuoExpressionParserRuleCall_1_2_0() { return cRightQuoExpressionParserRuleCall_1_2_0; }
	}

	public class QuoExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuoExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cModExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cQuoExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpQuoKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightModExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// *"quo",  precedence: 800, 801
		// * / QuoExpression returns Expr hidden(WS, SL_COMMENT):
		//	ModExpression ({QuoExpression.left=current} op="quo" right=ModExpression)*;
		public ParserRule getRule() { return rule; }

		//ModExpression ({QuoExpression.left=current} op="quo" right=ModExpression)*
		public Group getGroup() { return cGroup; }

		//ModExpression
		public RuleCall getModExpressionParserRuleCall_0() { return cModExpressionParserRuleCall_0; }

		//({QuoExpression.left=current} op="quo" right=ModExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{QuoExpression.left=current}
		public Action getQuoExpressionLeftAction_1_0() { return cQuoExpressionLeftAction_1_0; }

		//op="quo"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"quo"
		public Keyword getOpQuoKeyword_1_1_0() { return cOpQuoKeyword_1_1_0; }

		//right=ModExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ModExpression
		public RuleCall getRightModExpressionParserRuleCall_1_2_0() { return cRightModExpressionParserRuleCall_1_2_0; }
	}

	public class ModExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRemExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cModExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpModKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRemExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// *"mod",  precedence: 800, 801
		// * / ModExpression returns Expr hidden(WS, SL_COMMENT):
		//	RemExpression ({ModExpression.left=current} op="mod" right=RemExpression)*;
		public ParserRule getRule() { return rule; }

		//RemExpression ({ModExpression.left=current} op="mod" right=RemExpression)*
		public Group getGroup() { return cGroup; }

		//RemExpression
		public RuleCall getRemExpressionParserRuleCall_0() { return cRemExpressionParserRuleCall_0; }

		//({ModExpression.left=current} op="mod" right=RemExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ModExpression.left=current}
		public Action getModExpressionLeftAction_1_0() { return cModExpressionLeftAction_1_0; }

		//op="mod"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"mod"
		public Keyword getOpModKeyword_1_1_0() { return cOpModKeyword_1_1_0; }

		//right=RemExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//RemExpression
		public RuleCall getRightRemExpressionParserRuleCall_1_2_0() { return cRightRemExpressionParserRuleCall_1_2_0; }
	}

	public class RemExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RemExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRemExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpRemKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// *"rem", precedence: 800, 801
		// * / RemExpression returns Expr hidden(WS, SL_COMMENT):
		//	MultiplicativeExpression ({RemExpression.left=current} op="rem" right=MultiplicativeExpression)*;
		public ParserRule getRule() { return rule; }

		//MultiplicativeExpression ({RemExpression.left=current} op="rem" right=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }

		//({RemExpression.left=current} op="rem" right=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{RemExpression.left=current}
		public Action getRemExpressionLeftAction_1_0() { return cRemExpressionLeftAction_1_0; }

		//op="rem"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"rem"
		public Keyword getOpRemKeyword_1_1_0() { return cOpRemKeyword_1_1_0; }

		//right=MultiplicativeExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//MultiplicativeExpression
		public RuleCall getRightMultiplicativeExpressionParserRuleCall_1_2_0() { return cRightMultiplicativeExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExponentExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicativeExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpTIMESTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExponentExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		// * multiplication expression
		// * a * b * c
		// * 
		// * "*", precedence: 800, 801
		// * / MultiplicativeExpression returns Expr hidden(WS, SL_COMMENT):
		//	ExponentExpression ({MultiplicativeExpression.left=current} op=TIMES right=ExponentExpression)*;
		public ParserRule getRule() { return rule; }

		//ExponentExpression ({MultiplicativeExpression.left=current} op=TIMES right=ExponentExpression)*
		public Group getGroup() { return cGroup; }

		//ExponentExpression
		public RuleCall getExponentExpressionParserRuleCall_0() { return cExponentExpressionParserRuleCall_0; }

		//({MultiplicativeExpression.left=current} op=TIMES right=ExponentExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{MultiplicativeExpression.left=current}
		public Action getMultiplicativeExpressionLeftAction_1_0() { return cMultiplicativeExpressionLeftAction_1_0; }

		//op=TIMES
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//TIMES
		public RuleCall getOpTIMESTerminalRuleCall_1_1_0() { return cOpTIMESTerminalRuleCall_1_1_0; }

		//right=ExponentExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ExponentExpression
		public RuleCall getRightExponentExpressionParserRuleCall_1_2_0() { return cRightExponentExpressionParserRuleCall_1_2_0; }
	}

	public class ExponentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExponentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMapDefinitionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExponentExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cOpAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cOpCARATTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAssignment_1_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cOpPOWERTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMapDefinitionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * 
		// *
		// * "^", precedence: 901, 900
		// * "**", precedence: 901, 900
		// * / ExponentExpression returns Expr hidden(WS, SL_COMMENT):
		//	MapDefinition ({ExponentExpression.left=current} (op=CARAT | op=POWER) right=MapDefinition)*;
		public ParserRule getRule() { return rule; }

		//MapDefinition ({ExponentExpression.left=current} (op=CARAT | op=POWER) right=MapDefinition)*
		public Group getGroup() { return cGroup; }

		//MapDefinition
		public RuleCall getMapDefinitionParserRuleCall_0() { return cMapDefinitionParserRuleCall_0; }

		//({ExponentExpression.left=current} (op=CARAT | op=POWER) right=MapDefinition)*
		public Group getGroup_1() { return cGroup_1; }

		//{ExponentExpression.left=current}
		public Action getExponentExpressionLeftAction_1_0() { return cExponentExpressionLeftAction_1_0; }

		//op=CARAT | op=POWER
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//op=CARAT
		public Assignment getOpAssignment_1_1_0() { return cOpAssignment_1_1_0; }

		//CARAT
		public RuleCall getOpCARATTerminalRuleCall_1_1_0_0() { return cOpCARATTerminalRuleCall_1_1_0_0; }

		//op=POWER
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//POWER
		public RuleCall getOpPOWERTerminalRuleCall_1_1_1_0() { return cOpPOWERTerminalRuleCall_1_1_1_0; }

		//right=MapDefinition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//MapDefinition
		public RuleCall getRightMapDefinitionParserRuleCall_1_2_0() { return cRightMapDefinitionParserRuleCall_1_2_0; }
	}

	public class MapDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MapDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAssignExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMapDefinitionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpGIVESTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAssignExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * Map or Lambda expression
		// * var +-> function 	
		// * 
		// * +-> is an infix operator meaning 'maps-to'
		// * It can be used to create a function literal (an anonymous function), so
		// * instead of:
		// * myFunct(x:Type):Type == if x >0 then x else -x
		// * we can have forms such as:
		// * x +-> if x >0 then x else -x
		// * or:
		// * (x,y) +-> if x >0 then y else -x
		// * 
		// * fricas compatibility:
		// * "+->", precedence: 995, 112
		// * / MapDefinition returns Expr hidden(WS, SL_COMMENT): //  (PretendExpression | LPAREN PretendExpression (COMMA t25+=PretendExpression)+ RPAREN) (COLON rightType2 =TypeExpression)?
		//	AssignExpression ({MapDefinition.left=current} op=GIVES right=AssignExpression)*;
		public ParserRule getRule() { return rule; }

		////  (PretendExpression | LPAREN PretendExpression (COMMA t25+=PretendExpression)+ RPAREN) (COLON rightType2 =TypeExpression)?
		//AssignExpression ({MapDefinition.left=current} op=GIVES right=AssignExpression)*
		public Group getGroup() { return cGroup; }

		////  (PretendExpression | LPAREN PretendExpression (COMMA t25+=PretendExpression)+ RPAREN) (COLON rightType2 =TypeExpression)?
		//AssignExpression
		public RuleCall getAssignExpressionParserRuleCall_0() { return cAssignExpressionParserRuleCall_0; }

		//({MapDefinition.left=current} op=GIVES right=AssignExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{MapDefinition.left=current}
		public Action getMapDefinitionLeftAction_1_0() { return cMapDefinitionLeftAction_1_0; }

		//op=GIVES
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//GIVES
		public RuleCall getOpGIVESTerminalRuleCall_1_1_0() { return cOpGIVESTerminalRuleCall_1_1_0; }

		//right=AssignExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AssignExpression
		public RuleCall getRightAssignExpressionParserRuleCall_1_2_0() { return cRightAssignExpressionParserRuleCall_1_2_0; }
	}

	public class AssignExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPretendExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAssignExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpBECOMESTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Alternatives cAlternatives_1_2 = (Alternatives)cGroup_1.eContents().get(2);
		private final Assignment cRightAssignment_1_2_0 = (Assignment)cAlternatives_1_2.eContents().get(0);
		private final RuleCall cRightPretendExpressionParserRuleCall_1_2_0_0 = (RuleCall)cRightAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cAlternatives_1_2.eContents().get(1);
		private final Assignment cIfnameAssignment_1_2_1_0 = (Assignment)cGroup_1_2_1.eContents().get(0);
		private final Keyword cIfnameIfKeyword_1_2_1_0_0 = (Keyword)cIfnameAssignment_1_2_1_0.eContents().get(0);
		private final Assignment cIfpredAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cIfpredConditionExpressionParserRuleCall_1_2_1_1_0 = (RuleCall)cIfpredAssignment_1_2_1_1.eContents().get(0);
		private final Keyword cThenKeyword_1_2_1_2 = (Keyword)cGroup_1_2_1.eContents().get(2);
		private final Assignment cThenexpAssignment_1_2_1_3 = (Assignment)cGroup_1_2_1.eContents().get(3);
		private final RuleCall cThenexpConditionExpressionParserRuleCall_1_2_1_3_0 = (RuleCall)cThenexpAssignment_1_2_1_3.eContents().get(0);
		private final Keyword cElseKeyword_1_2_1_4 = (Keyword)cGroup_1_2_1.eContents().get(4);
		private final Assignment cElseexpAssignment_1_2_1_5 = (Assignment)cGroup_1_2_1.eContents().get(5);
		private final RuleCall cElseexpPretendExpressionParserRuleCall_1_2_1_5_0 = (RuleCall)cElseexpAssignment_1_2_1_5.eContents().get(0);
		
		/// *
		// * an assign expression like this:
		// * x := y
		// * can also be an inner assign like this:
		// * x := (y := z)
		// * or just:
		// *  x := y := z
		// * 
		// * right is expression to allow forms like
		// * x := if y<0 then -y else y
		// * / AssignExpression returns Expr hidden(WS, SL_COMMENT):
		//	PretendExpression ({AssignExpression.left=current} op=BECOMES (right=PretendExpression | ifname="if"
		//	ifpred=ConditionExpression "then" thenexp=ConditionExpression "else" elseexp=PretendExpression))*;
		public ParserRule getRule() { return rule; }

		//PretendExpression ({AssignExpression.left=current} op=BECOMES (right=PretendExpression | ifname="if"
		//ifpred=ConditionExpression "then" thenexp=ConditionExpression "else" elseexp=PretendExpression))*
		public Group getGroup() { return cGroup; }

		//PretendExpression
		public RuleCall getPretendExpressionParserRuleCall_0() { return cPretendExpressionParserRuleCall_0; }

		//({AssignExpression.left=current} op=BECOMES (right=PretendExpression | ifname="if" ifpred=ConditionExpression "then"
		//thenexp=ConditionExpression "else" elseexp=PretendExpression))*
		public Group getGroup_1() { return cGroup_1; }

		//{AssignExpression.left=current}
		public Action getAssignExpressionLeftAction_1_0() { return cAssignExpressionLeftAction_1_0; }

		//op=BECOMES
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//BECOMES
		public RuleCall getOpBECOMESTerminalRuleCall_1_1_0() { return cOpBECOMESTerminalRuleCall_1_1_0; }

		//right=PretendExpression | ifname="if" ifpred=ConditionExpression "then" thenexp=ConditionExpression "else"
		//elseexp=PretendExpression
		public Alternatives getAlternatives_1_2() { return cAlternatives_1_2; }

		//right=PretendExpression
		public Assignment getRightAssignment_1_2_0() { return cRightAssignment_1_2_0; }

		//PretendExpression
		public RuleCall getRightPretendExpressionParserRuleCall_1_2_0_0() { return cRightPretendExpressionParserRuleCall_1_2_0_0; }

		//ifname="if" ifpred=ConditionExpression "then" thenexp=ConditionExpression "else" elseexp=PretendExpression
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//ifname="if"
		public Assignment getIfnameAssignment_1_2_1_0() { return cIfnameAssignment_1_2_1_0; }

		//"if"
		public Keyword getIfnameIfKeyword_1_2_1_0_0() { return cIfnameIfKeyword_1_2_1_0_0; }

		//ifpred=ConditionExpression
		public Assignment getIfpredAssignment_1_2_1_1() { return cIfpredAssignment_1_2_1_1; }

		//ConditionExpression
		public RuleCall getIfpredConditionExpressionParserRuleCall_1_2_1_1_0() { return cIfpredConditionExpressionParserRuleCall_1_2_1_1_0; }

		//"then"
		public Keyword getThenKeyword_1_2_1_2() { return cThenKeyword_1_2_1_2; }

		//thenexp=ConditionExpression
		public Assignment getThenexpAssignment_1_2_1_3() { return cThenexpAssignment_1_2_1_3; }

		//ConditionExpression
		public RuleCall getThenexpConditionExpressionParserRuleCall_1_2_1_3_0() { return cThenexpConditionExpressionParserRuleCall_1_2_1_3_0; }

		//"else"
		public Keyword getElseKeyword_1_2_1_4() { return cElseKeyword_1_2_1_4; }

		//elseexp=PretendExpression
		public Assignment getElseexpAssignment_1_2_1_5() { return cElseexpAssignment_1_2_1_5; }

		//PretendExpression
		public RuleCall getElseexpPretendExpressionParserRuleCall_1_2_1_5_0() { return cElseexpPretendExpressionParserRuleCall_1_2_1_5_0; }
	}

	public class PretendExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PretendExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCoerceExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPretendExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpPretendKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		/// *
		// * pretend Type: treat one type as another,
		// * only works if they have the same internal structure.
		// * 
		// * Not very safe and should be avoided, if possible, unfortunately
		// * its not always possible to avoid.
		// * 
		// * "pretend", precedence: 995, 996
		// * / PretendExpression returns Expr hidden(WS, SL_COMMENT):
		//	CoerceExpression ({PretendExpression.left=current} op="pretend" rightType=TypeExpression)*;
		public ParserRule getRule() { return rule; }

		//CoerceExpression ({PretendExpression.left=current} op="pretend" rightType=TypeExpression)*
		public Group getGroup() { return cGroup; }

		//CoerceExpression
		public RuleCall getCoerceExpressionParserRuleCall_0() { return cCoerceExpressionParserRuleCall_0; }

		//({PretendExpression.left=current} op="pretend" rightType=TypeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{PretendExpression.left=current}
		public Action getPretendExpressionLeftAction_1_0() { return cPretendExpressionLeftAction_1_0; }

		//op="pretend"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"pretend"
		public Keyword getOpPretendKeyword_1_1_0() { return cOpPretendKeyword_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class CoerceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CoerceExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cHintTypeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCoerceExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpCOERCETerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		/// * 
		// * "::", precedence: 996, 997
		// * 
		// * although '::' and '@' apparently have the same precidence we want
		// * '@' to bind more tightly than '::'. As we can see in the following example:
		// * "dictionary"@String :: OutputForm.
		// * / CoerceExpression returns Expr hidden(WS, SL_COMMENT):
		//	HintTypeExpression ({CoerceExpression.left=current} op=COERCE rightType=TypeExpression)*;
		public ParserRule getRule() { return rule; }

		//HintTypeExpression ({CoerceExpression.left=current} op=COERCE rightType=TypeExpression)*
		public Group getGroup() { return cGroup; }

		//HintTypeExpression
		public RuleCall getHintTypeExpressionParserRuleCall_0() { return cHintTypeExpressionParserRuleCall_0; }

		//({CoerceExpression.left=current} op=COERCE rightType=TypeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{CoerceExpression.left=current}
		public Action getCoerceExpressionLeftAction_1_0() { return cCoerceExpressionLeftAction_1_0; }

		//op=COERCE
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//COERCE
		public RuleCall getOpCOERCETerminalRuleCall_1_1_0() { return cOpCOERCETerminalRuleCall_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class HintTypeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HintTypeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEltExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cHintTypeExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpATTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		/// * 
		// * "@", precedence: 996, 997
		// * / HintTypeExpression returns Expr hidden(WS, SL_COMMENT):
		//	EltExpression ({HintTypeExpression.left=current} op=AT rightType=TypeExpression)?;
		public ParserRule getRule() { return rule; }

		//EltExpression ({HintTypeExpression.left=current} op=AT rightType=TypeExpression)?
		public Group getGroup() { return cGroup; }

		//EltExpression
		public RuleCall getEltExpressionParserRuleCall_0() { return cEltExpressionParserRuleCall_0; }

		//({HintTypeExpression.left=current} op=AT rightType=TypeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{HintTypeExpression.left=current}
		public Action getHintTypeExpressionLeftAction_1_0() { return cHintTypeExpressionLeftAction_1_0; }

		//op=AT
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//AT
		public RuleCall getOpATTerminalRuleCall_1_1_0() { return cOpATTerminalRuleCall_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class EltExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EltExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExplicitTypeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEltExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpDOTTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExplicitTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// * We treat these as part of the language
		// * : indicates type
		// * ! is part of name to indicate mutable
		// * 
		// * ":", precedence: 996, 997
		// * "!", precedence: 1002, 1001
		// *
		// * / / *BangExpression returns Expr hidden(WS,SL_COMMENT):
		//  EqualityExpression
		//  ({AndExpression.left=current} op=AMPERSAND right = EqualityExpression)*
		//;* / / * 
		// * "with",  precedence: 2000, 400, ["parse_InfixWith"]
		// *
		// * / / *WithExpression returns Expr hidden(WS,SL_COMMENT):
		//  EqualityExpression
		//  ({AndExpression.left=current} op='with' right = EqualityExpression)*
		//;* / / * Elt is Lisp terminology for the use of '.' to select parameters
		// * the left expression is something that has selectable elements such as
		// * a list, array, string, Record or union, the right element should be a
		// * non-negative integer.
		// * / EltExpression returns Expr hidden(WS, SL_COMMENT):
		//	ExplicitTypeExpression ({EltExpression.left=current} op=DOT right=ExplicitTypeExpression)*;
		public ParserRule getRule() { return rule; }

		//ExplicitTypeExpression ({EltExpression.left=current} op=DOT right=ExplicitTypeExpression)*
		public Group getGroup() { return cGroup; }

		//ExplicitTypeExpression
		public RuleCall getExplicitTypeExpressionParserRuleCall_0() { return cExplicitTypeExpressionParserRuleCall_0; }

		//({EltExpression.left=current} op=DOT right=ExplicitTypeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{EltExpression.left=current}
		public Action getEltExpressionLeftAction_1_0() { return cEltExpressionLeftAction_1_0; }

		//op=DOT
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//DOT
		public RuleCall getOpDOTTerminalRuleCall_1_1_0() { return cOpDOTTerminalRuleCall_1_1_0; }

		//right=ExplicitTypeExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ExplicitTypeExpression
		public RuleCall getRightExplicitTypeExpressionParserRuleCall_1_2_0() { return cRightExplicitTypeExpressionParserRuleCall_1_2_0; }
	}

	public class ExplicitTypeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExplicitTypeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExplicitTypeExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpDOLARTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTypeTypeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightTypeAssignment_1_2.eContents().get(0);
		
		//////////////// unary expressions ////////////////////
		/// * 
		// * '$'
		// * / ExplicitTypeExpression returns Expr hidden(WS, SL_COMMENT):
		//	UnaryExpression ({ExplicitTypeExpression.left=current} op=DOLAR rightType=TypeExpression)?;
		public ParserRule getRule() { return rule; }

		//UnaryExpression ({ExplicitTypeExpression.left=current} op=DOLAR rightType=TypeExpression)?
		public Group getGroup() { return cGroup; }

		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }

		//({ExplicitTypeExpression.left=current} op=DOLAR rightType=TypeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{ExplicitTypeExpression.left=current}
		public Action getExplicitTypeExpressionLeftAction_1_0() { return cExplicitTypeExpressionLeftAction_1_0; }

		//op=DOLAR
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//DOLAR
		public RuleCall getOpDOLARTerminalRuleCall_1_1_0() { return cOpDOLARTerminalRuleCall_1_1_0; }

		//rightType=TypeExpression
		public Assignment getRightTypeAssignment_1_2() { return cRightTypeAssignment_1_2; }

		//TypeExpression
		public RuleCall getRightTypeTypeExpressionParserRuleCall_1_2_0() { return cRightTypeTypeExpressionParserRuleCall_1_2_0; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cUnaryExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cUopAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUopTILDETerminalRuleCall_1_1_0 = (RuleCall)cUopAssignment_1_1.eContents().get(0);
		private final Assignment cExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExprUnaryExpressionParserRuleCall_1_2_0 = (RuleCall)cExprAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cUnaryExpressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cUopAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cUopMINUSTerminalRuleCall_2_1_0 = (RuleCall)cUopAssignment_2_1.eContents().get(0);
		private final Assignment cExprAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cExprUnaryExpressionParserRuleCall_2_2_0 = (RuleCall)cExprAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cUnaryExpressionAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cUopAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cUopHASHTerminalRuleCall_3_1_0 = (RuleCall)cUopAssignment_3_1.eContents().get(0);
		private final Assignment cExprAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cExprUnaryExpressionParserRuleCall_3_2_0 = (RuleCall)cExprAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cUnaryExpressionAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Assignment cUopAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final Keyword cUopNotKeyword_4_1_0 = (Keyword)cUopAssignment_4_1.eContents().get(0);
		private final Assignment cExprAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cExprPrimaryExpressionParserRuleCall_4_2_0 = (RuleCall)cExprAssignment_4_2.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cUnaryExpressionAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Assignment cUopAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cUopSUMLISTTerminalRuleCall_5_1_0 = (RuleCall)cUopAssignment_5_1.eContents().get(0);
		private final Assignment cExprAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cExprPrimaryExpressionParserRuleCall_5_2_0 = (RuleCall)cExprAssignment_5_2.eContents().get(0);
		private final Assignment cE2Assignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cE2PERCENTTerminalRuleCall_6_0 = (RuleCall)cE2Assignment_6.eContents().get(0);
		private final Assignment cE3Assignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final Keyword cE3TypeKeyword_7_0 = (Keyword)cE3Assignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cAlternatives.eContents().get(8);
		private final Assignment cE5Assignment_8_0 = (Assignment)cGroup_8.eContents().get(0);
		private final Keyword cE5RecordKeyword_8_0_0 = (Keyword)cE5Assignment_8_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_8_1 = (RuleCall)cGroup_8.eContents().get(1);
		private final Assignment cE6Assignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cE6TypeExpressionParserRuleCall_8_2_0 = (RuleCall)cE6Assignment_8_2.eContents().get(0);
		private final Group cGroup_8_3 = (Group)cGroup_8.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_8_3_0 = (RuleCall)cGroup_8_3.eContents().get(0);
		private final Assignment cE22Assignment_8_3_1 = (Assignment)cGroup_8_3.eContents().get(1);
		private final RuleCall cE22TypeExpressionParserRuleCall_8_3_1_0 = (RuleCall)cE22Assignment_8_3_1.eContents().get(0);
		private final Group cGroup_8_4 = (Group)cGroup_8.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_8_4_0 = (RuleCall)cGroup_8_4.eContents().get(0);
		private final Assignment cE21Assignment_8_4_1 = (Assignment)cGroup_8_4.eContents().get(1);
		private final RuleCall cE21TypeExpressionParserRuleCall_8_4_1_0 = (RuleCall)cE21Assignment_8_4_1.eContents().get(0);
		private final Group cGroup_8_4_2 = (Group)cGroup_8_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_8_4_2_0 = (RuleCall)cGroup_8_4_2.eContents().get(0);
		private final Assignment cE23Assignment_8_4_2_1 = (Assignment)cGroup_8_4_2.eContents().get(1);
		private final RuleCall cE23TypeExpressionParserRuleCall_8_4_2_1_0 = (RuleCall)cE23Assignment_8_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_8_5 = (RuleCall)cGroup_8.eContents().get(5);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final Assignment cE9Assignment_9_0 = (Assignment)cGroup_9.eContents().get(0);
		private final Keyword cE9UnionKeyword_9_0_0 = (Keyword)cE9Assignment_9_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_9_1 = (RuleCall)cGroup_9.eContents().get(1);
		private final Assignment cE10Assignment_9_2 = (Assignment)cGroup_9.eContents().get(2);
		private final RuleCall cE10TypeExpressionParserRuleCall_9_2_0 = (RuleCall)cE10Assignment_9_2.eContents().get(0);
		private final Group cGroup_9_3 = (Group)cGroup_9.eContents().get(3);
		private final RuleCall cCOLONTerminalRuleCall_9_3_0 = (RuleCall)cGroup_9_3.eContents().get(0);
		private final Assignment cE25Assignment_9_3_1 = (Assignment)cGroup_9_3.eContents().get(1);
		private final RuleCall cE25TypeExpressionParserRuleCall_9_3_1_0 = (RuleCall)cE25Assignment_9_3_1.eContents().get(0);
		private final Group cGroup_9_4 = (Group)cGroup_9.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_9_4_0 = (RuleCall)cGroup_9_4.eContents().get(0);
		private final Assignment cE24Assignment_9_4_1 = (Assignment)cGroup_9_4.eContents().get(1);
		private final RuleCall cE24TypeExpressionParserRuleCall_9_4_1_0 = (RuleCall)cE24Assignment_9_4_1.eContents().get(0);
		private final Group cGroup_9_4_2 = (Group)cGroup_9_4.eContents().get(2);
		private final RuleCall cCOLONTerminalRuleCall_9_4_2_0 = (RuleCall)cGroup_9_4_2.eContents().get(0);
		private final Assignment cE26Assignment_9_4_2_1 = (Assignment)cGroup_9_4_2.eContents().get(1);
		private final RuleCall cE26TypeExpressionParserRuleCall_9_4_2_1_0 = (RuleCall)cE26Assignment_9_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_9_5 = (RuleCall)cGroup_9.eContents().get(5);
		private final Group cGroup_10 = (Group)cAlternatives.eContents().get(10);
		private final Assignment cE11Assignment_10_0 = (Assignment)cGroup_10.eContents().get(0);
		private final Keyword cE11JoinKeyword_10_0_0 = (Keyword)cE11Assignment_10_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_10_1 = (RuleCall)cGroup_10.eContents().get(1);
		private final Assignment cE12Assignment_10_2 = (Assignment)cGroup_10.eContents().get(2);
		private final RuleCall cE12TypeExpressionParserRuleCall_10_2_0 = (RuleCall)cE12Assignment_10_2.eContents().get(0);
		private final Group cGroup_10_3 = (Group)cGroup_10.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_10_3_0 = (RuleCall)cGroup_10_3.eContents().get(0);
		private final Assignment cE13Assignment_10_3_1 = (Assignment)cGroup_10_3.eContents().get(1);
		private final RuleCall cE13TypeExpressionParserRuleCall_10_3_1_0 = (RuleCall)cE13Assignment_10_3_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_10_4 = (RuleCall)cGroup_10.eContents().get(4);
		
		/// * UnaryExpression
		// * "~" TILDE : precedence  260, 259, nil
		// * ":" COLON : precedence  194, 195
		// * "-" MINUS : precedence  701, 700
		// * "#" HASH : precedence  999, 998
		// * "'" : precedence  999, 999, ["parse_Data"]
		// * / UnaryExpression returns Expr hidden(WS, SL_COMMENT):
		//	PrimaryExpression //  ({UnaryExpression} uop=COLON expr=UnaryExpression) |
		//	| {UnaryExpression} uop=TILDE expr=UnaryExpression | {UnaryExpression} uop=MINUS expr=UnaryExpression |
		//	{UnaryExpression} uop=HASH expr=UnaryExpression | {UnaryExpression} uop="not" expr=PrimaryExpression |
		//	{UnaryExpression} uop=SUMLIST expr=PrimaryExpression | e2=PERCENT | e3="Type" | e5="Record" LPAREN e6=TypeExpression
		//	(COLON e22+=TypeExpression)? (COMMA e21+=TypeExpression (COLON e23+=TypeExpression)?)* RPAREN | e9="Union" LPAREN
		//	e10=TypeExpression (COLON e25+=TypeExpression)? (COMMA e24+=TypeExpression (COLON e26+=TypeExpression)?)* RPAREN |
		//	e11="Join" LPAREN e12=TypeExpression (COMMA e13+=TypeExpression)* RPAREN;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression //  ({UnaryExpression} uop=COLON expr=UnaryExpression) |
		//| {UnaryExpression} uop=TILDE expr=UnaryExpression | {UnaryExpression} uop=MINUS expr=UnaryExpression |
		//{UnaryExpression} uop=HASH expr=UnaryExpression | {UnaryExpression} uop="not" expr=PrimaryExpression |
		//{UnaryExpression} uop=SUMLIST expr=PrimaryExpression | e2=PERCENT | e3="Type" | e5="Record" LPAREN e6=TypeExpression
		//(COLON e22+=TypeExpression)? (COMMA e21+=TypeExpression (COLON e23+=TypeExpression)?)* RPAREN | e9="Union" LPAREN
		//e10=TypeExpression (COLON e25+=TypeExpression)? (COMMA e24+=TypeExpression (COLON e26+=TypeExpression)?)* RPAREN |
		//e11="Join" LPAREN e12=TypeExpression (COMMA e13+=TypeExpression)* RPAREN
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//{UnaryExpression} uop=TILDE expr=UnaryExpression
		public Group getGroup_1() { return cGroup_1; }

		//{UnaryExpression}
		public Action getUnaryExpressionAction_1_0() { return cUnaryExpressionAction_1_0; }

		//uop=TILDE
		public Assignment getUopAssignment_1_1() { return cUopAssignment_1_1; }

		//TILDE
		public RuleCall getUopTILDETerminalRuleCall_1_1_0() { return cUopTILDETerminalRuleCall_1_1_0; }

		//expr=UnaryExpression
		public Assignment getExprAssignment_1_2() { return cExprAssignment_1_2; }

		//UnaryExpression
		public RuleCall getExprUnaryExpressionParserRuleCall_1_2_0() { return cExprUnaryExpressionParserRuleCall_1_2_0; }

		//{UnaryExpression} uop=MINUS expr=UnaryExpression
		public Group getGroup_2() { return cGroup_2; }

		//{UnaryExpression}
		public Action getUnaryExpressionAction_2_0() { return cUnaryExpressionAction_2_0; }

		//uop=MINUS
		public Assignment getUopAssignment_2_1() { return cUopAssignment_2_1; }

		//MINUS
		public RuleCall getUopMINUSTerminalRuleCall_2_1_0() { return cUopMINUSTerminalRuleCall_2_1_0; }

		//expr=UnaryExpression
		public Assignment getExprAssignment_2_2() { return cExprAssignment_2_2; }

		//UnaryExpression
		public RuleCall getExprUnaryExpressionParserRuleCall_2_2_0() { return cExprUnaryExpressionParserRuleCall_2_2_0; }

		//{UnaryExpression} uop=HASH expr=UnaryExpression
		public Group getGroup_3() { return cGroup_3; }

		//{UnaryExpression}
		public Action getUnaryExpressionAction_3_0() { return cUnaryExpressionAction_3_0; }

		//uop=HASH
		public Assignment getUopAssignment_3_1() { return cUopAssignment_3_1; }

		//HASH
		public RuleCall getUopHASHTerminalRuleCall_3_1_0() { return cUopHASHTerminalRuleCall_3_1_0; }

		//expr=UnaryExpression
		public Assignment getExprAssignment_3_2() { return cExprAssignment_3_2; }

		//UnaryExpression
		public RuleCall getExprUnaryExpressionParserRuleCall_3_2_0() { return cExprUnaryExpressionParserRuleCall_3_2_0; }

		//{UnaryExpression} uop="not" expr=PrimaryExpression
		public Group getGroup_4() { return cGroup_4; }

		//{UnaryExpression}
		public Action getUnaryExpressionAction_4_0() { return cUnaryExpressionAction_4_0; }

		//uop="not"
		public Assignment getUopAssignment_4_1() { return cUopAssignment_4_1; }

		//"not"
		public Keyword getUopNotKeyword_4_1_0() { return cUopNotKeyword_4_1_0; }

		//expr=PrimaryExpression
		public Assignment getExprAssignment_4_2() { return cExprAssignment_4_2; }

		//PrimaryExpression
		public RuleCall getExprPrimaryExpressionParserRuleCall_4_2_0() { return cExprPrimaryExpressionParserRuleCall_4_2_0; }

		//{UnaryExpression} uop=SUMLIST expr=PrimaryExpression
		public Group getGroup_5() { return cGroup_5; }

		//{UnaryExpression}
		public Action getUnaryExpressionAction_5_0() { return cUnaryExpressionAction_5_0; }

		//uop=SUMLIST
		public Assignment getUopAssignment_5_1() { return cUopAssignment_5_1; }

		//SUMLIST
		public RuleCall getUopSUMLISTTerminalRuleCall_5_1_0() { return cUopSUMLISTTerminalRuleCall_5_1_0; }

		//expr=PrimaryExpression
		public Assignment getExprAssignment_5_2() { return cExprAssignment_5_2; }

		//PrimaryExpression
		public RuleCall getExprPrimaryExpressionParserRuleCall_5_2_0() { return cExprPrimaryExpressionParserRuleCall_5_2_0; }

		//e2=PERCENT
		public Assignment getE2Assignment_6() { return cE2Assignment_6; }

		//PERCENT
		public RuleCall getE2PERCENTTerminalRuleCall_6_0() { return cE2PERCENTTerminalRuleCall_6_0; }

		//e3="Type"
		public Assignment getE3Assignment_7() { return cE3Assignment_7; }

		//"Type"
		public Keyword getE3TypeKeyword_7_0() { return cE3TypeKeyword_7_0; }

		//e5="Record" LPAREN e6=TypeExpression (COLON e22+=TypeExpression)? (COMMA e21+=TypeExpression (COLON
		//e23+=TypeExpression)?)* RPAREN
		public Group getGroup_8() { return cGroup_8; }

		//e5="Record"
		public Assignment getE5Assignment_8_0() { return cE5Assignment_8_0; }

		//"Record"
		public Keyword getE5RecordKeyword_8_0_0() { return cE5RecordKeyword_8_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_8_1() { return cLPARENTerminalRuleCall_8_1; }

		//e6=TypeExpression
		public Assignment getE6Assignment_8_2() { return cE6Assignment_8_2; }

		//TypeExpression
		public RuleCall getE6TypeExpressionParserRuleCall_8_2_0() { return cE6TypeExpressionParserRuleCall_8_2_0; }

		//(COLON e22+=TypeExpression)?
		public Group getGroup_8_3() { return cGroup_8_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_8_3_0() { return cCOLONTerminalRuleCall_8_3_0; }

		//e22+=TypeExpression
		public Assignment getE22Assignment_8_3_1() { return cE22Assignment_8_3_1; }

		//TypeExpression
		public RuleCall getE22TypeExpressionParserRuleCall_8_3_1_0() { return cE22TypeExpressionParserRuleCall_8_3_1_0; }

		//(COMMA e21+=TypeExpression (COLON e23+=TypeExpression)?)*
		public Group getGroup_8_4() { return cGroup_8_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_8_4_0() { return cCOMMATerminalRuleCall_8_4_0; }

		//e21+=TypeExpression
		public Assignment getE21Assignment_8_4_1() { return cE21Assignment_8_4_1; }

		//TypeExpression
		public RuleCall getE21TypeExpressionParserRuleCall_8_4_1_0() { return cE21TypeExpressionParserRuleCall_8_4_1_0; }

		//(COLON e23+=TypeExpression)?
		public Group getGroup_8_4_2() { return cGroup_8_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_8_4_2_0() { return cCOLONTerminalRuleCall_8_4_2_0; }

		//e23+=TypeExpression
		public Assignment getE23Assignment_8_4_2_1() { return cE23Assignment_8_4_2_1; }

		//TypeExpression
		public RuleCall getE23TypeExpressionParserRuleCall_8_4_2_1_0() { return cE23TypeExpressionParserRuleCall_8_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_8_5() { return cRPARENTerminalRuleCall_8_5; }

		//e9="Union" LPAREN e10=TypeExpression (COLON e25+=TypeExpression)? (COMMA e24+=TypeExpression (COLON
		//e26+=TypeExpression)?)* RPAREN
		public Group getGroup_9() { return cGroup_9; }

		//e9="Union"
		public Assignment getE9Assignment_9_0() { return cE9Assignment_9_0; }

		//"Union"
		public Keyword getE9UnionKeyword_9_0_0() { return cE9UnionKeyword_9_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_9_1() { return cLPARENTerminalRuleCall_9_1; }

		//e10=TypeExpression
		public Assignment getE10Assignment_9_2() { return cE10Assignment_9_2; }

		//TypeExpression
		public RuleCall getE10TypeExpressionParserRuleCall_9_2_0() { return cE10TypeExpressionParserRuleCall_9_2_0; }

		//(COLON e25+=TypeExpression)?
		public Group getGroup_9_3() { return cGroup_9_3; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_9_3_0() { return cCOLONTerminalRuleCall_9_3_0; }

		//e25+=TypeExpression
		public Assignment getE25Assignment_9_3_1() { return cE25Assignment_9_3_1; }

		//TypeExpression
		public RuleCall getE25TypeExpressionParserRuleCall_9_3_1_0() { return cE25TypeExpressionParserRuleCall_9_3_1_0; }

		//(COMMA e24+=TypeExpression (COLON e26+=TypeExpression)?)*
		public Group getGroup_9_4() { return cGroup_9_4; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_9_4_0() { return cCOMMATerminalRuleCall_9_4_0; }

		//e24+=TypeExpression
		public Assignment getE24Assignment_9_4_1() { return cE24Assignment_9_4_1; }

		//TypeExpression
		public RuleCall getE24TypeExpressionParserRuleCall_9_4_1_0() { return cE24TypeExpressionParserRuleCall_9_4_1_0; }

		//(COLON e26+=TypeExpression)?
		public Group getGroup_9_4_2() { return cGroup_9_4_2; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_9_4_2_0() { return cCOLONTerminalRuleCall_9_4_2_0; }

		//e26+=TypeExpression
		public Assignment getE26Assignment_9_4_2_1() { return cE26Assignment_9_4_2_1; }

		//TypeExpression
		public RuleCall getE26TypeExpressionParserRuleCall_9_4_2_1_0() { return cE26TypeExpressionParserRuleCall_9_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_9_5() { return cRPARENTerminalRuleCall_9_5; }

		//e11="Join" LPAREN e12=TypeExpression (COMMA e13+=TypeExpression)* RPAREN
		public Group getGroup_10() { return cGroup_10; }

		//e11="Join"
		public Assignment getE11Assignment_10_0() { return cE11Assignment_10_0; }

		//"Join"
		public Keyword getE11JoinKeyword_10_0_0() { return cE11JoinKeyword_10_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_10_1() { return cLPARENTerminalRuleCall_10_1; }

		//e12=TypeExpression
		public Assignment getE12Assignment_10_2() { return cE12Assignment_10_2; }

		//TypeExpression
		public RuleCall getE12TypeExpressionParserRuleCall_10_2_0() { return cE12TypeExpressionParserRuleCall_10_2_0; }

		//(COMMA e13+=TypeExpression)*
		public Group getGroup_10_3() { return cGroup_10_3; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_10_3_0() { return cCOMMATerminalRuleCall_10_3_0; }

		//e13+=TypeExpression
		public Assignment getE13Assignment_10_3_1() { return cE13Assignment_10_3_1; }

		//TypeExpression
		public RuleCall getE13TypeExpressionParserRuleCall_10_3_1_0() { return cE13TypeExpressionParserRuleCall_10_3_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_10_4() { return cRPARENTerminalRuleCall_10_4; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final RuleCall cPrimaryPrefixParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * 
		// *
		// * / / *UnaryExpressionHash returns Expr hidden(WS,SL_COMMENT):
		////  HASH? PrimaryExpression
		//  PrimaryExpression | ({UnaryExpressionHash} uop=HASH expr=UnaryExpressionHash)
		//;* / / * 
		// *
		// * / PrimaryExpression returns Expr hidden(WS, SL_COMMENT): / * ( t2+=PrimarySuffix )*    * / PrimaryPrefix;
		public ParserRule getRule() { return rule; }

		/// * ( t2+=PrimarySuffix )*    * / PrimaryPrefix
		public RuleCall getPrimaryPrefixParserRuleCall() { return cPrimaryPrefixParserRuleCall; }
	}

	public class PrimaryPrefixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryPrefix");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cLPARENTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cT4Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cT4ExpressionParserRuleCall_1_1_0 = (RuleCall)cT4Assignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_1_2_0 = (RuleCall)cGroup_1_2.eContents().get(0);
		private final Assignment cT25Assignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cT25ExpressionParserRuleCall_1_2_1_0 = (RuleCall)cT25Assignment_1_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Group cGroup_1_4 = (Group)cGroup_1.eContents().get(4);
		private final Group cGroup_1_4_0 = (Group)cGroup_1_4.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_1_4_0_0 = (RuleCall)cGroup_1_4_0.eContents().get(0);
		private final Assignment cRightType3Assignment_1_4_0_1 = (Assignment)cGroup_1_4_0.eContents().get(1);
		private final RuleCall cRightType3TypeExpressionParserRuleCall_1_4_0_1_0 = (RuleCall)cRightType3Assignment_1_4_0_1.eContents().get(0);
		private final Assignment cT7Assignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cT7NameOrFunctionCallParserRuleCall_2_0 = (RuleCall)cT7Assignment_2.eContents().get(0);
		
		/// * 
		// * Can contain an expression in parenthesis, this expression is
		// * 'StatementExpression' which means that it can contain an
		// * inner assignment.
		// * 
		// * The comma option allows us to define a tuple
		// * / PrimaryPrefix hidden(WS, SL_COMMENT):
		//	Literal | LPAREN t4=Expression (COMMA t25+=Expression)* RPAREN => (COLON rightType3=TypeExpression)? |
		//	t7=NameOrFunctionCall;
		public ParserRule getRule() { return rule; }

		//Literal | LPAREN t4=Expression (COMMA t25+=Expression)* RPAREN => (COLON rightType3=TypeExpression)? |
		//t7=NameOrFunctionCall
		public Alternatives getAlternatives() { return cAlternatives; }

		//Literal
		public RuleCall getLiteralParserRuleCall_0() { return cLiteralParserRuleCall_0; }

		//LPAREN t4=Expression (COMMA t25+=Expression)* RPAREN => (COLON rightType3=TypeExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_1_0() { return cLPARENTerminalRuleCall_1_0; }

		//t4=Expression
		public Assignment getT4Assignment_1_1() { return cT4Assignment_1_1; }

		//Expression
		public RuleCall getT4ExpressionParserRuleCall_1_1_0() { return cT4ExpressionParserRuleCall_1_1_0; }

		//(COMMA t25+=Expression)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_2_0() { return cCOMMATerminalRuleCall_1_2_0; }

		//t25+=Expression
		public Assignment getT25Assignment_1_2_1() { return cT25Assignment_1_2_1; }

		//Expression
		public RuleCall getT25ExpressionParserRuleCall_1_2_1_0() { return cT25ExpressionParserRuleCall_1_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_1_3() { return cRPARENTerminalRuleCall_1_3; }

		//=> (COLON rightType3=TypeExpression)?
		public Group getGroup_1_4() { return cGroup_1_4; }

		//COLON rightType3=TypeExpression
		public Group getGroup_1_4_0() { return cGroup_1_4_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_1_4_0_0() { return cCOLONTerminalRuleCall_1_4_0_0; }

		//rightType3=TypeExpression
		public Assignment getRightType3Assignment_1_4_0_1() { return cRightType3Assignment_1_4_0_1; }

		//TypeExpression
		public RuleCall getRightType3TypeExpressionParserRuleCall_1_4_0_1_0() { return cRightType3TypeExpressionParserRuleCall_1_4_0_1_0; }

		//t7=NameOrFunctionCall
		public Assignment getT7Assignment_2() { return cT7Assignment_2; }

		//NameOrFunctionCall
		public RuleCall getT7NameOrFunctionCallParserRuleCall_2_0() { return cT7NameOrFunctionCallParserRuleCall_2_0; }
	}

	public class NameOrFunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NameOrFunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cApostropheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFnnameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFnnameIDTerminalRuleCall_1_0 = (RuleCall)cFnnameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cLspAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cLspDOLARTerminalRuleCall_2_0_0 = (RuleCall)cLspAssignment_2_0.eContents().get(0);
		private final Keyword cLispKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_3_0_0 = (RuleCall)cGroup_3_0.eContents().get(0);
		private final Assignment cT4Assignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final RuleCall cT4ExpressionParserRuleCall_3_0_1_0 = (RuleCall)cT4Assignment_3_0_1.eContents().get(0);
		private final Group cGroup_3_0_2 = (Group)cGroup_3_0.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_3_0_2_0 = (RuleCall)cGroup_3_0_2.eContents().get(0);
		private final Assignment cT5Assignment_3_0_2_1 = (Assignment)cGroup_3_0_2.eContents().get(1);
		private final RuleCall cT5ExpressionParserRuleCall_3_0_2_1_0 = (RuleCall)cT5Assignment_3_0_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3_0_3 = (RuleCall)cGroup_3_0.eContents().get(3);
		private final Group cGroup_3_0_4 = (Group)cGroup_3_0.eContents().get(4);
		private final RuleCall cLPARENTerminalRuleCall_3_0_4_0 = (RuleCall)cGroup_3_0_4.eContents().get(0);
		private final Assignment cT14Assignment_3_0_4_1 = (Assignment)cGroup_3_0_4.eContents().get(1);
		private final RuleCall cT14StatementParserRuleCall_3_0_4_1_0 = (RuleCall)cT14Assignment_3_0_4_1.eContents().get(0);
		private final Group cGroup_3_0_4_2 = (Group)cGroup_3_0_4.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_3_0_4_2_0 = (RuleCall)cGroup_3_0_4_2.eContents().get(0);
		private final Assignment cT15Assignment_3_0_4_2_1 = (Assignment)cGroup_3_0_4_2.eContents().get(1);
		private final RuleCall cT15ExpressionParserRuleCall_3_0_4_2_1_0 = (RuleCall)cT15Assignment_3_0_4_2_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3_0_4_3 = (RuleCall)cGroup_3_0_4.eContents().get(3);
		private final Assignment cT6Assignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cT6PrimaryExpressionParserRuleCall_3_1_0 = (RuleCall)cT6Assignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Group cGroup_4_0 = (Group)cGroup_4.eContents().get(0);
		private final Group cGroup_4_0_0 = (Group)cGroup_4_0.eContents().get(0);
		private final RuleCall cCOMMATerminalRuleCall_4_0_0_0 = (RuleCall)cGroup_4_0_0.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_4_0_0_1 = (RuleCall)cGroup_4_0_0.eContents().get(1);
		private final RuleCall cCOLONTerminalRuleCall_4_0_1 = (RuleCall)cGroup_4_0.eContents().get(1);
		private final Assignment cRightType2Assignment_4_0_2 = (Assignment)cGroup_4_0.eContents().get(2);
		private final RuleCall cRightType2TypeExpressionParserRuleCall_4_0_2_0 = (RuleCall)cRightType2Assignment_4_0_2.eContents().get(0);
		
		/// * function call such as List(Integer)
		// * known as a parameterised type or functor (not necessarily a true functor since
		// * it may not obey the axioms of a functor)
		// * if there is only one parameter then the parenthesis are optional
		// * 
		// * function binds most tightly
		// * / // allow multiple assignment
		////=>(op=GIVES lambda = Expression 'xxx')?
		//NameOrFunctionCall hidden(WS, SL_COMMENT):
		//	"\'"? fnname=ID (=> lsp=DOLAR "Lisp")? / *t2=TypeExpression* / //    LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
		//	(LPAREN t4=Expression? (COMMA t5+=Expression)* //(COLON rightType2 =TypeExpression)?
		//	RPAREN // optional curried function:
		//	(LPAREN t14+=Statement? (COMMA t15+=Expression)* RPAREN)* //  option for parameters in parenthesis
		//	// option of no parenthesis for single parameter
		//	| => t6=PrimaryExpression)? => ((COMMA ID)* COLON rightType2=TypeExpression)?;
		public ParserRule getRule() { return rule; }

		//"\'"? fnname=ID (=> lsp=DOLAR "Lisp")? / *t2=TypeExpression* / //    LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
		//(LPAREN t4=Expression? (COMMA t5+=Expression)* //(COLON rightType2 =TypeExpression)?
		//RPAREN // optional curried function:
		//(LPAREN t14+=Statement? (COMMA t15+=Expression)* RPAREN)* //  option for parameters in parenthesis
		//// option of no parenthesis for single parameter
		//| => t6=PrimaryExpression)? => ((COMMA ID)* COLON rightType2=TypeExpression)?
		public Group getGroup() { return cGroup; }

		//"\'"?
		public Keyword getApostropheKeyword_0() { return cApostropheKeyword_0; }

		//fnname=ID
		public Assignment getFnnameAssignment_1() { return cFnnameAssignment_1; }

		//ID
		public RuleCall getFnnameIDTerminalRuleCall_1_0() { return cFnnameIDTerminalRuleCall_1_0; }

		//(=> lsp=DOLAR "Lisp")?
		public Group getGroup_2() { return cGroup_2; }

		//=> lsp=DOLAR
		public Assignment getLspAssignment_2_0() { return cLspAssignment_2_0; }

		//DOLAR
		public RuleCall getLspDOLARTerminalRuleCall_2_0_0() { return cLspDOLARTerminalRuleCall_2_0_0; }

		//"Lisp"
		public Keyword getLispKeyword_2_1() { return cLispKeyword_2_1; }

		////    LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
		//(LPAREN t4=Expression? (COMMA t5+=Expression)* //(COLON rightType2 =TypeExpression)?
		//RPAREN // optional curried function:
		//(LPAREN t14+=Statement? (COMMA t15+=Expression)* RPAREN)* //  option for parameters in parenthesis
		//// option of no parenthesis for single parameter
		//| => t6=PrimaryExpression)?
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		////    LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
		//LPAREN t4=Expression? (COMMA t5+=Expression)* //(COLON rightType2 =TypeExpression)?
		//RPAREN // optional curried function:
		//(LPAREN t14+=Statement? (COMMA t15+=Expression)* RPAREN)*
		public Group getGroup_3_0() { return cGroup_3_0; }

		////    LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_3_0_0() { return cLPARENTerminalRuleCall_3_0_0; }

		//t4=Expression?
		public Assignment getT4Assignment_3_0_1() { return cT4Assignment_3_0_1; }

		//Expression
		public RuleCall getT4ExpressionParserRuleCall_3_0_1_0() { return cT4ExpressionParserRuleCall_3_0_1_0; }

		//(COMMA t5+=Expression)*
		public Group getGroup_3_0_2() { return cGroup_3_0_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_0_2_0() { return cCOMMATerminalRuleCall_3_0_2_0; }

		//t5+=Expression
		public Assignment getT5Assignment_3_0_2_1() { return cT5Assignment_3_0_2_1; }

		//Expression
		public RuleCall getT5ExpressionParserRuleCall_3_0_2_1_0() { return cT5ExpressionParserRuleCall_3_0_2_1_0; }

		////(COLON rightType2 =TypeExpression)?
		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3_0_3() { return cRPARENTerminalRuleCall_3_0_3; }

		//(LPAREN t14+=Statement? (COMMA t15+=Expression)* RPAREN)*
		public Group getGroup_3_0_4() { return cGroup_3_0_4; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_3_0_4_0() { return cLPARENTerminalRuleCall_3_0_4_0; }

		//t14+=Statement?
		public Assignment getT14Assignment_3_0_4_1() { return cT14Assignment_3_0_4_1; }

		//Statement
		public RuleCall getT14StatementParserRuleCall_3_0_4_1_0() { return cT14StatementParserRuleCall_3_0_4_1_0; }

		//(COMMA t15+=Expression)*
		public Group getGroup_3_0_4_2() { return cGroup_3_0_4_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_0_4_2_0() { return cCOMMATerminalRuleCall_3_0_4_2_0; }

		//t15+=Expression
		public Assignment getT15Assignment_3_0_4_2_1() { return cT15Assignment_3_0_4_2_1; }

		//Expression
		public RuleCall getT15ExpressionParserRuleCall_3_0_4_2_1_0() { return cT15ExpressionParserRuleCall_3_0_4_2_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3_0_4_3() { return cRPARENTerminalRuleCall_3_0_4_3; }

		//=> t6=PrimaryExpression
		public Assignment getT6Assignment_3_1() { return cT6Assignment_3_1; }

		//PrimaryExpression
		public RuleCall getT6PrimaryExpressionParserRuleCall_3_1_0() { return cT6PrimaryExpressionParserRuleCall_3_1_0; }

		//=> ((COMMA ID)* COLON rightType2=TypeExpression)?
		public Group getGroup_4() { return cGroup_4; }

		//(COMMA ID)* COLON rightType2=TypeExpression
		public Group getGroup_4_0() { return cGroup_4_0; }

		//(COMMA ID)*
		public Group getGroup_4_0_0() { return cGroup_4_0_0; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_4_0_0_0() { return cCOMMATerminalRuleCall_4_0_0_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_4_0_0_1() { return cIDTerminalRuleCall_4_0_0_1; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_4_0_1() { return cCOLONTerminalRuleCall_4_0_1; }

		//rightType2=TypeExpression
		public Assignment getRightType2Assignment_4_0_2() { return cRightType2Assignment_4_0_2; }

		//TypeExpression
		public RuleCall getRightType2TypeExpressionParserRuleCall_4_0_2_0() { return cRightType2TypeExpressionParserRuleCall_4_0_2_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueINTTerminalRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cT2Assignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cT2STRINGTerminalRuleCall_1_0_0 = (RuleCall)cT2Assignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cE1Assignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cE1NameOrFunctionCallParserRuleCall_1_1_0_0 = (RuleCall)cE1Assignment_1_1_0.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Group cGroup_1_1_1_0 = (Group)cGroup_1_1_1.eContents().get(0);
		private final Assignment cT31Assignment_1_1_1_0_0 = (Assignment)cGroup_1_1_1_0.eContents().get(0);
		private final RuleCall cT31STRINGTerminalRuleCall_1_1_1_0_0_0 = (RuleCall)cT31Assignment_1_1_1_0_0.eContents().get(0);
		private final Assignment cE4Assignment_1_1_1_0_1 = (Assignment)cGroup_1_1_1_0.eContents().get(1);
		private final RuleCall cE4NameOrFunctionCallParserRuleCall_1_1_1_0_1_0 = (RuleCall)cE4Assignment_1_1_1_0_1.eContents().get(0);
		private final RuleCall cListLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cCharacterLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cBooleanLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		/// * Literals are actual values of a given type 
		// * Outstanding issues:
		// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
		// *    and convert to float literal
		// * 2) We need to be able to recognise exponent notation for floats
		// * 3) Integers without '-' prefix can be converted to PI or NNI
		// * 4) need to add hex or octal notation for integers (0xhhhh)
		// * 5) String and Character literals need to have backslash "\" doubled to
		// *    "\\" otherwise xtext will interpret backslash as an escape character.
		// * 6) values following immediately after string literal such as "abc"d should
		// *    represent an implied concat: concat("abc",d)
		// * / Literal hidden(WS, SL_COMMENT):
		//	value=INT //  | t3=FloatLiteral // conflicts with use of '.' for elt
		//	| t2=STRING (=> e1=NameOrFunctionCall => (t31+=STRING => e4+=NameOrFunctionCall?)*)? | ListLiteral | CharacterLiteral |
		//	BooleanLiteral;
		public ParserRule getRule() { return rule; }

		//value=INT //  | t3=FloatLiteral // conflicts with use of '.' for elt
		//| t2=STRING (=> e1=NameOrFunctionCall => (t31+=STRING => e4+=NameOrFunctionCall?)*)? | ListLiteral | CharacterLiteral |
		//BooleanLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//value=INT
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_0_0() { return cValueINTTerminalRuleCall_0_0; }

		//t2=STRING (=> e1=NameOrFunctionCall => (t31+=STRING => e4+=NameOrFunctionCall?)*)?
		public Group getGroup_1() { return cGroup_1; }

		//t2=STRING
		public Assignment getT2Assignment_1_0() { return cT2Assignment_1_0; }

		//STRING
		public RuleCall getT2STRINGTerminalRuleCall_1_0_0() { return cT2STRINGTerminalRuleCall_1_0_0; }

		//(=> e1=NameOrFunctionCall => (t31+=STRING => e4+=NameOrFunctionCall?)*)?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//=> e1=NameOrFunctionCall
		public Assignment getE1Assignment_1_1_0() { return cE1Assignment_1_1_0; }

		//NameOrFunctionCall
		public RuleCall getE1NameOrFunctionCallParserRuleCall_1_1_0_0() { return cE1NameOrFunctionCallParserRuleCall_1_1_0_0; }

		//=> (t31+=STRING => e4+=NameOrFunctionCall?)*
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//t31+=STRING => e4+=NameOrFunctionCall?
		public Group getGroup_1_1_1_0() { return cGroup_1_1_1_0; }

		//t31+=STRING
		public Assignment getT31Assignment_1_1_1_0_0() { return cT31Assignment_1_1_1_0_0; }

		//STRING
		public RuleCall getT31STRINGTerminalRuleCall_1_1_1_0_0_0() { return cT31STRINGTerminalRuleCall_1_1_1_0_0_0; }

		//=> e4+=NameOrFunctionCall?
		public Assignment getE4Assignment_1_1_1_0_1() { return cE4Assignment_1_1_1_0_1; }

		//NameOrFunctionCall
		public RuleCall getE4NameOrFunctionCallParserRuleCall_1_1_1_0_1_0() { return cE4NameOrFunctionCallParserRuleCall_1_1_1_0_1_0; }

		//ListLiteral
		public RuleCall getListLiteralParserRuleCall_2() { return cListLiteralParserRuleCall_2; }

		//CharacterLiteral
		public RuleCall getCharacterLiteralParserRuleCall_3() { return cCharacterLiteralParserRuleCall_3; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_4() { return cBooleanLiteralParserRuleCall_4; }
	}

	public class CharacterLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CharacterLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cApostropheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cC1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cC1ANY_OTHERTerminalRuleCall_1_0 = (RuleCall)cC1Assignment_1.eContents().get(0);
		private final Keyword cApostropheKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		/// * Contains a single character whereas a string contains multiple
		// * characters.
		// * / CharacterLiteral hidden(WS, SL_COMMENT):
		//	"\'" c1=ANY_OTHER "\'";
		public ParserRule getRule() { return rule; }

		//"\'" c1=ANY_OTHER "\'"
		public Group getGroup() { return cGroup; }

		//"\'"
		public Keyword getApostropheKeyword_0() { return cApostropheKeyword_0; }

		//c1=ANY_OTHER
		public Assignment getC1Assignment_1() { return cC1Assignment_1; }

		//ANY_OTHER
		public RuleCall getC1ANY_OTHERTerminalRuleCall_1_0() { return cC1ANY_OTHERTerminalRuleCall_1_0; }

		//"\'"
		public Keyword getApostropheKeyword_2() { return cApostropheKeyword_2; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cLitnameAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Keyword cLitnameTrueKeyword_0_0 = (Keyword)cLitnameAssignment_0.eContents().get(0);
		private final Assignment cLitnameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cLitnameFalseKeyword_1_0 = (Keyword)cLitnameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cLitnameAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cLitnameTrueKeyword_2_0_0 = (Keyword)cLitnameAssignment_2_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final RuleCall cRPARENTerminalRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cLitnameAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Keyword cLitnameFalseKeyword_3_0_0 = (Keyword)cLitnameAssignment_3_0.eContents().get(0);
		private final RuleCall cLPARENTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final RuleCall cRPARENTerminalRuleCall_3_2 = (RuleCall)cGroup_3.eContents().get(2);
		
		/// * This may not need to be specified here at the syntax level. Perhaps we
		// * should treat boolean as any other library defined type.
		// * / BooleanLiteral hidden(WS, SL_COMMENT):
		//	litname="true" | litname="false" | litname="true" LPAREN RPAREN | litname="false" LPAREN RPAREN;
		public ParserRule getRule() { return rule; }

		//litname="true" | litname="false" | litname="true" LPAREN RPAREN | litname="false" LPAREN RPAREN
		public Alternatives getAlternatives() { return cAlternatives; }

		//litname="true"
		public Assignment getLitnameAssignment_0() { return cLitnameAssignment_0; }

		//"true"
		public Keyword getLitnameTrueKeyword_0_0() { return cLitnameTrueKeyword_0_0; }

		//litname="false"
		public Assignment getLitnameAssignment_1() { return cLitnameAssignment_1; }

		//"false"
		public Keyword getLitnameFalseKeyword_1_0() { return cLitnameFalseKeyword_1_0; }

		//litname="true" LPAREN RPAREN
		public Group getGroup_2() { return cGroup_2; }

		//litname="true"
		public Assignment getLitnameAssignment_2_0() { return cLitnameAssignment_2_0; }

		//"true"
		public Keyword getLitnameTrueKeyword_2_0_0() { return cLitnameTrueKeyword_2_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_2_1() { return cLPARENTerminalRuleCall_2_1; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_2_2() { return cRPARENTerminalRuleCall_2_2; }

		//litname="false" LPAREN RPAREN
		public Group getGroup_3() { return cGroup_3; }

		//litname="false"
		public Assignment getLitnameAssignment_3_0() { return cLitnameAssignment_3_0; }

		//"false"
		public Keyword getLitnameFalseKeyword_3_0_0() { return cLitnameFalseKeyword_3_0_0; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_3_1() { return cLPARENTerminalRuleCall_3_1; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3_2() { return cRPARENTerminalRuleCall_3_2; }
	}

	public class ListLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ListLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLitnameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLitnameLBRACKETTerminalRuleCall_0_0 = (RuleCall)cLitnameAssignment_0.eContents().get(0);
		private final Assignment cL2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cL2ExpressionParserRuleCall_1_0 = (RuleCall)cL2Assignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cT3Assignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cT3ExpressionParserRuleCall_2_1_0 = (RuleCall)cT3Assignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cForKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cT14Assignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cT14ExpressionParserRuleCall_3_1_0 = (RuleCall)cT14Assignment_3_1.eContents().get(0);
		private final Keyword cInKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Assignment cL5Assignment_3_3 = (Assignment)cGroup_3.eContents().get(3);
		private final RuleCall cL5ExpressionParserRuleCall_3_3_0 = (RuleCall)cL5Assignment_3_3.eContents().get(0);
		private final RuleCall cRBRACKETTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		/// *
		// * a list literal may consist of:
		// * [] an empty list
		// * [a] a single element
		// * [a,b] multiple elements
		// * [a for b in c] a list comprehension
		// * / ListLiteral hidden(WS, SL_COMMENT):
		//	litname=LBRACKET l2=Expression? (COMMA t3+=Expression)* ("for" t14+=Expression "in" l5+=Expression)? RBRACKET;
		public ParserRule getRule() { return rule; }

		//litname=LBRACKET l2=Expression? (COMMA t3+=Expression)* ("for" t14+=Expression "in" l5+=Expression)? RBRACKET
		public Group getGroup() { return cGroup; }

		//litname=LBRACKET
		public Assignment getLitnameAssignment_0() { return cLitnameAssignment_0; }

		//LBRACKET
		public RuleCall getLitnameLBRACKETTerminalRuleCall_0_0() { return cLitnameLBRACKETTerminalRuleCall_0_0; }

		//l2=Expression?
		public Assignment getL2Assignment_1() { return cL2Assignment_1; }

		//Expression
		public RuleCall getL2ExpressionParserRuleCall_1_0() { return cL2ExpressionParserRuleCall_1_0; }

		//(COMMA t3+=Expression)*
		public Group getGroup_2() { return cGroup_2; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_2_0() { return cCOMMATerminalRuleCall_2_0; }

		//t3+=Expression
		public Assignment getT3Assignment_2_1() { return cT3Assignment_2_1; }

		//Expression
		public RuleCall getT3ExpressionParserRuleCall_2_1_0() { return cT3ExpressionParserRuleCall_2_1_0; }

		//("for" t14+=Expression "in" l5+=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//"for"
		public Keyword getForKeyword_3_0() { return cForKeyword_3_0; }

		//t14+=Expression
		public Assignment getT14Assignment_3_1() { return cT14Assignment_3_1; }

		//Expression
		public RuleCall getT14ExpressionParserRuleCall_3_1_0() { return cT14ExpressionParserRuleCall_3_1_0; }

		//"in"
		public Keyword getInKeyword_3_2() { return cInKeyword_3_2; }

		//l5+=Expression
		public Assignment getL5Assignment_3_3() { return cL5Assignment_3_3; }

		//Expression
		public RuleCall getL5ExpressionParserRuleCall_3_3_0() { return cL5ExpressionParserRuleCall_3_3_0; }

		//RBRACKET
		public RuleCall getRBRACKETTerminalRuleCall_4() { return cRBRACKETTerminalRuleCall_4; }
	}
	
	
	private ModelElements pModel;
	private TerminalRule tID;
	private TerminalRule tWS;
	private TerminalRule tNL;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tMACROVALUE;
	private TerminalRule tSTRING;
	private TerminalRule tINT;
	private TerminalRule tLPAREN;
	private TerminalRule tRPAREN;
	private TerminalRule tLBRACE;
	private TerminalRule tRBRACE;
	private TerminalRule tLBRACKET;
	private TerminalRule tRBRACKET;
	private TerminalRule tOANGLE;
	private TerminalRule tCANGLE;
	private TerminalRule tMDEF;
	private TerminalRule tBAR;
	private TerminalRule tDOT;
	private TerminalRule tCOERCE;
	private TerminalRule tCOLON;
	private TerminalRule tAT;
	private TerminalRule tCOMMA;
	private TerminalRule tSEMICOLON;
	private TerminalRule tPOWER;
	private TerminalRule tTIMES;
	private TerminalRule tPLUS;
	private TerminalRule tMINUS;
	private TerminalRule tLT;
	private TerminalRule tGT;
	private TerminalRule tLE;
	private TerminalRule tGE;
	private TerminalRule tEQUAL;
	private TerminalRule tNOTEQUAL;
	private TerminalRule tTILDE;
	private TerminalRule tCARAT;
	private TerminalRule tSEG;
	private TerminalRule tHASH;
	private TerminalRule tAMPERSAND;
	private TerminalRule tDOLAR;
	private TerminalRule tSLASH;
	private TerminalRule tBACKSLASH;
	private TerminalRule tSLASHSLASH;
	private TerminalRule tBACKSLASHBACKSLASH;
	private TerminalRule tSLASHBACKSLASH;
	private TerminalRule tBACKSLASHSLASH;
	private TerminalRule tEXIT;
	private TerminalRule tBECOMES;
	private TerminalRule tDEF;
	private TerminalRule tARROW;
	private TerminalRule tLARROW;
	private TerminalRule tGIVES;
	private TerminalRule tPERCENT;
	private TerminalRule tELLIPSIS;
	private TerminalRule tSUMLIST;
	private TerminalRule tANY_OTHER;
	private CategoryDefElements pCategoryDef;
	private PackageDefElements pPackageDef;
	private DomainDefElements pDomainDef;
	private WherePartElements pWherePart;
	private WhereAssignmentsElements pWhereAssignments;
	private WithPartElements pWithPart;
	private AddPartElements pAddPart;
	private AddStatementsElements pAddStatements;
	private FunctionDefinitionElements pFunctionDefinition;
	private FunctionDefinitionBlockElements pFunctionDefinitionBlock;
	private FunctionSignatureElements pFunctionSignature;
	private MacroDefElements pMacroDef;
	private ImportElements pImport;
	private VariableDeclarationBlockElements pVariableDeclarationBlock;
	private VariableDeclarationElements pVariableDeclaration;
	private TypeWithNameElements pTypeWithName;
	private VariableTypedElements pVariableTyped;
	private VariableDeclarationAssignElements pVariableDeclarationAssign;
	private FreeVariableElements pFreeVariable;
	private LocalVariableElements pLocalVariable;
	private TypeExpressionElements pTypeExpression;
	private TypeParameterListElements pTypeParameterList;
	private TypeArgumentsElements pTypeArguments;
	private TypeResultElements pTypeResult;
	private TypePrimaryExpressionElements pTypePrimaryExpression;
	private TypeNameOrFunctionCallElements pTypeNameOrFunctionCall;
	private TupleDefinitionElements pTupleDefinition;
	private TypeLiteralElements pTypeLiteral;
	private StatementElements pStatement;
	private BlockElements pBlock;
	private StatementExpressionElements pStatementExpression;
	private ForStatementElements pForStatement;
	private WhileStatementElements pWhileStatement;
	private DoStatementElements pDoStatement;
	private RepeatStatementElements pRepeatStatement;
	private IterateStatementElements pIterateStatement;
	private BreakStatementElements pBreakStatement;
	private ReturnStatementElements pReturnStatement;
	private IfStatementElements pIfStatement;
	private IfElseStatementElements pIfElseStatement;
	private ExpressionElements pExpression;
	private ExitExpressionElements pExitExpression;
	private ConditionExpressionElements pConditionExpression;
	private OrExpressionElements pOrExpression;
	private AndExpressionElements pAndExpression;
	private InnerProdExpressionElements pInnerProdExpression;
	private OuterProdExpressionElements pOuterProdExpression;
	private HasExpressionElements pHasExpression;
	private CaseExpressionElements pCaseExpression;
	private EqualityExpressionElements pEqualityExpression;
	private RelationalExpressionElements pRelationalExpression;
	private IsExpressionElements pIsExpression;
	private SegmentExpressionElements pSegmentExpression;
	private AdditiveExpressionElements pAdditiveExpression;
	private ExquoExpressionElements pExquoExpression;
	private DivisionExpressionElements pDivisionExpression;
	private QuoExpressionElements pQuoExpression;
	private ModExpressionElements pModExpression;
	private RemExpressionElements pRemExpression;
	private MultiplicativeExpressionElements pMultiplicativeExpression;
	private ExponentExpressionElements pExponentExpression;
	private MapDefinitionElements pMapDefinition;
	private AssignExpressionElements pAssignExpression;
	private PretendExpressionElements pPretendExpression;
	private CoerceExpressionElements pCoerceExpression;
	private HintTypeExpressionElements pHintTypeExpression;
	private EltExpressionElements pEltExpression;
	private ExplicitTypeExpressionElements pExplicitTypeExpression;
	private UnaryExpressionElements pUnaryExpression;
	private PrimaryExpressionElements pPrimaryExpression;
	private PrimaryPrefixElements pPrimaryPrefix;
	private NameOrFunctionCallElements pNameOrFunctionCall;
	private LiteralElements pLiteral;
	private CharacterLiteralElements pCharacterLiteral;
	private BooleanLiteralElements pBooleanLiteral;
	private ListLiteralElements pListLiteral;
	
	private final Grammar grammar;

	@Inject
	public EditorGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.euclideanspace.spad.Editor".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	/// * Copyright 2012 Martin John Baker
	// * 
	// * This file is part of EuclideanSpace.
	// *
	// *  EuclideanSpace is free software: you can redistribute it and/or modify
	// *  it under the terms of the GNU Affero General Public License as published by
	// *  the Free Software Foundation, either version 3 of the License, or
	// *  (at your option) any later version.
	// *
	// *  EuclideanSpace is distributed in the hope that it will be useful,
	// *  but WITHOUT ANY WARRANTY; without even the implied warranty of
	// *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	// *  GNU Affero General Public License for more details.
	// *
	// *  You should have received a copy of the GNU Affero General Public License
	// *  along with EuclideanSpace.  If not, see <http://www.gnu.org/licenses/>.
	// * / / * FriCAS parses SPAD using a type of parser known as a 'Pratt' parser.
	// * In this type of parser each operator has different binding powers for
	// * its left and right. The SPAD parser also has 'special handlers' for
	// * certain operators. In this type of parser there is less distinction made
	// * between expressions and statements, effectively everything is treated as
	// * an expression so in this context, not only are "+" and "*" operators
	// * but also other keywords such as "for" and "return".
	// * 
	// * Here we are using a LL(*) recursive-descent parser generator and this
	// * may not be able to exactly replicate the SPAD parser as described above
	// * 
	// * I have taken this information from s-parser.boot in src/interp
	// * so I suspect that it in valid only for the SPAD interpreter and not
	// * the compiler however I am hoping that this will be a close enough
	// * approximation for this purpose.
	// *
	// * So I will use the LED Table to approximate infix operator precedence
	// * and the NUD Table to approximate prefix operator precedence. So I
	// * have ordered both these tables in 
	// * 
	// * I have ordered the tables low (binds least tightly) to high (binds most tightly) as follows:
	// * 
	// * LED Table - infix operators
	// * ---------------------------
	// * ";", 81, 82, ["parse_SemiColon"]
	// * "|", 108, 111
	// * ",", 110, 111
	// * "when", 112, 190
	// * "otherwise", 119, 190, ["parse_Suffix"]
	// * "where", 121, 104
	// * "==>", "MDEF", 122, 121
	// * "==", "DEF", 122, 121
	// * "=>", 123, 103
	// * ":=", "LET", 125, 124]
	// * "\/", BACKSLASHSLASH 200, 201
	// * "/\", SLASHBACKSLASH 250, 251
	// * "or", 200, 201
	// * "and", 250, 251
	// * "has", 400, 400
	// * "add", 400, 120
	// * "case", 400, 400
	// * "in", 400, 400
	// * "~=", 400, 400
	// * "^=", 400, 400
	// * "=", 400, 400
	// * ">=", 400, 400
	// * "<=", 400, 400
	// * ">>", 400, 400
	// * "<<", 400, 400
	// * ">", 400, 400
	// * "<", 400, 400
	// * "isnt", 400, 400
	// * "is", 400, 400
	// * "..", "SEGMENT", 401, 699, ["parse_Seg"]
	// * "-", 700, 701
	// * "+", 700, 701
	// * "exquo", 800, 801
	// * "/", 800, 801
	// * "quo", 800, 801
	// * "mod", 800, 801
	// * "rem", 800, 801
	// * "*", 800, 801
	// * "^", 901, 900
	// * "**", 901, 900
	// * "+->", 995, 112
	// * "pretend", 995, 996
	// * "@", 996, 997
	// * "::", 996, 997
	// * ":", 996, 997
	// * "!", 1002, 1001
	// * "with", 2000, 400, ["parse_InfixWith"]
	// * "."
	// *
	// * NUD Table - prefix operators
	// * ----------------------------
	// *
	// * "catch", 0, 114
	// * "finally", 0, 114
	// * "then", 0, 114
	// * "else", 0, 114
	// * "|", 0, 190
	// * "import", 120, 0, ["parse_Import"]
	// * "<<", 122, 120, ["parse_LabelExpr"]
	// * ">>"
	// * "if", 130, 0, ["parse_Conditional"]
	// * "try", 130, 0, ["parse_Try"]
	// * "for", 130, 350, ["parse_Loop"
	// * "while", 130, 190, ["parse_Loop"]
	// * "until", 130, 190, ["parse_Loop"]
	// * "repeat", 130, 190, ["parse_Loop"]
	// * "return", 202, 201, ["parse_Return"]
	// * "leave", 202, 201, ["parse_Leave"]
	// * "exit", 202, 201, ["parse_Exit"]
	// * "~", 260, 259, nil
	// * ":", 194, 195
	// * "not", 260, 259, NIL
	// * "has", 400, 400
	// * "=", 400, 700
	// * "-", 701, 700
	// * "add", 900, 120
	// * "#", 999, 998
	// * "'", 999, 999, ["parse_Data"]
	// * "with", 1000, 300, ["parse_With"]
	// * "->", 1001, 1002
	// * "!", 1002, 1001
	// * "unless"
	// * "suchthat"
	// * "from"
	// * "iterate"
	// * "yield"
	// * 
	// * * / / *
	// * Parser starts here
	// * CategoryDef,PackageDef and DomainDef must end with newline to ensure that
	// * only an '@' at the start of a line will be taken as the end.
	// * 
	// * On this line whitespace (WS) is not hidden so is explicitly included.
	// * / Model:
	//	")abbrev" WS (c=CategoryDef | p=PackageDef | d=DomainDef) AT;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//////////// start of lexer rules ///////////////
	/// * ID consists of alpha (upper or lower case) followed by alphanumeric
	// * any other character can stand in for alpha if prefixed by '_'
	// * for instance a multiply function is often named '_*'
	// * IDs can also end with ? or ! where:
	// * '?' indicates a function which returns a boolean value
	// * '!' indicates a function which changes an existing domain value
	// *     (in a mutable domain) * / terminal ID:
	//	("a".."z" | "A".."Z" | "_" .) ("a".."z" | "A".."Z" | "_" . | "0".."9")* "!"? "?"?;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	/// * whitespace on single line overrides default whitespace
	// * does not include newline unless it follows underscore.
	// * I would have liked to do this as follows:
	// * terminal WS : (' '|'\t'|'_'(('\r'|'\n')+))+;
	// * problem: unfortunately use of underscore in this way masks the use of underscore
	// * in ID. We therefore need to remove this type of underscore in a
	// * preprocessor
	// * / terminal WS:
	//	(" " | "\t")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	/// * at least one newline or carriage return character.
	// * This is not included with WS because whitespace is significant in SPAD.
	// * We usually absorb newlines like this: NL+ which absorbs any number of
	// * blank lines and it also supports both the Linux and the Windows forms of
	// * newlines.
	// * / terminal NL:
	//	"\r" | "\n";
	public TerminalRule getNLRule() {
		return (tNL != null) ? tNL : (tNL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NL"));
	} 

	/// * overwriting SL_COMMENTS we do not want Java syntax (//) but spad syntax (--)
	// * This absorbs everything from '--' or '++' to the end of the line (but not
	// * including the newline or carriage return characters)
	// * / //('\r'|'\n')?;
	//terminal SL_COMMENT:
	//	("--" | "++") !("\n" | "\r")*;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	/// * Macro value can be anything until the end of line
	// * Macro is really '==>' but the pre-processor inserts an extra '=' so
	// * that we can distinguish from where ==> is used in 'with' or 'add' parts
	// * It is difficult for a LL(*) parser to handle macros so we want to
	// * substitute the macro in a pre-processor * / terminal MACROVALUE:
	//	"===>" !("\n" | "\r")*;
	public TerminalRule getMACROVALUERule() {
		return (tMACROVALUE != null) ? tMACROVALUE : (tMACROVALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MACROVALUE"));
	} 

	/// * '==>' is used in 'with' or 'add' parts so is not really a macro?
	// * / //terminal MACRO:
	////	'==>'
	////;
	/// * string literals are enclosed in double quotes
	// * / terminal STRING:
	//	"\"" !"\""* "\"";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//// grouping
	/// * ( * / terminal LPAREN:
	//	"(";
	public TerminalRule getLPARENRule() {
		return (tLPAREN != null) ? tLPAREN : (tLPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LPAREN"));
	} 

	/// * ) * / terminal RPAREN:
	//	")";
	public TerminalRule getRPARENRule() {
		return (tRPAREN != null) ? tRPAREN : (tRPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RPAREN"));
	} 

	/// * { * / terminal LBRACE:
	//	"{";
	public TerminalRule getLBRACERule() {
		return (tLBRACE != null) ? tLBRACE : (tLBRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LBRACE"));
	} 

	/// * } * / terminal RBRACE:
	//	"}";
	public TerminalRule getRBRACERule() {
		return (tRBRACE != null) ? tRBRACE : (tRBRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RBRACE"));
	} 

	/// * [ * / terminal LBRACKET:
	//	"[";
	public TerminalRule getLBRACKETRule() {
		return (tLBRACKET != null) ? tLBRACKET : (tLBRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LBRACKET"));
	} 

	/// * ] * / terminal RBRACKET:
	//	"]";
	public TerminalRule getRBRACKETRule() {
		return (tRBRACKET != null) ? tRBRACKET : (tRBRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RBRACKET"));
	} 

	/// *
	//terminal LBANANA '(|';
	//terminal RBANANA '|)';
	//terminal EBRACKET '[__]';
	//terminal EBRACKET2 '[]';
	//terminal EBRACE '{__}';
	//terminal EBRACE2 '{}';
	//terminal LBANANABRACKET '[|';
	//terminal RBANANABRACKET '|]';
	//terminal EBANANABRACKET '[|__|]';
	//terminal EBANANABRACKET2 '[||]';
	//terminal LBANANABRACE '{|';
	//terminal RBANANABRACE '|}';
	//terminal EBANANABRACE '{|__|}';
	//terminal EBANANABRACE2 '{||}'; * / / * << * / terminal OANGLE:
	//	"<<";
	public TerminalRule getOANGLERule() {
		return (tOANGLE != null) ? tOANGLE : (tOANGLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OANGLE"));
	} 

	/// * >> * / terminal CANGLE:
	//	">>";
	public TerminalRule getCANGLERule() {
		return (tCANGLE != null) ? tCANGLE : (tCANGLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CANGLE"));
	} 

	/// *terminal QUOTE "'";
	//terminal BACKQUOTE "`";* / // operators
	/// * ==> * / terminal MDEF:
	//	"==>";
	public TerminalRule getMDEFRule() {
		return (tMDEF != null) ? tMDEF : (tMDEF = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MDEF"));
	} 

	/// * | * / terminal BAR:
	//	"|";
	public TerminalRule getBARRule() {
		return (tBAR != null) ? tBAR : (tBAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BAR"));
	} 

	/// * . * / terminal DOT:
	//	".";
	public TerminalRule getDOTRule() {
		return (tDOT != null) ? tDOT : (tDOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOT"));
	} 

	/// * :: * / terminal COERCE:
	//	"::";
	public TerminalRule getCOERCERule() {
		return (tCOERCE != null) ? tCOERCE : (tCOERCE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COERCE"));
	} 

	/// * : * / terminal COLON:
	//	":";
	public TerminalRule getCOLONRule() {
		return (tCOLON != null) ? tCOLON : (tCOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COLON"));
	} 

	/// * @ * / terminal AT:
	//	"@";
	public TerminalRule getATRule() {
		return (tAT != null) ? tAT : (tAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "AT"));
	} 

	/// * , * / terminal COMMA:
	//	",";
	public TerminalRule getCOMMARule() {
		return (tCOMMA != null) ? tCOMMA : (tCOMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMA"));
	} 

	/// * ; * / terminal SEMICOLON:
	//	";";
	public TerminalRule getSEMICOLONRule() {
		return (tSEMICOLON != null) ? tSEMICOLON : (tSEMICOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SEMICOLON"));
	} 

	/// * ** * / terminal POWER:
	//	"**";
	public TerminalRule getPOWERRule() {
		return (tPOWER != null) ? tPOWER : (tPOWER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "POWER"));
	} 

	/// * * * / terminal TIMES:
	//	"*";
	public TerminalRule getTIMESRule() {
		return (tTIMES != null) ? tTIMES : (tTIMES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TIMES"));
	} 

	/// * + * / terminal PLUS:
	//	"+";
	public TerminalRule getPLUSRule() {
		return (tPLUS != null) ? tPLUS : (tPLUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PLUS"));
	} 

	/// * - * / terminal MINUS:
	//	"-";
	public TerminalRule getMINUSRule() {
		return (tMINUS != null) ? tMINUS : (tMINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MINUS"));
	} 

	/// * < * / terminal LT:
	//	"<";
	public TerminalRule getLTRule() {
		return (tLT != null) ? tLT : (tLT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LT"));
	} 

	/// * > * / terminal GT:
	//	">";
	public TerminalRule getGTRule() {
		return (tGT != null) ? tGT : (tGT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GT"));
	} 

	/// * <= * / terminal LE:
	//	"<=";
	public TerminalRule getLERule() {
		return (tLE != null) ? tLE : (tLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LE"));
	} 

	/// * >= * / terminal GE:
	//	">=";
	public TerminalRule getGERule() {
		return (tGE != null) ? tGE : (tGE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GE"));
	} 

	/// * = * / terminal EQUAL:
	//	"=";
	public TerminalRule getEQUALRule() {
		return (tEQUAL != null) ? tEQUAL : (tEQUAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EQUAL"));
	} 

	/// * ~= * / terminal NOTEQUAL:
	//	"~=";
	public TerminalRule getNOTEQUALRule() {
		return (tNOTEQUAL != null) ? tNOTEQUAL : (tNOTEQUAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NOTEQUAL"));
	} 

	/// * ~ * / terminal TILDE:
	//	"~";
	public TerminalRule getTILDERule() {
		return (tTILDE != null) ? tTILDE : (tTILDE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TILDE"));
	} 

	/// * ^ * / terminal CARAT:
	//	"^";
	public TerminalRule getCARATRule() {
		return (tCARAT != null) ? tCARAT : (tCARAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CARAT"));
	} 

	/// * .. * / terminal SEG:
	//	"..";
	public TerminalRule getSEGRule() {
		return (tSEG != null) ? tSEG : (tSEG = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SEG"));
	} 

	/// * # * / terminal HASH:
	//	"#";
	public TerminalRule getHASHRule() {
		return (tHASH != null) ? tHASH : (tHASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HASH"));
	} 

	/// * & * / terminal AMPERSAND:
	//	"&";
	public TerminalRule getAMPERSANDRule() {
		return (tAMPERSAND != null) ? tAMPERSAND : (tAMPERSAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "AMPERSAND"));
	} 

	/// * $ * / terminal DOLAR:
	//	"$";
	public TerminalRule getDOLARRule() {
		return (tDOLAR != null) ? tDOLAR : (tDOLAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOLAR"));
	} 

	/// * / * / terminal SLASH:
	//	"/";
	public TerminalRule getSLASHRule() {
		return (tSLASH != null) ? tSLASH : (tSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASH"));
	} 

	//terminal BACKSLASH:
	//	"\\";
	public TerminalRule getBACKSLASHRule() {
		return (tBACKSLASH != null) ? tBACKSLASH : (tBACKSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BACKSLASH"));
	} 

	//terminal SLASHSLASH:
	//	"//";
	public TerminalRule getSLASHSLASHRule() {
		return (tSLASHSLASH != null) ? tSLASHSLASH : (tSLASHSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASHSLASH"));
	} 

	//terminal BACKSLASHBACKSLASH:
	//	"\\\\";
	public TerminalRule getBACKSLASHBACKSLASHRule() {
		return (tBACKSLASHBACKSLASH != null) ? tBACKSLASHBACKSLASH : (tBACKSLASHBACKSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BACKSLASHBACKSLASH"));
	} 

	/// * '/\\' outer product or logical and * / terminal SLASHBACKSLASH:
	//	"/\\";
	public TerminalRule getSLASHBACKSLASHRule() {
		return (tSLASHBACKSLASH != null) ? tSLASHBACKSLASH : (tSLASHBACKSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASHBACKSLASH"));
	} 

	/// * \\/ inner product or logical or * / terminal BACKSLASHSLASH:
	//	"\\/";
	public TerminalRule getBACKSLASHSLASHRule() {
		return (tBACKSLASHSLASH != null) ? tBACKSLASHSLASH : (tBACKSLASHSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BACKSLASHSLASH"));
	} 

	/// * '=>' * / terminal EXIT:
	//	"=>";
	public TerminalRule getEXITRule() {
		return (tEXIT != null) ? tEXIT : (tEXIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EXIT"));
	} 

	/// * := * / terminal BECOMES:
	//	":=";
	public TerminalRule getBECOMESRule() {
		return (tBECOMES != null) ? tBECOMES : (tBECOMES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BECOMES"));
	} 

	/// * == * / terminal DEF:
	//	"==";
	public TerminalRule getDEFRule() {
		return (tDEF != null) ? tDEF : (tDEF = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DEF"));
	} 

	/// * -> * / terminal ARROW:
	//	"->";
	public TerminalRule getARROWRule() {
		return (tARROW != null) ? tARROW : (tARROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ARROW"));
	} 

	//terminal LARROW:
	//	"<-";
	public TerminalRule getLARROWRule() {
		return (tLARROW != null) ? tLARROW : (tLARROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LARROW"));
	} 

	/// * +-> * / terminal GIVES:
	//	"+->";
	public TerminalRule getGIVESRule() {
		return (tGIVES != null) ? tGIVES : (tGIVES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GIVES"));
	} 

	/// * % * / terminal PERCENT:
	//	"%";
	public TerminalRule getPERCENTRule() {
		return (tPERCENT != null) ? tPERCENT : (tPERCENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PERCENT"));
	} 

	/// * ... * / terminal ELLIPSIS:
	//	"...";
	public TerminalRule getELLIPSISRule() {
		return (tELLIPSIS != null) ? tELLIPSIS : (tELLIPSIS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ELLIPSIS"));
	} 

	/// * +/ takes the sum of a list * / terminal SUMLIST:
	//	"+/";
	public TerminalRule getSUMLISTRule() {
		return (tSUMLIST != null) ? tSUMLIST : (tSUMLIST = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SUMLIST"));
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 

	//////////// end of lexer rules ///////////////
	/// *
	// * longname and longname2 should both be ID and have the same value. Since the
	// * runtime values can't be checked by the parser this must be checked later.
	// * / CategoryDef hidden(WS, NL, SL_COMMENT):
	//	name="category" shortname=ID longname=ID longname2= / *[CategoryDef]* / ID cp=TypeParameterList? COLON "Category" DEF
	//	(implName=TypeArguments? (w=WithPart? a=AddPart? | wh5=WherePart) | LBRACE NL* implName=TypeArguments (w=WithPart?
	//	a=AddPart? | wh5=WherePart) RBRACE NL* a2=AddPart?);
	public CategoryDefElements getCategoryDefAccess() {
		return (pCategoryDef != null) ? pCategoryDef : (pCategoryDef = new CategoryDefElements());
	}
	
	public ParserRule getCategoryDefRule() {
		return getCategoryDefAccess().getRule();
	}

	/// *
	// * longname and longname2 should both be ID and have the same value. Since the
	// * runtime values can't be checked by the parser this must be checked later.
	// * / PackageDef hidden(WS, NL, SL_COMMENT):
	//	name="package" shortname=ID longname=ID longname2= / *[PackageDef]* / ID cp=TypeParameterList? COLON (exportName=ID DEF
	//	implName=ID (w=WithPart | wh5=WherePart) | w=WithPart (DEF add2=AddPart)?);
	public PackageDefElements getPackageDefAccess() {
		return (pPackageDef != null) ? pPackageDef : (pPackageDef = new PackageDefElements());
	}
	
	public ParserRule getPackageDefRule() {
		return getPackageDefAccess().getRule();
	}

	/// *
	// * longname and longname2 should both be ID and have the same value. Since the
	// * runtime values can't be checked by the parser this must be checked later.
	// * / DomainDef hidden(WS, NL, SL_COMMENT):
	//	name="domain" shortname5=ID longname5=ID longname6= / *[DomainDef]* / ID cp5=TypeParameterList? COLON exportName=ID
	//	cp6=TypeParameterList? DEF implName5=ID? (w=WithPart | wh5=WherePart | a=AddPart);
	public DomainDefElements getDomainDefAccess() {
		return (pDomainDef != null) ? pDomainDef : (pDomainDef = new DomainDefElements());
	}
	
	public ParserRule getDomainDefRule() {
		return getDomainDefAccess().getRule();
	}

	/// *
	// * both category and domain can have 'where' part which holds overall information
	// * such as category/domain parameter information and general macros. This is
	// * followed by export('with') and import ('add') information.
	// * Forms allowed include:
	// * Exports == PlottablePlaneCurveCategory with {
	// * Exports ==> PlottablePlaneCurveCategory with {
	// * Exports ==> with {
	// * / WherePart hidden(WS, SL_COMMENT):
	//	name="where" NL* LBRACE NL* (whereAssig+=WhereAssignments (NL | SEMICOLON)+)* // with part
	//	(longname8=ID ((DEF | MDEF) imp=TypeExpression?)? w8=WithPart)? // add part
	//	((longname9=ID (DEF | MDEF))? (fs=ID LPAREN par2=ID? (COMMA par3+=ID)* RPAREN)? add=AddPart)? RBRACE NL+;
	public WherePartElements getWherePartAccess() {
		return (pWherePart != null) ? pWherePart : (pWherePart = new WherePartElements());
	}
	
	public ParserRule getWherePartRule() {
		return getWherePartAccess().getRule();
	}

	/// * each one must be on a separate line or separated by ';'
	// * need to add name=
	// * / WhereAssignments hidden(WS):
	//	VariableDeclaration | MacroDef | Import;
	public WhereAssignmentsElements getWhereAssignmentsAccess() {
		return (pWhereAssignments != null) ? pWhereAssignments : (pWhereAssignments = new WhereAssignmentsElements());
	}
	
	public ParserRule getWhereAssignmentsRule() {
		return getWhereAssignmentsAccess().getRule();
	}

	/// *
	// * the 'where' part contains a 'with' part which holds export information
	// * such as function signatures (function declarations) but not function definitions.
	// * / WithPart hidden(WS, SL_COMMENT):
	//	name="with" NL* LBRACE NL* (fundec+=VariableDeclaration (NL | SEMICOLON)+)* RBRACE NL*;
	public WithPartElements getWithPartAccess() {
		return (pWithPart != null) ? pWithPart : (pWithPart = new WithPartElements());
	}
	
	public ParserRule getWithPartRule() {
		return getWithPartAccess().getRule();
	}

	/// *
	// * the 'where' part contains a 'add' part which holds function and other
	// * declarations.
	// * / AddPart hidden(WS, SL_COMMENT):
	//	name="add" NL* LBRACE NL* (t+=AddStatements (NL | SEMICOLON)+)* RBRACE NL*;
	public AddPartElements getAddPartAccess() {
		return (pAddPart != null) ? pAddPart : (pAddPart = new AddPartElements());
	}
	
	public ParserRule getAddPartRule() {
		return getAddPartAccess().getRule();
	}

	/// *
	// * The add section of domain or package may contain multiple lines
	// * / AddStatements hidden(WS, SL_COMMENT):
	//	VariableDeclarationAssign | FunctionDefinition | "if" t1= // expression has form 'x has y'
	//	Expression "then" t13=FunctionDefinitionBlock | "else" t14=FunctionDefinitionBlock | MacroDef | Import;
	public AddStatementsElements getAddStatementsAccess() {
		return (pAddStatements != null) ? pAddStatements : (pAddStatements = new AddStatementsElements());
	}
	
	public ParserRule getAddStatementsRule() {
		return getAddStatementsAccess().getRule();
	}

	/// * function definition in add part (called by AddStatements)
	// * has a form like:
	// * name(params) == statement
	// * or, for infix operators,
	// * a = b == statement
	// * or, for multiple statements,
	// * name(params) == {
	// *     statement
	// *     statement
	// * }
	// * some function definitions may be conditional like this:
	// * if % has finiteAggregate then {
	// * ... }
	// * / FunctionDefinition hidden(WS, SL_COMMENT):
	//	par3=FunctionSignature (COLON par4=TypeExpression)? DEF par5=Statement;
	public FunctionDefinitionElements getFunctionDefinitionAccess() {
		return (pFunctionDefinition != null) ? pFunctionDefinition : (pFunctionDefinition = new FunctionDefinitionElements());
	}
	
	public ParserRule getFunctionDefinitionRule() {
		return getFunctionDefinitionAccess().getRule();
	}

	/// *
	// * called by 'AddStatements' rule.
	// * allows more add statements inside:
	// * if a has y then 'more add statements'
	// * / FunctionDefinitionBlock hidden(WS, SL_COMMENT):
	//	fnDecBr=LBRACE NL* (fnDecBk+=FunctionDefinition (NL | SEMICOLON)+ | vars+=VariableDeclarationAssign (NL | SEMICOLON)+
	//	| "if" t1+= // expression has form 'x has y'
	//	Expression "then" t13+=FunctionDefinitionBlock (NL | SEMICOLON)+ | "else" t14+=FunctionDefinitionBlock (NL |
	//	SEMICOLON)+)* RBRACE;
	public FunctionDefinitionBlockElements getFunctionDefinitionBlockAccess() {
		return (pFunctionDefinitionBlock != null) ? pFunctionDefinitionBlock : (pFunctionDefinitionBlock = new FunctionDefinitionBlockElements());
	}
	
	public ParserRule getFunctionDefinitionBlockRule() {
		return getFunctionDefinitionBlockAccess().getRule();
	}

	/// * This is the first part of the function definition without the return type or
	// * the function implementation. Usually the function signature has a form like:
	// * name(params)
	// * We allow a single parameter to be given without brackets:
	// * name param
	// * We also allow some alternative forms to represent infix operators like:
	// * a = b to represent _=(a,b)
	// * or the following (this works but only for % we need it to work for every type)
	// * s:% = t:%
	// * or
	// * a > b to represent _>(a,b)
	// * 0 or 1 can be used as a function signature as a short form of
	// * _0() or _1()
	// * / FunctionSignature hidden(WS, SL_COMMENT):
	//	fnNam=ID LPAREN par2=VariableTyped? (COMMA par3+=VariableTyped)* RPAREN // can't specify '0' or '1' explicitly as this would affect lex
	//	// order
	//	| // fnNam=ID par2=VariableDeclaration causes recursive definition so use:
	//	fnNam=ID par=ID | t4=ID (COLON PERCENT)? //(COLON te1=TypeExpression)?
	//	(b1=EQUAL | b1=LT | b1=GT | b1=LE | b1=GE | b1=PLUS | b1=MINUS | b1=TIMES | b1=SLASH | b1=AMPERSAND | b1=BAR |
	//	b1=CARAT) t5=ID | b3= // allows special form of function signature using '0' or '1'
	//	INT | b2=MINUS t6=ID | b4=TILDE t7=ID | b5="not" t8=ID | b6=HASH t8=ID;
	public FunctionSignatureElements getFunctionSignatureAccess() {
		return (pFunctionSignature != null) ? pFunctionSignature : (pFunctionSignature = new FunctionSignatureElements());
	}
	
	public ParserRule getFunctionSignatureRule() {
		return getFunctionSignatureAccess().getRule();
	}

	/// * macros provide a general textual substitution
	// * there are two forms:
	// * name ==> body
	// * and
	// * name macro == body 	
	// * / //MACRO val=ID NL;
	//MacroDef:
	//	macroname=ID MACROVALUE;
	public MacroDefElements getMacroDefAccess() {
		return (pMacroDef != null) ? pMacroDef : (pMacroDef = new MacroDefElements());
	}
	
	public ParserRule getMacroDefRule() {
		return getMacroDefAccess().getRule();
	}

	/// *
	// * import domain
	// * / Import hidden(WS):
	//	"import" impname+=ID+ (LPAREN par22+=TypeExpression (COMMA par22+=TypeExpression)* RPAREN)?;
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	/// * Variable declaration in where and with sections:
	// * A 'variable' can be simple like:
	// * x:Float
	// * or something more complicated like:
	// * x:Record(newPt: Pt,type:  String)
	// * or it can be a function like:
	// * x:(Float,Integer) -> Float
	// * or it can be conditional like:
	// * if 
	// * / VariableDeclarationBlock hidden(WS, SL_COMMENT):
	//	vardecbr=LBRACE NL* (vardecBlk+=VariableDeclaration (NL | SEMICOLON)+)* RBRACE;
	public VariableDeclarationBlockElements getVariableDeclarationBlockAccess() {
		return (pVariableDeclarationBlock != null) ? pVariableDeclarationBlock : (pVariableDeclarationBlock = new VariableDeclarationBlockElements());
	}
	
	public ParserRule getVariableDeclarationBlockRule() {
		return getVariableDeclarationBlockAccess().getRule();
	}

	/// * Variable declaration in where and with sections:
	// * A 'variable' can be simple like:
	// * x:Float
	// * or something more complicated like:
	// * x:Record(newPt: Pt,type:  String)
	// * or it can be a function like:
	// * x:(Float,Integer) -> Float
	// * or it can be conditional like:
	// * if 
	// * / VariableDeclaration hidden(WS, SL_COMMENT):
	//	("if" t1=Expression "then")? // expression has form 'x has y'
	//	(v1=TypeWithName | v2=VariableDeclarationBlock);
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return (pVariableDeclaration != null) ? pVariableDeclaration : (pVariableDeclaration = new VariableDeclarationElements());
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}

	/// *
	// * This rule is used where a type is expected like:
	// * Float
	// * but it may also have an optional name like:
	// * x:Float
	// * / TypeWithName hidden(WS, SL_COMMENT):
	//	((varName=ID | varNameSt=STRING) (COMMA varName2=ID)? COLON)? typ=TypeExpression;
	public TypeWithNameElements getTypeWithNameAccess() {
		return (pTypeWithName != null) ? pTypeWithName : (pTypeWithName = new TypeWithNameElements());
	}
	
	public ParserRule getTypeWithNameRule() {
		return getTypeWithNameAccess().getRule();
	}

	/// * Variable name with optional type. This is used in function signature
	// * and also by VariableDeclaration:
	// * A 'variable' can be simple like:
	// * x:Float
	// * or something more complicated like:
	// * x:Record(newPt: Pt,type:  String)
	// * or it can be a function like:
	// * x:(Float,Integer) -> Float
	// * we can define multiple variables together:
	// * i,j : Integer
	// * / VariableTyped hidden(WS, SL_COMMENT):
	//	(varName=ID | varNameSt=STRING) //    =>(COMMA t2+=ID)* // multiple declarations in same line
	//	(COLON typ=TypeExpression)?;
	public VariableTypedElements getVariableTypedAccess() {
		return (pVariableTyped != null) ? pVariableTyped : (pVariableTyped = new VariableTypedElements());
	}
	
	public ParserRule getVariableTypedRule() {
		return getVariableTypedAccess().getRule();
	}

	/// * in add part we can declare and assign in same part
	// * such as:
	// * a := 3
	// * a:Integer := 3
	// * a := sin(x)
	// * 
	// * There are two forms of multiple assignment:
	// * a,b,c := 0@Integer
	// * or:
	// * a := b := c := 0@Integer
	// * / VariableDeclarationAssign hidden(WS):
	//	varName= // name of variable
	//	ID // if I just use name=ID then, when the ui program is running, I get:
	//	// Duplicate xxx 'coerce' in yyy
	//	((COMMA t12+=ID)* // multiple declarations in same line
	//	(COLON typ=TypeExpression)? // option to explicitly define type
	//	(BECOMES t4=Expression / * |(LBRACE NL* Expression NL* RBRACE) * /)?) // we need block since we can't always detect continuation after ':='
	//	// but this causes infinite loop
	//	// | (BECOMES t2+=ID)+ BECOMES t4=Expression
	//;
	public VariableDeclarationAssignElements getVariableDeclarationAssignAccess() {
		return (pVariableDeclarationAssign != null) ? pVariableDeclarationAssign : (pVariableDeclarationAssign = new VariableDeclarationAssignElements());
	}
	
	public ParserRule getVariableDeclarationAssignRule() {
		return getVariableDeclarationAssignAccess().getRule();
	}

	/// *
	// * free variable 	allows us to declare a variable that is global 
	// * / FreeVariable hidden(WS):
	//	"free" var=ID;
	public FreeVariableElements getFreeVariableAccess() {
		return (pFreeVariable != null) ? pFreeVariable : (pFreeVariable = new FreeVariableElements());
	}
	
	public ParserRule getFreeVariableRule() {
		return getFreeVariableAccess().getRule();
	}

	/// *
	// * allows us to declare a variable that is not global  
	// * / LocalVariable hidden(WS):
	//	"local" var=ID;
	public LocalVariableElements getLocalVariableAccess() {
		return (pLocalVariable != null) ? pLocalVariable : (pLocalVariable = new LocalVariableElements());
	}
	
	public ParserRule getLocalVariableRule() {
		return getLocalVariableAccess().getRule();
	}

	/// *
	// * This is similar to Expression but known to be of type.
	// * (Expression can also be of type) but if we know that
	// * this is a type we can exclude some possibilities.
	// * 
	// * A 'typeExpression' can be simple like:
	// * Float
	// * or something more complicated like:
	// * Record(newPt: Pt,type:  String)
	// * or it can be a function like:
	// * (Float,Integer) -> Float
	// * 
	// * first we check for a function like: Integer -> Integer
	// * / TypeExpression hidden(WS):
	//	=> (t2=TypeArguments ARROW t3=TypeResult) | TypePrimaryExpression;
	public TypeExpressionElements getTypeExpressionAccess() {
		return (pTypeExpression != null) ? pTypeExpression : (pTypeExpression = new TypeExpressionElements());
	}
	
	public ParserRule getTypeExpressionRule() {
		return getTypeExpressionAccess().getRule();
	}

	/// *
	// * we use a type parameter list for parameters of category, package or domains
	// * Parameter list may be empty '()'.
	// * in this case parameters may be just ID or they may be nameID:typeID
	// * 
	// * examples are:
	// * ()
	// * (String)
	// * (s:String)
	// * (String,Integer)
	// * (s:String,i:Integer)
	// * / TypeParameterList hidden(WS):
	//	tyname=LPAREN par=ID? (COLON par21=TypeExpression)? (COMMA par2+=ID (COLON par22+=TypeExpression)?)* RPAREN;
	public TypeParameterListElements getTypeParameterListAccess() {
		return (pTypeParameterList != null) ? pTypeParameterList : (pTypeParameterList = new TypeParameterListElements());
	}
	
	public ParserRule getTypeParameterListRule() {
		return getTypeParameterListAccess().getRule();
	}

	/// *
	// * we use type arguments for first part of function type, that is
	// * x in x-> y
	// * usually this is enclosed in parenthesis
	// * (x) in (x)-> y
	// * but if x is a single argument (Including Record, Union, etc.) then it does
	// * not need to be in parenthesis.
	// * / TypeArguments hidden(WS):
	//	t=TypeLiteral | t2=PERCENT | t3="Type" | // usually, but not always type arguments are in parenthesis, and empty
	//	// parenthesis are allowed
	//	b1?=LPAREN ((ID COLON)? t4=TypeExpression)? (COMMA (ID COLON)? t16+=TypeExpression)* RPAREN | t5="Record" LPAREN
	//	t6=TypeExpression (COLON t22+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN |
	//	t9="Union" LPAREN t10=TypeExpression (COLON t25+=TypeExpression)? (COMMA t24+=TypeExpression (COLON
	//	t26+=TypeExpression)?)* RPAREN | t11="Join" LPAREN t12=TypeExpression (COMMA t13+=TypeExpression)* RPAREN |
	//	t15=TypeNameOrFunctionCall;
	public TypeArgumentsElements getTypeArgumentsAccess() {
		return (pTypeArguments != null) ? pTypeArguments : (pTypeArguments = new TypeArgumentsElements());
	}
	
	public ParserRule getTypeArgumentsRule() {
		return getTypeArgumentsAccess().getRule();
	}

	/// *
	// * we use type arguments for final part of function type, that is
	// * y in x-> y
	// * / TypeResult hidden(WS):
	//	t=TypeLiteral | t2=PERCENT | tyname="Type" | // | LPAREN t4=TypePrimaryExpression ( COMMA t16 += TypePrimaryExpression)* RPAREN
	//	tyname="Record" LPAREN t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON
	//	t23+=TypeExpression)?)* RPAREN | tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
	//	t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | tyname="Join" LPAREN t12=TypeExpression (COMMA
	//	t13+=TypeExpression)* RPAREN | t15=TypeNameOrFunctionCall;
	public TypeResultElements getTypeResultAccess() {
		return (pTypeResult != null) ? pTypeResult : (pTypeResult = new TypeResultElements());
	}
	
	public ParserRule getTypeResultRule() {
		return getTypeResultAccess().getRule();
	}

	//TypePrimaryExpression hidden(WS):
	//	TypeLiteral // 'Type' is top of the category hierarchy
	//	// 'Lisp' is used for native lisp function calls such as Say$Lisp
	//	| {TypePrimaryExpression} t32=PERCENT | {TypePrimaryExpression} tyname="Type" | {TypePrimaryExpression} tyname="Lisp" |
	//	{TypePrimaryExpression} LPAREN t5=TypeExpression RPAREN | {TypePrimaryExpression} tyname="Record" LPAREN
	//	t7=TypeExpression (COLON t8+=TypeExpression)? (COMMA t21+=TypeExpression (COLON t23+=TypeExpression)?)* RPAREN |
	//	{TypePrimaryExpression} tyname="Union" LPAREN t10=TypeExpression (COLON t11+=TypeExpression)? (COMMA
	//	t24+=TypeExpression (COLON t26+=TypeExpression)?)* RPAREN | {TypePrimaryExpression} tyname="Join" LPAREN
	//	t13=TypeExpression (COMMA t14+=TypeExpression)* RPAREN | TypeNameOrFunctionCall | => TupleDefinition;
	public TypePrimaryExpressionElements getTypePrimaryExpressionAccess() {
		return (pTypePrimaryExpression != null) ? pTypePrimaryExpression : (pTypePrimaryExpression = new TypePrimaryExpressionElements());
	}
	
	public ParserRule getTypePrimaryExpressionRule() {
		return getTypePrimaryExpressionAccess().getRule();
	}

	/// * This rule will match:
	// * Float - an ID representation of a type
	// * List(Float) - a type function call
	// * List Float - a non-parenthesis form if only one parameter
	// * 
	// * The second two forms are known as a parameterised type or
	// * functor (not necessarily a true
	// * functor since it may not obey the axioms of a functor).
	// * If there is only one parameter then the parenthesis are optional
	// * / TypeNameOrFunctionCall hidden(WS):
	//	tfnname=ID ((LPAREN (ID COLON)? t4=TypeExpression? (COMMA (ID COLON)? t25+=TypeExpression)* RPAREN) // optional curried function:
	//	(LPAREN t44+=StatementExpression? (COMMA t45+=Expression)* RPAREN)* // option of no parenthesis for single parameter
	//	| => t6=TypePrimaryExpression)?;
	public TypeNameOrFunctionCallElements getTypeNameOrFunctionCallAccess() {
		return (pTypeNameOrFunctionCall != null) ? pTypeNameOrFunctionCall : (pTypeNameOrFunctionCall = new TypeNameOrFunctionCallElements());
	}
	
	public ParserRule getTypeNameOrFunctionCallRule() {
		return getTypeNameOrFunctionCallAccess().getRule();
	}

	/// * This has a form like: (Integer,Float,String)
	// * like an array where each entry can be of a different type
	// * / TupleDefinition hidden(WS):
	//	LPAREN t4=TypeExpression (COMMA t25+=TypeExpression)* RPAREN;
	public TupleDefinitionElements getTupleDefinitionAccess() {
		return (pTupleDefinition != null) ? pTupleDefinition : (pTupleDefinition = new TupleDefinitionElements());
	}
	
	public ParserRule getTupleDefinitionRule() {
		return getTupleDefinitionAccess().getRule();
	}

	/// * Since SPAD supports dependent types then numbers and strings can occur here.
	// * Outstanding issues:
	// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
	// *    and convert to float literal
	// * 2) We need to be able to recognise exponent notation for floats
	// * 3) Integers without '-' prefix can be converted to PI or NNI
	// * 4) need to add hex or octal notation for integers (0xhhhh)
	// * 5) String and Character literals need to have backslash "\" doubled to
	// *    "\\" otherwise xtext will interpret backslash as an escape character.
	// * 6) values following immediately after string literal such as "abc"d should
	// *    represent an implied concat: concat("abc",d)
	// * / TypeLiteral hidden(WS):
	//	t1=INT | t22=STRING | // t3=FloatLiteral |
	//	t34=CharacterLiteral | t35=BooleanLiteral;
	public TypeLiteralElements getTypeLiteralAccess() {
		return (pTypeLiteral != null) ? pTypeLiteral : (pTypeLiteral = new TypeLiteralElements());
	}
	
	public ParserRule getTypeLiteralRule() {
		return getTypeLiteralAccess().getRule();
	}

	/// * In FunctionDefinition the algorithm is defined by a sequence of the
	// * following statements:
	// * / Statement hidden(WS, SL_COMMENT):
	//	s1=Block | s3=StatementExpression | // 'if' can occur in an expression or in
	//	// a statement so we use '=>' to choose
	//	// expression if there is any ambiguity
	//	s4=IfStatement | s4b=IfElseStatement | //    s4c=IfThenStatement |
	//	s5=WhileStatement | s6=DoStatement | s7=ForStatement | s8=BreakStatement | s12=RepeatStatement | s9=IterateStatement | //    s11= ContinueStatement|
	//	s10=ReturnStatement;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	/// * allows multiple statements which are grouped by wrapping in curly brackets * / Block hidden(WS, SL_COMMENT):
	//	stname=LBRACE NL* (statemBl+=Statement (NL | SEMICOLON)+)* RBRACE;
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	/// *
	// * Gives a value or assigns a value to a variable or does conditional exit
	// * 
	// * examples:
	// * x
	// * x:Int
	// * x,y:INT -- multiple assignment
	// * x:Int := 3
	// * 
	// * x=y => 3
	// * / StatementExpression hidden(WS, SL_COMMENT): //(ID COMMA)* // allow multiple assignment
	//	t= // was Expression but changed so that 'if' statement
	//	ConditionExpression // does not clash with if-then-else expression
	//	//    (COLON t2=TypeExpression)?
	//	//    (BECOMES t3=Expression (BECOMES t33+=Expression)*)?
	//	(BECOMES t5=Block)? // breaks out of a block if predicate before '=>' is true then program
	//	// control leaves the block.
	//	// Put it here so that it can only occur at the top level of an expression.
	//	// if inside some complicated expression then it must be terminated with ';'.
	//	(EXIT t4=Statement)?;
	public StatementExpressionElements getStatementExpressionAccess() {
		return (pStatementExpression != null) ? pStatementExpression : (pStatementExpression = new StatementExpressionElements());
	}
	
	public ParserRule getStatementExpressionRule() {
		return getStatementExpressionAccess().getRule();
	}

	/// *
	// * for i in n..m repeat ... is 1
	// * for i in n..m by s repeat ...
	// * for i in list repeat ...
	// * for i in list for i in 1..length() repeat ...
	// * for i in list for i in 1.. repeat ...
	// * for j in n..m repeat loopBody
	// * for j in n..m | odd? j repeat
	// * 
	// * To Do
	// * -----
	// * As a temporary measure we check for '..' as a suffix operator
	// * here, but we should really put this into expression?
	// * 
	// * We need to allow conditions using BAR '|'
	// * / ForStatement hidden(WS, SL_COMMENT):
	//	"for" (stname=ID "in" t1=Expression SEG? //(=> '..' t2=Expression)?
	//	("by" by1=Expression)? //       (=> BAR t2=PredicateOr)? // condition
	//	("for" stname2+=ID "in" t2+=Expression ("by" by2+=Expression)? SEG?)* ("while" t2+=Expression)*) "repeat" NL? s1= //('is' s2=Statement)?
	//	Statement;
	public ForStatementElements getForStatementAccess() {
		return (pForStatement != null) ? pForStatement : (pForStatement = new ForStatementElements());
	}
	
	public ParserRule getForStatementRule() {
		return getForStatementAccess().getRule();
	}

	/// *
	// * while BoolExpr repeat loopBody
	// * / WhileStatement hidden(WS, SL_COMMENT):
	//	stname="while" t2= / *PredicateOr* / Expression "repeat" NL? s1=Statement;
	public WhileStatementElements getWhileStatementAccess() {
		return (pWhileStatement != null) ? pWhileStatement : (pWhileStatement = new WhileStatementElements());
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}

	/// *
	// *  do loopBody while BoolExpr
	// * / DoStatement hidden(WS, SL_COMMENT):
	//	stname="do" s1=Statement "while" NL? t2= / *PredicateOr* / Expression;
	public DoStatementElements getDoStatementAccess() {
		return (pDoStatement != null) ? pDoStatement : (pDoStatement = new DoStatementElements());
	}
	
	public ParserRule getDoStatementRule() {
		return getDoStatementAccess().getRule();
	}

	/// *
	// *  will repeat until we jump out. For instance by calling return.
	// * / RepeatStatement hidden(WS, SL_COMMENT):
	//	stname="repeat" s1=Statement;
	public RepeatStatementElements getRepeatStatementAccess() {
		return (pRepeatStatement != null) ? pRepeatStatement : (pRepeatStatement = new RepeatStatementElements());
	}
	
	public ParserRule getRepeatStatementRule() {
		return getRepeatStatementAccess().getRule();
	}

	/// *
	// * iterate ...
	// * skips over the remainder of a loop 
	// * / IterateStatement hidden(WS, SL_COMMENT):
	//	stname="iterate";
	public IterateStatementElements getIterateStatementAccess() {
		return (pIterateStatement != null) ? pIterateStatement : (pIterateStatement = new IterateStatementElements());
	}
	
	public ParserRule getIterateStatementRule() {
		return getIterateStatementAccess().getRule();
	}

	/// *
	// * break 	leave current loop 
	// * / BreakStatement hidden(WS, SL_COMMENT):
	//	stname="break";
	public BreakStatementElements getBreakStatementAccess() {
		return (pBreakStatement != null) ? pBreakStatement : (pBreakStatement = new BreakStatementElements());
	}
	
	public ParserRule getBreakStatementRule() {
		return getBreakStatementAccess().getRule();
	}

	/// *
	// * return 	leave current function 
	// * / ReturnStatement hidden(WS):
	//	stname="return" t2=Expression;
	public ReturnStatementElements getReturnStatementAccess() {
		return (pReturnStatement != null) ? pReturnStatement : (pReturnStatement = new ReturnStatementElements());
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	/// * 'if' statement allows program flow to be switched
	// * forms:
	// * if boolean then
	// * if equation then
	// * if ... not ... and ...or ... then
	// * if ... then ... else ...
	// * note1:
	// * if ... then ... else ... always returns a value so we can use this
	// * on the right hand side of an assignment
	// * note2:
	// * since there is an explicit 'then' keyword there is no need to put
	// * the condition in brackets
	// * 	
	// * examples:
	// * a:= if x >0 then x else -x
	// * if R has Field then ... 	  	 
	// * if myUnion case mtType then ...
	// * 
	// * we also need to allow a form like this:
	// * if x >0 {
	// *   then x
	// *   else -x
	// * }
	// * 
	// * also this form (this requires IfElseStatement rule):
	// * if x >0 then {
	// *   x
	// * }
	// * else {
	// *   -x
	// * }
	// * / IfStatement hidden(WS, SL_COMMENT):
	//	"if" t2=Expression ("then" s1=Statement ("else" s2=Statement)? //  'if' t2=ConditionExpression
	//	| b?=LBRACE NL+ "then" s11=Statement NL* ("else" s12=Statement NL*)? RBRACE);
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//IfElseStatement hidden(WS, SL_COMMENT):
	//	"else" s2=Statement;
	public IfElseStatementElements getIfElseStatementAccess() {
		return (pIfElseStatement != null) ? pIfElseStatement : (pIfElseStatement = new IfElseStatementElements());
	}
	
	public ParserRule getIfElseStatementRule() {
		return getIfElseStatementAccess().getRule();
	}

	/////////////// Expression syntax follows //////////////
	/// * This is the top level for expressions
	// * 
	// * This level handles special cases such as:
	// * if x then y else z
	// * (x,y) +-> z
	// * 
	// * We can consider expressions as elements of statements 
	// * expressions contain no newlines unless preceded by underscore
	// * (which is handled by WS)
	// * / Expression returns Expr hidden(WS, SL_COMMENT):
	//	ifname="if" ifpred=Expression "then" thenexp=Expression "else" elseexp=Expression //  | LPAREN t24=ConditionExpression (COMMA t25+=ConditionExpression)+ RPAREN (COLON rightType2 =TypeExpression)? GIVES ConditionExpression
	//	| ExitExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	/// * 
	// * condition '=>' expr1 ';' expr2
	// * / ExitExpression returns Expr hidden(WS, SL_COMMENT):
	//	ConditionExpression ({ExitExpression.left=current} op=EXIT right=ConditionExpression SEMICOLON
	//	r2=ConditionExpression)*;
	public ExitExpressionElements getExitExpressionAccess() {
		return (pExitExpression != null) ? pExitExpression : (pExitExpression = new ExitExpressionElements());
	}
	
	public ParserRule getExitExpressionRule() {
		return getExitExpressionAccess().getRule();
	}

	/// * 
	// * BAR "|" precedence: 108, 111
	// * / ConditionExpression returns Expr hidden(WS, SL_COMMENT):
	//	OrExpression ({ConditionExpression.left=current} op=BAR right=OrExpression)*;
	public ConditionExpressionElements getConditionExpressionAccess() {
		return (pConditionExpression != null) ? pConditionExpression : (pConditionExpression = new ConditionExpressionElements());
	}
	
	public ParserRule getConditionExpressionRule() {
		return getConditionExpressionAccess().getRule();
	}

	/// * 
	// * COMMA"," precedence: 110, 111
	// * / //CommaExpression returns Expr hidden(WS,SL_COMMENT):
	////  ConditionalAndExpression
	////  ({ConditionExpression.left=current} op=BAR right = ConditionalAndExpression )*
	////;
	/// *
	// * There is also another rule that looks for 'or' which is PredicateOr,
	// * this version is used in a general expression and the other version is
	// * used when we know we have a predicate.
	// * "or", precedence: 200, 201
	// * / OrExpression returns Expr hidden(WS, SL_COMMENT):
	//	AndExpression ({OrExpression.left=current} op="or" right=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return (pOrExpression != null) ? pOrExpression : (pOrExpression = new OrExpressionElements());
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	/// *
	// * There is also another rule that looks for 'and' which is PredicateAnd,
	// * this version is used in a general expression and the other version is
	// * used when we know we have a predicate.
	// * "and", precedence: 250, 251
	// * / AndExpression returns Expr hidden(WS, SL_COMMENT):
	//	InnerProdExpression ({AndExpression.left=current} op="and" right=InnerProdExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return (pAndExpression != null) ? pAndExpression : (pAndExpression = new AndExpressionElements());
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	/// *
	// * This has multiple uses such as inner product and logical or.
	// * 
	// * "\/", BACKSLASHSLASH precedence: 200, 201
	// * 
	// * the backslash is duplicated here because it is the escape character for
	// * strings, it will not be duplicated when used. 
	// * / InnerProdExpression returns Expr hidden(WS, SL_COMMENT):
	//	OuterProdExpression ({InnerProdExpression.left=current} op=BACKSLASHSLASH right=OuterProdExpression)*;
	public InnerProdExpressionElements getInnerProdExpressionAccess() {
		return (pInnerProdExpression != null) ? pInnerProdExpression : (pInnerProdExpression = new InnerProdExpressionElements());
	}
	
	public ParserRule getInnerProdExpressionRule() {
		return getInnerProdExpressionAccess().getRule();
	}

	/// *
	// * This has multiple uses such as outer product and logical and.
	// * 
	// * "/\", SLASHBACKSLASH precedence: 250, 251
	// * 
	// * the backslash is duplicated here because it is the escape character for
	// * strings, it will not be duplicated when used. 
	// * / OuterProdExpression returns Expr hidden(WS, SL_COMMENT):
	//	HasExpression ({OuterProdExpression.left=current} op=SLASHBACKSLASH right=HasExpression)*;
	public OuterProdExpressionElements getOuterProdExpressionAccess() {
		return (pOuterProdExpression != null) ? pOuterProdExpression : (pOuterProdExpression = new OuterProdExpressionElements());
	}
	
	public ParserRule getOuterProdExpressionRule() {
		return getOuterProdExpressionAccess().getRule();
	}

	/// * Predicate which returns true if preceding value is of a given type
	// * example:
	// * if R has Field then ..
	// * 
	// * "has", precedence: 400, 400
	// * / HasExpression returns Expr hidden(WS, SL_COMMENT):
	//	CaseExpression ({HasExpression.left=current} op="has" rightType=TypeExpression)*;
	public HasExpressionElements getHasExpressionAccess() {
		return (pHasExpression != null) ? pHasExpression : (pHasExpression = new HasExpressionElements());
	}
	
	public ParserRule getHasExpressionRule() {
		return getHasExpressionAccess().getRule();
	}

	/// * Select from Union values 
	// * example:
	// * if myUnion case mtType then ... 	
	// * 
	// * "case", precedence: 400, 400
	// * / CaseExpression returns Expr hidden(WS, SL_COMMENT):
	//	EqualityExpression ({CaseExpression.left=current} op="case" right=EqualityExpression)?;
	public CaseExpressionElements getCaseExpressionAccess() {
		return (pCaseExpression != null) ? pCaseExpression : (pCaseExpression = new CaseExpressionElements());
	}
	
	public ParserRule getCaseExpressionRule() {
		return getCaseExpressionAccess().getRule();
	}

	/// * used in list comprehension
	// * 
	// * "in", precedence: 400, 400
	// * / / *InExpression returns Expr hidden(WS,SL_COMMENT):
	//  RelationalExpression
	//  ( {CaseExpression.left=current} op='in' right = RelationalExpression)?
	//;* / / * 
	// * "~=", precedence: 400, 400
	// * "^=", precedence: 400, 400
	// * "=", precedence: 400, 400
	// * / EqualityExpression returns Expr hidden(WS, SL_COMMENT):
	//	RelationalExpression // ambiguous because EQ can be in top level expression
	//	({EqualityExpression.left=current} (op=EQUAL | op=NOTEQUAL | op="^=") (DOLAR te=ID)? right=RelationalExpression)*;
	public EqualityExpressionElements getEqualityExpressionAccess() {
		return (pEqualityExpression != null) ? pEqualityExpression : (pEqualityExpression = new EqualityExpressionElements());
	}
	
	public ParserRule getEqualityExpressionRule() {
		return getEqualityExpressionAccess().getRule();
	}

	/// * 
	// * ">=", precedence: 400, 400
	// * "<=", precedence: 400, 400
	// * ">>", precedence: 400, 400
	// * "<<", precedence: 400, 400
	// * ">", precedence: 400, 400
	// * "<", precedence: 400, 400
	// * / RelationalExpression returns Expr hidden(WS, SL_COMMENT):
	//	IsExpression ({RelationalExpression.left=current} (op=LT | op=GT | op=LE | op=GE) right=IsExpression)?;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return (pRelationalExpression != null) ? pRelationalExpression : (pRelationalExpression = new RelationalExpressionElements());
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	/// * 
	// * 
	// * "isnt", precedence: 400, 400
	// * "is", precedence: 400, 400
	// * / IsExpression returns Expr hidden(WS, SL_COMMENT):
	//	SegmentExpression ({IsExpression.left=current} (op="is" | op="isnt") rightType=TypeExpression)*;
	public IsExpressionElements getIsExpressionAccess() {
		return (pIsExpression != null) ? pIsExpression : (pIsExpression = new IsExpressionElements());
	}
	
	public ParserRule getIsExpressionRule() {
		return getIsExpressionAccess().getRule();
	}

	/// * 
	// * this is used to indicate a range:
	// * 1..4 means the range from 1 to 4
	// * 1.. means the range from 1 to infinity. This is used in cases where
	// * no top bounds is necessary, when the end point is determined by other
	// * means.
	// * "..", "SEGMENT",  precedence: 401, 699, ["parse_Seg"]
	// * / SegmentExpression returns Expr hidden(WS, SL_COMMENT):
	//	AdditiveExpression ({SegmentExpression.left=current} op=SEG right=AdditiveExpression)*;
	public SegmentExpressionElements getSegmentExpressionAccess() {
		return (pSegmentExpression != null) ? pSegmentExpression : (pSegmentExpression = new SegmentExpressionElements());
	}
	
	public ParserRule getSegmentExpressionRule() {
		return getSegmentExpressionAccess().getRule();
	}

	/// *
	// * add expression
	// * we include both '+' and '-' in the same case as this allows a
	// * multiple sequence like:
	// * a + b + c - d + e -f
	// * 
	// * "-",  precedence: 700, 701
	// * "+",  precedence: 700, 701
	// * / AdditiveExpression returns Expr hidden(WS, SL_COMMENT):
	//	ExquoExpression ({AdditiveExpression.left=current} (op=PLUS | op=MINUS) right=ExquoExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return (pAdditiveExpression != null) ? pAdditiveExpression : (pAdditiveExpression = new AdditiveExpressionElements());
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	/// * 
	// * "exquo",  precedence: 800, 801
	// * / ExquoExpression returns Expr hidden(WS, SL_COMMENT):
	//	DivisionExpression ({ExquoExpression.left=current} op="exquo" right=DivisionExpression)*;
	public ExquoExpressionElements getExquoExpressionAccess() {
		return (pExquoExpression != null) ? pExquoExpression : (pExquoExpression = new ExquoExpressionElements());
	}
	
	public ParserRule getExquoExpressionRule() {
		return getExquoExpressionAccess().getRule();
	}

	/// *
	// * division expression
	// * "/",  precedence: 800, 801
	// * / DivisionExpression returns Expr hidden(WS, SL_COMMENT):
	//	QuoExpression ({DivisionExpression.left=current} op=SLASH right=QuoExpression)*;
	public DivisionExpressionElements getDivisionExpressionAccess() {
		return (pDivisionExpression != null) ? pDivisionExpression : (pDivisionExpression = new DivisionExpressionElements());
	}
	
	public ParserRule getDivisionExpressionRule() {
		return getDivisionExpressionAccess().getRule();
	}

	/// * 
	// *"quo",  precedence: 800, 801
	// * / QuoExpression returns Expr hidden(WS, SL_COMMENT):
	//	ModExpression ({QuoExpression.left=current} op="quo" right=ModExpression)*;
	public QuoExpressionElements getQuoExpressionAccess() {
		return (pQuoExpression != null) ? pQuoExpression : (pQuoExpression = new QuoExpressionElements());
	}
	
	public ParserRule getQuoExpressionRule() {
		return getQuoExpressionAccess().getRule();
	}

	/// * 
	// *"mod",  precedence: 800, 801
	// * / ModExpression returns Expr hidden(WS, SL_COMMENT):
	//	RemExpression ({ModExpression.left=current} op="mod" right=RemExpression)*;
	public ModExpressionElements getModExpressionAccess() {
		return (pModExpression != null) ? pModExpression : (pModExpression = new ModExpressionElements());
	}
	
	public ParserRule getModExpressionRule() {
		return getModExpressionAccess().getRule();
	}

	/// * 
	// *"rem", precedence: 800, 801
	// * / RemExpression returns Expr hidden(WS, SL_COMMENT):
	//	MultiplicativeExpression ({RemExpression.left=current} op="rem" right=MultiplicativeExpression)*;
	public RemExpressionElements getRemExpressionAccess() {
		return (pRemExpression != null) ? pRemExpression : (pRemExpression = new RemExpressionElements());
	}
	
	public ParserRule getRemExpressionRule() {
		return getRemExpressionAccess().getRule();
	}

	/// *
	// * multiplication expression
	// * a * b * c
	// * 
	// * "*", precedence: 800, 801
	// * / MultiplicativeExpression returns Expr hidden(WS, SL_COMMENT):
	//	ExponentExpression ({MultiplicativeExpression.left=current} op=TIMES right=ExponentExpression)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return (pMultiplicativeExpression != null) ? pMultiplicativeExpression : (pMultiplicativeExpression = new MultiplicativeExpressionElements());
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}

	/// * 
	// *
	// * "^", precedence: 901, 900
	// * "**", precedence: 901, 900
	// * / ExponentExpression returns Expr hidden(WS, SL_COMMENT):
	//	MapDefinition ({ExponentExpression.left=current} (op=CARAT | op=POWER) right=MapDefinition)*;
	public ExponentExpressionElements getExponentExpressionAccess() {
		return (pExponentExpression != null) ? pExponentExpression : (pExponentExpression = new ExponentExpressionElements());
	}
	
	public ParserRule getExponentExpressionRule() {
		return getExponentExpressionAccess().getRule();
	}

	/// * Map or Lambda expression
	// * var +-> function 	
	// * 
	// * +-> is an infix operator meaning 'maps-to'
	// * It can be used to create a function literal (an anonymous function), so
	// * instead of:
	// * myFunct(x:Type):Type == if x >0 then x else -x
	// * we can have forms such as:
	// * x +-> if x >0 then x else -x
	// * or:
	// * (x,y) +-> if x >0 then y else -x
	// * 
	// * fricas compatibility:
	// * "+->", precedence: 995, 112
	// * / MapDefinition returns Expr hidden(WS, SL_COMMENT): //  (PretendExpression | LPAREN PretendExpression (COMMA t25+=PretendExpression)+ RPAREN) (COLON rightType2 =TypeExpression)?
	//	AssignExpression ({MapDefinition.left=current} op=GIVES right=AssignExpression)*;
	public MapDefinitionElements getMapDefinitionAccess() {
		return (pMapDefinition != null) ? pMapDefinition : (pMapDefinition = new MapDefinitionElements());
	}
	
	public ParserRule getMapDefinitionRule() {
		return getMapDefinitionAccess().getRule();
	}

	/// *
	// * an assign expression like this:
	// * x := y
	// * can also be an inner assign like this:
	// * x := (y := z)
	// * or just:
	// *  x := y := z
	// * 
	// * right is expression to allow forms like
	// * x := if y<0 then -y else y
	// * / AssignExpression returns Expr hidden(WS, SL_COMMENT):
	//	PretendExpression ({AssignExpression.left=current} op=BECOMES (right=PretendExpression | ifname="if"
	//	ifpred=ConditionExpression "then" thenexp=ConditionExpression "else" elseexp=PretendExpression))*;
	public AssignExpressionElements getAssignExpressionAccess() {
		return (pAssignExpression != null) ? pAssignExpression : (pAssignExpression = new AssignExpressionElements());
	}
	
	public ParserRule getAssignExpressionRule() {
		return getAssignExpressionAccess().getRule();
	}

	/// *
	// * pretend Type: treat one type as another,
	// * only works if they have the same internal structure.
	// * 
	// * Not very safe and should be avoided, if possible, unfortunately
	// * its not always possible to avoid.
	// * 
	// * "pretend", precedence: 995, 996
	// * / PretendExpression returns Expr hidden(WS, SL_COMMENT):
	//	CoerceExpression ({PretendExpression.left=current} op="pretend" rightType=TypeExpression)*;
	public PretendExpressionElements getPretendExpressionAccess() {
		return (pPretendExpression != null) ? pPretendExpression : (pPretendExpression = new PretendExpressionElements());
	}
	
	public ParserRule getPretendExpressionRule() {
		return getPretendExpressionAccess().getRule();
	}

	/// * 
	// * "::", precedence: 996, 997
	// * 
	// * although '::' and '@' apparently have the same precidence we want
	// * '@' to bind more tightly than '::'. As we can see in the following example:
	// * "dictionary"@String :: OutputForm.
	// * / CoerceExpression returns Expr hidden(WS, SL_COMMENT):
	//	HintTypeExpression ({CoerceExpression.left=current} op=COERCE rightType=TypeExpression)*;
	public CoerceExpressionElements getCoerceExpressionAccess() {
		return (pCoerceExpression != null) ? pCoerceExpression : (pCoerceExpression = new CoerceExpressionElements());
	}
	
	public ParserRule getCoerceExpressionRule() {
		return getCoerceExpressionAccess().getRule();
	}

	/// * 
	// * "@", precedence: 996, 997
	// * / HintTypeExpression returns Expr hidden(WS, SL_COMMENT):
	//	EltExpression ({HintTypeExpression.left=current} op=AT rightType=TypeExpression)?;
	public HintTypeExpressionElements getHintTypeExpressionAccess() {
		return (pHintTypeExpression != null) ? pHintTypeExpression : (pHintTypeExpression = new HintTypeExpressionElements());
	}
	
	public ParserRule getHintTypeExpressionRule() {
		return getHintTypeExpressionAccess().getRule();
	}

	/// * We treat these as part of the language
	// * : indicates type
	// * ! is part of name to indicate mutable
	// * 
	// * ":", precedence: 996, 997
	// * "!", precedence: 1002, 1001
	// *
	// * / / *BangExpression returns Expr hidden(WS,SL_COMMENT):
	//  EqualityExpression
	//  ({AndExpression.left=current} op=AMPERSAND right = EqualityExpression)*
	//;* / / * 
	// * "with",  precedence: 2000, 400, ["parse_InfixWith"]
	// *
	// * / / *WithExpression returns Expr hidden(WS,SL_COMMENT):
	//  EqualityExpression
	//  ({AndExpression.left=current} op='with' right = EqualityExpression)*
	//;* / / * Elt is Lisp terminology for the use of '.' to select parameters
	// * the left expression is something that has selectable elements such as
	// * a list, array, string, Record or union, the right element should be a
	// * non-negative integer.
	// * / EltExpression returns Expr hidden(WS, SL_COMMENT):
	//	ExplicitTypeExpression ({EltExpression.left=current} op=DOT right=ExplicitTypeExpression)*;
	public EltExpressionElements getEltExpressionAccess() {
		return (pEltExpression != null) ? pEltExpression : (pEltExpression = new EltExpressionElements());
	}
	
	public ParserRule getEltExpressionRule() {
		return getEltExpressionAccess().getRule();
	}

	//////////////// unary expressions ////////////////////
	/// * 
	// * '$'
	// * / ExplicitTypeExpression returns Expr hidden(WS, SL_COMMENT):
	//	UnaryExpression ({ExplicitTypeExpression.left=current} op=DOLAR rightType=TypeExpression)?;
	public ExplicitTypeExpressionElements getExplicitTypeExpressionAccess() {
		return (pExplicitTypeExpression != null) ? pExplicitTypeExpression : (pExplicitTypeExpression = new ExplicitTypeExpressionElements());
	}
	
	public ParserRule getExplicitTypeExpressionRule() {
		return getExplicitTypeExpressionAccess().getRule();
	}

	/// * UnaryExpression
	// * "~" TILDE : precedence  260, 259, nil
	// * ":" COLON : precedence  194, 195
	// * "-" MINUS : precedence  701, 700
	// * "#" HASH : precedence  999, 998
	// * "'" : precedence  999, 999, ["parse_Data"]
	// * / UnaryExpression returns Expr hidden(WS, SL_COMMENT):
	//	PrimaryExpression //  ({UnaryExpression} uop=COLON expr=UnaryExpression) |
	//	| {UnaryExpression} uop=TILDE expr=UnaryExpression | {UnaryExpression} uop=MINUS expr=UnaryExpression |
	//	{UnaryExpression} uop=HASH expr=UnaryExpression | {UnaryExpression} uop="not" expr=PrimaryExpression |
	//	{UnaryExpression} uop=SUMLIST expr=PrimaryExpression | e2=PERCENT | e3="Type" | e5="Record" LPAREN e6=TypeExpression
	//	(COLON e22+=TypeExpression)? (COMMA e21+=TypeExpression (COLON e23+=TypeExpression)?)* RPAREN | e9="Union" LPAREN
	//	e10=TypeExpression (COLON e25+=TypeExpression)? (COMMA e24+=TypeExpression (COLON e26+=TypeExpression)?)* RPAREN |
	//	e11="Join" LPAREN e12=TypeExpression (COMMA e13+=TypeExpression)* RPAREN;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return (pUnaryExpression != null) ? pUnaryExpression : (pUnaryExpression = new UnaryExpressionElements());
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	/// * 
	// *
	// * / / *UnaryExpressionHash returns Expr hidden(WS,SL_COMMENT):
	////  HASH? PrimaryExpression
	//  PrimaryExpression | ({UnaryExpressionHash} uop=HASH expr=UnaryExpressionHash)
	//;* / / * 
	// *
	// * / PrimaryExpression returns Expr hidden(WS, SL_COMMENT): / * ( t2+=PrimarySuffix )*    * / PrimaryPrefix;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	/// * 
	// * Can contain an expression in parenthesis, this expression is
	// * 'StatementExpression' which means that it can contain an
	// * inner assignment.
	// * 
	// * The comma option allows us to define a tuple
	// * / PrimaryPrefix hidden(WS, SL_COMMENT):
	//	Literal | LPAREN t4=Expression (COMMA t25+=Expression)* RPAREN => (COLON rightType3=TypeExpression)? |
	//	t7=NameOrFunctionCall;
	public PrimaryPrefixElements getPrimaryPrefixAccess() {
		return (pPrimaryPrefix != null) ? pPrimaryPrefix : (pPrimaryPrefix = new PrimaryPrefixElements());
	}
	
	public ParserRule getPrimaryPrefixRule() {
		return getPrimaryPrefixAccess().getRule();
	}

	/// * function call such as List(Integer)
	// * known as a parameterised type or functor (not necessarily a true functor since
	// * it may not obey the axioms of a functor)
	// * if there is only one parameter then the parenthesis are optional
	// * 
	// * function binds most tightly
	// * / // allow multiple assignment
	////=>(op=GIVES lambda = Expression 'xxx')?
	//NameOrFunctionCall hidden(WS, SL_COMMENT):
	//	"\'"? fnname=ID (=> lsp=DOLAR "Lisp")? / *t2=TypeExpression* / //    LPAREN t4=StatementExpression? (COMMA t5+=Expression)* RPAREN //(COLON rightType2 =TypeExpression)?
	//	(LPAREN t4=Expression? (COMMA t5+=Expression)* //(COLON rightType2 =TypeExpression)?
	//	RPAREN // optional curried function:
	//	(LPAREN t14+=Statement? (COMMA t15+=Expression)* RPAREN)* //  option for parameters in parenthesis
	//	// option of no parenthesis for single parameter
	//	| => t6=PrimaryExpression)? => ((COMMA ID)* COLON rightType2=TypeExpression)?;
	public NameOrFunctionCallElements getNameOrFunctionCallAccess() {
		return (pNameOrFunctionCall != null) ? pNameOrFunctionCall : (pNameOrFunctionCall = new NameOrFunctionCallElements());
	}
	
	public ParserRule getNameOrFunctionCallRule() {
		return getNameOrFunctionCallAccess().getRule();
	}

	/// * Literals are actual values of a given type 
	// * Outstanding issues:
	// * 1) Float literals are parsed as elt(Int,Int) so we need to recognise this
	// *    and convert to float literal
	// * 2) We need to be able to recognise exponent notation for floats
	// * 3) Integers without '-' prefix can be converted to PI or NNI
	// * 4) need to add hex or octal notation for integers (0xhhhh)
	// * 5) String and Character literals need to have backslash "\" doubled to
	// *    "\\" otherwise xtext will interpret backslash as an escape character.
	// * 6) values following immediately after string literal such as "abc"d should
	// *    represent an implied concat: concat("abc",d)
	// * / Literal hidden(WS, SL_COMMENT):
	//	value=INT //  | t3=FloatLiteral // conflicts with use of '.' for elt
	//	| t2=STRING (=> e1=NameOrFunctionCall => (t31+=STRING => e4+=NameOrFunctionCall?)*)? | ListLiteral | CharacterLiteral |
	//	BooleanLiteral;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	/// * Contains a single character whereas a string contains multiple
	// * characters.
	// * / CharacterLiteral hidden(WS, SL_COMMENT):
	//	"\'" c1=ANY_OTHER "\'";
	public CharacterLiteralElements getCharacterLiteralAccess() {
		return (pCharacterLiteral != null) ? pCharacterLiteral : (pCharacterLiteral = new CharacterLiteralElements());
	}
	
	public ParserRule getCharacterLiteralRule() {
		return getCharacterLiteralAccess().getRule();
	}

	/// * This may not need to be specified here at the syntax level. Perhaps we
	// * should treat boolean as any other library defined type.
	// * / BooleanLiteral hidden(WS, SL_COMMENT):
	//	litname="true" | litname="false" | litname="true" LPAREN RPAREN | litname="false" LPAREN RPAREN;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return (pBooleanLiteral != null) ? pBooleanLiteral : (pBooleanLiteral = new BooleanLiteralElements());
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	/// *
	// * a list literal may consist of:
	// * [] an empty list
	// * [a] a single element
	// * [a,b] multiple elements
	// * [a for b in c] a list comprehension
	// * / ListLiteral hidden(WS, SL_COMMENT):
	//	litname=LBRACKET l2=Expression? (COMMA t3+=Expression)* ("for" t14+=Expression "in" l5+=Expression)? RBRACKET;
	public ListLiteralElements getListLiteralAccess() {
		return (pListLiteral != null) ? pListLiteral : (pListLiteral = new ListLiteralElements());
	}
	
	public ParserRule getListLiteralRule() {
		return getListLiteralAccess().getRule();
	}
}
